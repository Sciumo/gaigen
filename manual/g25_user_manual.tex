\documentclass[10pt, a4paper]{article}
\usepackage{palatino}
\usepackage{graphics}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{longtable}
\usepackage{color}
  
\newtheorem{theorem}{Theorem}
\newtheorem{law}{Law}
\newtheorem{assumption}{Assumption}

\raggedbottom

\newcommand{\dist}{\mbox{distance}}
\newcommand{\gav}[1]{\ensuremath{\mathbf{#1}}}
\newcommand{\bev}[1]{\ensuremath{\mathbf{e}_{#1}}}
\newcommand{\op}{\wedge}
\newcommand{\ip}{\cdot}
\newcommand{\dual}[1]{{#1}^*}
\newcommand{\gp}{\,}
\newcommand{\inv}[1]{{#1}^{-1}}
\newcommand{\rev}[1]{\widetilde{#1}}
\newcommand{\no}{\ensuremath{{\bf o}}}
\renewcommand{\ni}{\ensuremath{{\bf  \infty}}}
\renewcommand{\no}{\ensuremath{e_{\bf  o}}}
\renewcommand{\ni}{\ensuremath{e_{\bf  \infty}}}
\newcommand{\grade}[1]{\mbox{\rm grade}}
\newcommand{\gradeop}[2]{{\langle {#1}\rangle_{#2}}}
\newcommand{\NOTE}[1]{\mbox{\bf [[~{#1}~]]}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\half}{{\mbox{$\frac{1}{2}$}}}

\definecolor{black}{gray}{0}
\definecolor{dark}{gray}{0.5}
\definecolor{red}{rgb}{1,0,0}
\definecolor{darkred}{rgb}{0.65,0,0}
\definecolor{blue}{rgb}{0,0,1}
\definecolor{darkgreen}{rgb}{0,0.65,0}
\newcommand{\tcb}[1]{\textcolor{blue}{#1}}
\newcommand{\tcr}[1]{\textcolor{red}{#1}}
\newcommand{\tcdr}[1]{\textcolor{darkred}{#1}}
\newcommand{\tcd}[1]{\textcolor{dark}{#1}}
\newcommand{\tcdg}[1]{\textcolor{darkgreen}{#1}}

\begin{document}

\title{Gaigen 2.5 User Manual}
\author{
Daniel Fontijne\\University of Amsterdam 
}
\date{\today}
\maketitle

\section{Introduction}

Gaigen 2.5 is a code generator for geometric algebra. It compiles an XML specification
of an algebra into an implementation. Supported output languages are C and C++.
Support for C\# and Java will be finished in May 2010. The tool itself is written in C\#.

\section{History, Background, Licensing}

Gaigen stands for \emph{Geometric Algebra Implementation GENerator}.
The first version of Gaigen was written in 2001. It supported only C++ as output language
and the performance of the generated code was two to five times slower than the equivalent
use of linear algebra. At that time it was the fastest general purpose GA implementation available. 
Gaigen 1 supported only the general multivector type and used coordinate  compression and profiling 
to increase performance. The tool itself was written in C++.

The second version of Gaigen was released in 2006. It added support for specialized multivector
types and supported C++ and Java. The tool itself was written in Java.
The generated code was competitive with linear algebra (faster for some problems, slower for others).
Again Gaigen~2 was the fastest general purpose GA implementation available, although a 
C++ template library named Clifford was equally fast (this library is no longer available,
it seems).

This version (2.5) is a re-implementation of Gaigen 2. It removes a lot of `dead weight' and
primarily aims at making Gaigen suitable for a production environment, with an emphasis on
testing, programming language support, scalability and extendibility. Some functions may be
slightly faster in Gaigen~2.5 than Gaigen~2 due to minor optimizations.

The Gaigen~2.5 tool ({\tt g25}) is covered by a GPL license. 
The generated (compiled) code is your own and can be covered by any license.

See \cite{GA4CS} and \cite{fontijnePhD} for background information on (implementation of) geometric algebra.


\section{Installing}

An installer is provided on SourceForge for each platform.
On Linux and OSX, Mono is required because Gaigen 2.5 is written in C\#.
Mono is a free, open source implementation of Microsofts .Net platform.

\begin{itemize}
\item {\bf Windows: } Run {\tt InstallG25.msi}. By default, the files are installed in {\tt c:/program files/g25}.
The system path is updated to include this directory.
\item {\bf Linux: } Make sure Mono and ANTLR are installed, then install the RPM using 
{\tt rpm -i g25-2.5.X.rpm}. Use {\tt rpm -U g25-2.5.X.rpm} to update.
By default three small scripts are installed in {\tt /usr/bin}, the actual program is installed in {\tt /usr/share/g25}.
\item {\bf Mac OS X:} Install Mono, then run {\tt g25.pkg}. Three small scripts are installed in {\tt /usr/bin}, the actual 
program is installed in {\tt /usr/share/g25}.
\end{itemize}

ANTLR is only required to compile grammars for parsing multivector strings.
To avoid its use, simply ask for the built-in parser in the specification.

\section{Running}

To compile an algebra specification, run {\tt g25 specfile.xml} from the command line.
	
The first time you run {\tt g25} it may be a bit slow because it is compiling
a lot of code templates on the fly. Compiled templates are stored in a temporary 
directory and recycled in future runs.
On Linux and OSX, the first run can take a even more time because Mono is a bit
slower than Microsofts CLR implementation.

	
The following command line options are available:

\vspace*{2mm}

\noindent {\tt -h -help -?}: display help.\\
Example: {\tt g25 -h}

\vspace*{2mm}

\noindent {\tt -v, -version}: display version information.\\
Example: {\tt g25 -v}

\vspace*{2mm}

\noindent {\tt -s, -save}: read specification file, then save it.\\
Example: {\tt g25 -s spec\_out.xml spec\_in.xml}

\vspace*{2mm}

\noindent {\tt -f, -filelist}: save a list of generated files to a file.\\
Example: {\tt g25 -f filelist.txt spec.xml}

\section{Generated Files}

\subsubsection*{C}
\subsubsection*{C++}
\subsubsection*{C\#}
\subsubsection*{Java}

\section{Sample Algebras}
\label{s:sample_algebras}

Use the following command to generate a few algebra specifications that may be used
as a starting for your own specs: {\tt g25\_test\_generator -sa }.
This creates a directory {\tt TestG25}. In that directory will be four algebra specifications.
Make files, and scripts to build and test the algebras are also included, for each supported
language.

The sample algebras are:
\begin{itemize}
\item {\bf e2ga}. 2-D Euclidean geometric algebra.
\item {\bf e3ga}. 3-D Euclidean geometric algebra.
\item {\bf p3ga}. Geometric algebra for the homogeneous model of 3-D space (so it is a 4-D algebra).
Multivector types for points, planes, lines and so on are defined.
\item {\bf c3ga} Geometric algebra for the conformal model of 3-D space (so it is a 5-D algebra).
Multivector types for points, spheres, circles, lines and so on are defined.
\end{itemize}

\section{Documentation of Generated Code}

The generated code is self-documenting, although this
feature is not fully finished yet. Run {\tt doxygen } to extract
the documentation from the code.

The generated test code is also a good way to get an example
of use of each function.


\section{Testing the Generated Code}

Gaigen 2.5 can generate a test suite with each algebra.
This is controlled via option {\tt testSuite} in the specification file.

The sample algebras (Section~\ref{s:sample_algebras}) generate the test 
code by default. Building them will result in executables named 
{\tt test } which test whether the generated code is working correctly. 


\subsection{Testing of Gaigen 2.5}

A special tool called {\tt g25\_test\_generator} is included with Gaigen 2.5.
Its purpose is to generate variations on algebra specifications for thorough testing
Gaigen 2.5. It for regression testing during development. 

If you are interested in running it, run {\tt g25\_test\_generator -r 5000 -s} on
the command line.
This should generate a directory named {\tt TestG25}. 
Inside that directory, run the {\tt build} script to see if all the
generated algebras actually build. Run the {\tt test} script to see if
all algebras work correctly. Run the {\tt xml\_test} script to see if
loading and saving specification XML files works correctly.
Run the {\tt clean} script to get rid of all intermediate build and test
files.

The {\tt -r} option reduces the number of algebras generated. Without it,
many thousands of algebras would be generated, which would take a long time to build.
Building takes a long time anyway since the test algebras include an unrealistic
large number of functions.

The command line options to {\tt g25\_test\_generator} are:
\vspace*{2mm}

\noindent {\tt -r -reduce }: reduce the number of test algebras by approximately that factor.
Example: {\tt g25\_test\_generator -r 5000}

\vspace*{2mm}

\noindent {\tt -s -shuffle}: shuffle the order in which the test algebras are built, tested.
Example: {\tt g25\_test\_generator -s}

\vspace*{2mm}

\noindent {\tt -sa -sample\_algebras}: generate the sample algebras instead of the randomly
selected test algebras.
Example: {\tt g25\_test\_generator -sa}

\section{Building from source}

To build Gaigen 2.5 from source, first download the source code as a tarball {\tt g25-2.5.X.tar.gz}
or from SourceForge SVN.

Using Visual Studio or MonoDevelop, open the main project {\tt g25.sln} in {\tt g25/vs2008}.
(When using MonoDevelop you will get a warning that the Windows installer project cannot be loaded.)
Do {\tt Build->Build Solution} to build all. 

If you want to build from the command line on Windows, open a Visual Studio Command Prompt and
go to the directory {\tt g25/vs2008}. Do {\tt msbuild g25.sln /p:Configuration=Release}.

If you want to build from the command line on Linux or OSX, go to the directory {\tt g25/vs2008}
and do 
\begin{verbatim}
export MONO_IOMAP=all  # makes mono tools case/slash insensitive
cd g25/vs2008
xbuild g25.sln /p:Configuration=Release
cd ../../g25_diff/vs2008
xbuild g25_diff.csproj /p:Configuration=Release
cd ../../g25_test_generator/vs2008
xbuild g25_test_generator.csproj /p:Configuration=Release
\end{verbatim}

Installers / packagers for each platform are in {\tt g25/setup\_win}, 
{\tt g25/setup\_osx} and {\tt g25/setup\_linux}.


\section{Writing Algebra Specifications}

The format of the specification file is described in the next section.
A good starting point for writing you own specifications are the sample algebras,
see Section~\ref{s:sample_algebras} for how to obtain them.

If you'd like to write a totally new specification, typically you'd take the top part
of one of the sample algebras (up to where the specialized multivectors ({\tt smv}) are defined).
Then you'd change the dimension of the space to what you need, edit the names of the basis
vectors, and set the metric. Then adjust all the other settings to your needs.

If you need them, add your own specialized multivectors (defining types like points,
vectors, bivectors). 

Finally you need to ask for the functions you want to have implemented using {\tt function} entries.
The easiest way is to ask for these functions to be implemented for general multivectors.
Specialized multivectors automatically convert to general multivectors when passed
as arguments to such functions, so if you do not care about speed they are all you need.

If you want to optimize your code, add specialized functions as needed. You can
also use the {\tt reportUsage} feature to get a report on what functions could be
optimized.

\section{Algebra Specification File XML Format}

An XML specification file starts with the opening element {\tt g25spec}.

This element can have the following attributes:
\begin{itemize}
\item {\bf license}. The license of the generated code. The value can be {\tt custom}, {\tt gpl} or {\tt bsd}. The license is case insensitive.
If the license is custom, a {\tt customLicense} element is expected later on in the specification.

\item {\bf language}. The value can be {\tt c}, {\tt cpp}, {\tt java}, {\tt csharp}, {\tt python}, {\tt matlab} currently. 
(the fact that a value is valid does not means that it is actually implemented . . .). The language names are case insensitive.

\item {\bf namespace}. The name and the namespace/package of the generated code (always required, because it is also used as a prefix/part of generated filenames).

\item {\bf coordStorage}. The value can be {\tt array} (coordinates are stored in arrays) or {\tt variables} (one variable for each coordinate). 
Determines whether coordinates are stored in arrays or in single variables. This only applies to specialized multivectors. 

\item {\bf defaultOperatorBindings}. The value can be {\tt true} or {\tt false}. If {\tt true}, the default operator bindings for the output language are used 
(for example, the {\tt +} symbol is bound to the {\tt add} function).

\item {\bf dimension}. The dimension of the space of the algebra. Must be $>= 1$. 
For values above 7, consider using {\tt gmvCode="runtime"}, see below.
Values above 12 probably lead to code that cannot be compiled because it is too large.

\item {\bf testSuite}. Whether to generate extra code to test the generated code. 
	Can be {\tt true} or {\tt false}.


\item {\bf reportUsage}. The value can be {\tt true} or {\tt false}. 
       When {\tt true}, print statements are added to the code to report usage of non-optimized functions
       (i.e., functions involving specialized multivectors which were implicitly converted to general multivectors). 
       Also, a member variable is added to the general multivector type which keeps track of the original specialized 
       type of the multivector. This option has no effect in the {\tt C} language because it does not support implicit conversion.
 
\item {\bf gmvCode}. Possible values are {\tt expand} and {\tt runtime}. 
      The code for general multivectors can be very large. 
      For example a geometric product of two GMVs in 10-D 
      takes in the order of 1024*1024 multiplications and additions.
      If the code for this product is written explicitly into the code (the default option),
      the code size would also be in the order of megabytes. 
      
      Because of this, Gaigen 1 and Gaigen 2 could only generate algebras up to about 7-D.
      To overcome this limitation, Gaigen 2.5 supports `run-time' computation of geometric products and all other functions without explicitly generating
      code for every single multiply/add. The default option {\tt expand} writes out all code, is fast, but cannot realistically be used above 7-D. 
      
      The option {\tt runtime} performs the computations at run-time, using (among others) tables which must be initialized at startup. 
      If the option {\tt runtime} is used, the metric must be diagonal. To compute the tables of a non-diagonal metric,
      symmetric eigenvalue computation is required, and it would be a burden to require eigenvalue code for every output language. 
      Note that the run-time code is approximately two times slower than the expanded code.
      
\item {\bf parser}. What type of multivector string parser to generate. The default is {\tt none}. Other options are
       {\tt builtin} (for a parser hand-written for Gaigen 2.5) and {\tt antlr} for an ANTLR based parser. Both these parsers have the
       same functionality and interface, but their internal implementation is different. For the ANTLR parser, you need to
       invoke {\tt java org.antlr.Tool} on the generated {\tt .g} grammar and link with the ANTLR run-time.
       
\item {\bf copyright}. The copyright notice of the generated code.
\end{itemize}
 
  
Inside the main {\tt g25spec} element, the following elements can be present:
\begin{itemize}
\item {\bf customLicense}. The custom license text. This element must be present when {\tt license="custom"}. 
         The text is copied verbatim to the top of each the generated file.
         
\item {\bf outputDirectory}. Where the generated files should go. The value {\tt path} attribute is the name of the path
	where the output should go. By default, the output goes to the current working directory.
       
\item {\bf outputFilename}. Allows the name of individual generated files to be modified. For example, if the code generator 
       would generate a file named {\tt foo.cpp}, but the user wants this file to be named {\tt bar.cpp}, then setting 
       attributes {\tt defaultName="foo.cpp"} and {\tt customName="bar.cpp"}
       allows the filename to be overridden. Attributes:
       \begin{itemize}
       \item {\bf defaultName} (required). Default name of the file; do not include the full path.
       \item {\bf customName} (required). Custom name for file; do not include the full path.
       \end{itemize}
         
\item {\bf inline}. What types of functions to inline. Possible attributes are {\tt constructors}, 
      {\tt set}, {\tt assign}, {\tt operators} and {\tt functions}.
      The value of the attributes can be {\tt true} or {\tt false}.
      
\item {\bf floatType}. Specifies the float type used for storing coordinates.
	Multiple float types can be defined in the same algebra. This element can have the following attributes:
       \begin{itemize}
       \item {\bf type}. (required). The value should be a floating point type (e.g. {\tt float} or {\tt double}).
       
       \item {\bf suffix}. (optional). The suffix applied to multivector/outermorphism classes when instantiated with this
            floating point type. For example if there is a specialized multivector type called {\tt vectorE3GA} and the suffix
            for the float type {\tt float} is {\tt \_f} then {\tt vectorE3GA} instantiated with {\tt float}
            will be called {\tt vectorE3GA\_f}.
            
            
       \item {\bf prefix}. (optional). The prefix applied to multivector/outermorphism classes when instantiated with this
            floating point type.
            
       \end{itemize}
       
\item {\bf basisVectorNames}. This element lists the names of basis vectors of the algebra. The number of basis vectors
      must match the dimension {\tt N} of the space. The attributes of the element are {\tt name1}, {\tt name2}, 
      ..., {\tt nameN}. Each attribute is assigned the name of its respective basis vector, for example {\tt name1="e1" name2="e2"}.
      
\item {\bf metric}. A {\tt metric} element specifies the inner product between one or more pairs of basis vectors.
      By default, all inner product between basis vectors are assumed to be 0. By using {\tt metric} elements, one can
      set the inner product to different values. Inside a single algebra, different metrics can be used, e.g. a conformal one and
      a Euclidean one. Having a Euclidean metric is useful, e.g., for blade factorization algorithms.
      
      An example of a metric element is 
\begin{verbatim}
<metric name="default">no.ni=-1</metric>
\end{verbatim}
      This line says that the inner product between basis vectors {\tt no} and {\tt ni} is {\tt -1}.
      The attribute {\tt name="default"} says that this line belongs to the {\tt default} metric and may be
      left out (because the default value for this attribute \emph{is} {\tt "default"}).
      
      One may also specify multiple metrics at once, as in
\begin{verbatim}
<metric>e1.e1=e2.e2=e3.e3=1</metric>
\end{verbatim}
      Inside {\tt function} elements, a non-default metric name may be specified by using the 
      {\tt metric="name"} attribute, e.g., {\tt metric="conformal"}.
      
      Due to floating point round-off errors in eigenvalue computation, values or
      coordinates that should be (e.g.)1.0 may become (e.g., $1 + 1e^{-16}$).
      This makes the generated code less efficient, is annoying to read and propagates
      the round-off errors.
      
      For that reason, there is the option to round coordinates after a metric product.
      The default is to round, but when the final metric is diagonal, it is forced
      to no rounding because there is not need to use it in that case. 
      The user can explicitly force the rounding using the {\tt round="false"} or {\tt round="true"} attribute,
      but when the metric is diagonal, it will still be forced to no rounding.
      When rounding is enabled, coordinates which are very close to an integer
      value are rounded to that value. The threshold for being 'very close' is $1e^{-14}$.
      
\item {\bf unaryOperator}. This element allows you to bind a unary operator symbol to a one-argument function (in
      languages which support this feature). The attributes of this element are:
       \begin{itemize}
       \item {\tt symbol}. The operator symbol, for example {\tt ++}.
       \item {\tt prefix}. Only for operators {\tt ++} and {\tt --}:
            Whether this operator is prefix (e.g. {\tt ++a}) or postifx ({\tt a++}). Use {\tt true}
            for prefix, and {\tt false} for postfix. 
       \item {\tt function}. The name of the function to bind to, for example {\tt increment}.
       \end{itemize}
         
\item {\bf binaryOperator}. This element allows you to bind an binary operator symbol to a two-argument function (in
      languages which support this feature). The attributes of this element are:
       \begin{itemize}
         \item {\tt symbol} The operator symbol, for example {\tt $\wedge$}.
         \item  {\tt function} The name of the function to bind to, for example {\tt op}.
       \end{itemize}
       
      
\item {\bf mv}. This element specifies the properties of the general multivector. It is one of the most involved elements.
      Some examples are given below in Section~\ref{s:mv_coord}.
      Its attributes are:
       \begin{itemize}
         \item {\tt name}. The name of the general multivector type, for example {\tt mv}.
         \item {\tt compress}. How to compress the multivector coordinates: {\tt byGrade} or {\tt byGroup}.
         \item {\tt coordinateOrder}. The order of coordinates: {\tt default} or {\tt custom}.
         \item {\tt memAlloc}. How to allocate memory for coordinates: {\tt full}, {\tt parityPure} or {\tt dynamic}.
       \end{itemize}
         
         
\item {\bf smv}. An {\tt smv} specifies a specialized multivector type. 
      The {\tt smv} element should contain the basis blades of the type. These may have constant assignments, and if the
      type is constant {\tt const="true"}, then all basis blades must have a constant assignment. An example of a specialized
      multivector definition is
\begin{verbatim}
{\tt <smv name="normalizedPoint" type="blade">no=1 e1 e2 e3</smv>}.
\end{verbatim}     
      The attributes of a {\tt smv} element are:
       \begin{itemize}
       \item {\tt name}. The name of the specialized multivector type, for example {\tt vector}.
       \item {\tt const} (optional). Can either be {\tt true} or {\tt false}. When true, the type is a constant type with no
           variable coordinates. In that case, all basis blades must have a constant value assigned to it. If the {\tt const}
           attribute is not specified it is assumed to be {\tt false}. A constant with the {\tt name} will be generated and the
           actual name of the type will have an {\tt \_t} suffix.
       \item {\tt type}. The {\tt type} attribute specified whether instances of the specifialized multivector class will contain
           only blades ({\tt type="blade"}), rotors ({\tt type="rotor"}), versors ({\tt type="versor"}) or any type of multivector  
           ({\tt type="multivector"}) value. This may be used for optimizations and for sanity checks by the code generator.
       \end{itemize}
       
\item {\bf constant}. This element is used to generate a constant value in the output. This is useful is you
      want a constant value of non-constant type. The constant has a name, 
      a type, and a value. Some examples of a constant are:
\begin{verbatim}
<constant name="vectorE1" type="vectorE3GA">e1=1</constant>
<constant name="pointAtOrigin" type="normalizedPoint"></constant>
\end{verbatim}
      Coordinates which are zero do not need to be specified. The attributes of a {\tt constant} element are:
       \begin{itemize}
       \item {\tt name}. The name of the constant.
       \item {\tt type}. The type of the constant. Currently only specialized multivector constants are supported ({\tt smv}).
       \end{itemize}
      The {\tt constant} element contains the values of the coordinates of the constant, and optionally a {\tt comment} element.
      
\item {\bf om}. Specifies the general outermorphism matrix representation type. This allows for efficient
      application of linear transformations using the {\tt applyOM} function.

      The outermorphism has a domain and
      a range, both of which may be specified, but they can also be left to the defaults. An example of an outermorphism with default
      coordinate order is:
      \begin{verbatim}
      <om name="om" coordinateOrder="default" />
      \end{verbatim}
      A 3-D example of an outermorphism with a custom domain and range is:
\begin{verbatim}
<om name="om" coordinateOrder="custom">
<domain>scalar e1 e2 e3 e1^e2 e2^e3 e3^e1 e1^e2^e3</domain>
<range>scalar e1 e2 e3 e1^e2 e2^e3 e3^e1 e1^e2^e3</range>
\end{verbatim}
      In this example, it was redundant to specify the range since it is identical to the domain. Leaving the {\tt range} element
      out would have the same effect. Note that all basis blades must be present in an general outermorphism's range and domain.
      
      The attributes of a {\tt om} element are:
       \begin{itemize}
       \item {\tt name}. The name of the outermorphism type, for example {\tt om}.
       \item {\tt coordinateOrder}. This can be {\tt default} or {\tt custom}. If {\tt custom} is used, the {\tt domain}
            and possibly the {\tt range} should be specified. If the {\tt range} is left out, it is assumed to be identical to the {\tt domain}.
       \end{itemize}
       
\item {\bf som}. A {\tt som} element specifies a specialized outermorphism. It is pretty much that same as a general outermorphism
      except it does not need to have all basis blades in its domain and range. An example of a {\tt som} element is:
\begin{verbatim}
<som name="flatPointOM">
<domain>e1^ni e2^ni e3^ni no^ni</domain>
<range>e1^ni e2^ni e3^ni no^ni</range> 
</som>
\end{verbatim}
      The {\tt som} element has only one attribute, since the {\tt coordinateOrder} is always custom:
       \begin{itemize}
       \item {\tt name}. The name of the outermorphism type, for example {\tt om}.
       \end{itemize}
       
\item {\bf function}. This element specifies a request to the code generator back-end to implement a specific function
       for specific arguments. See Section~\ref{s:functions} for the supported GA functions and Section~\ref{s:converters} for
       information on converters.
       
       The attributes are:
       \begin{itemize}
       \item {\tt name}. The name of the function, as it is known to the code generator (see Section~\ref{s:functions} for a list of function names).
       	     This name is also the name of the generated function unless an {\tt outputName} attribute is specified. 
       	     
       	     To generate a converter (`underscore constructor'), the name of the function should be an underscore plus the name of the destination type, 
       	     e.g., {\tt \_vectorE3GA}. This first (and only) argument should be the source type.
             
       \item {\tt outputName}. Optional. Changes the name of the generated function to the value of the attribute. For example, allows you
            to rename a function {\tt gp} to {\tt geometricProduct}. Sometimes this attribute is required to avoid name-clashes, for example
            if you want the define the same function for two different metrics.
            
       \item {\tt returnType}. Optional. By default, the code generator will determine the return type of the functions it generates, 
       		but it is possible to override this default by setting it explicitly. 
       		
            The return type should be the name of a specialized multivector. However, the return type may also be {\tt scalar} or any of the 
            floating point typenames used in the algebra.
            If the return type is {\tt scalar}, then a float will be returned, automatically adapted to the floating point type of the function.
            
       \item {\tt argN}. Specifies the type of argument {\tt N}. If no {\tt argN} attribute is given, the code generator will fill in the 
       	     default (general) types automatically. Otherwise, the correct number of {\tt argN} attributes should be specified for the function 
       	     (running from 1 up to the number of arguments of the function). 
       	     
       	     Not all combinations of argument types are possible. For example, currently it is not possible
             to mix general and specialized multivectors. It \emph{is} possible to mix floats and general multivectors though.
             
       \item {\tt argNameN}. Specifies the name of argument {\tt N}. This only affects the name of the argument inside
             the generated function. Specifying this name may be superfluous, but it can improve readability, especially for code completion.
             
       \item {\tt optionX}. Specifies an option {\tt X}. For example, the {\tt exp} functions can generate more efficient code
             when it knows what the sign of the square of the argument is. In that case, one may use for example {\tt optionSquare="1.0"}.
             
       \item {\tt floatType}. Multiple {\tt floatType} attributes may be present in a single {\tt function} element. 
            By default, the code generator will generate code for all floating point types of the specification, but using the 
            {\tt floatType} attribute(s) this may be limited to only the set of listed floating point types.
            
       \item {\tt metric}. The optional {\tt metric} attribute specifies the usage of a non-default metric (case insensitive). By default,
            the metric {\tt "default"} is used. By using this attribute a different metric may be used for
            the function, e.g., {\tt metric="euclidean"}.
            
       \item {\tt comment}. Use the this optional attribute to add any extra user comments to the function documentation. For example, one could
            use the comment to explain what a certain function is used for. These comments will appear in the documentation generated by Doxygen.
            
       \end{itemize}
       
\item {\bf verbatim}. This element is used to add verbatim code to the output files. 
	It can be useful,for example to include some headers or packages, or to add some custom functions or documentation. 
	The {\tt verbatim} element can contain the code as text, or can point to a file using the {\tt codeFilename} attribute. 
	The attributes are:
	\begin{itemize}
	
        \item {\tt filenameX}. The filename(s) of the files to modify. Multiple files can be modifed with one {\tt verbatim} element.
         The {\tt X} in the attribute can be any string (including empty). If multiple {\tt filenameX} attributes are specified, multiple
         files are modified.
         
        \item {\tt position}. Where to place the verbatim code. The values can be {\tt top} (at the top of the file), 
            {\tt bottom} (at the bottom of the file), {\tt before} (before some marker string) or
            {\tt after} (before some marker string).
            
        \item {\tt marker}. If {\tt position} is {\tt before} or {\tt after}, then this attribute specifies the string
            before or after which the verbatim code should be inserted.
            
        \item {\tt codeFilename}. The verbatim code can be directly inside the {\tt verbatim} element but for long code
            it may be easier to put the code in a separate file. The name of this file is specified using this attribute.
            
	\end{itemize}
 \end{itemize}
 
 \subsection{Multivector Compression, Coordinate Order and Memory Allocation}
 \label{s:mv_coord}
  
Memory of general multivector variables can be allocated in different ways, each with its own advantages and disadvantages.

Memory can be allocated for all possible coordinates ({\tt memAlloc="full"}). 
For example, this would allocate 32 coordinates for a 5-D algebra.

Memory can also be allocated for halve the coordinates ({\tt memAlloc="parityPure"}), it it is known that multivector values will always be parity-pure 
(only even-grade, or only odd-grade). 

Another option is dynamically allocate just the memory that is required ({\tt memAlloc="dynamic"}).

Compression of multivector coordinates can be done per grade part ({\tt compress="byGrade"}) or per user-defined group ({\tt compress="byGroup"}).

If compression is done by grade, then the attribute value {\tt coordinateOrder="default"} can be used. In that case
the coordinate or does not have to be specified. 

But it is also allowed to have a custom coordinate order. 
In that case the {\tt mv} element must contain a list of basis blades all, i.e., the order of coordinates.
The basis blades should not be in {\tt group} elements, just listed in the order you want them to be. The basis blades
should be listed in ascending grade order. For example:
\begin{verbatim}
<mv compress="byGrade" coordinateOrder="custom" memAlloc="parityPure">
   scalar
   no e1 e2 e3 ni
   no^e1 no^e2 no^e3 e1^e2 e2^e3 e3^e1 e1^ni e2^ni e3^ni no^ni
   e2^e3^ni e3^e1^ni e1^e2^ni no^e3^ni no^e1^ni no^e2^ni no^e2^e3 no^e1^e3 no^e1^e2 e1^e2^e3
   e1^e2^e3^ni no^e2^e3^ni no^e1^e3^ni no^e1^e2^ni no^e1^e2^e3
   no^e1^e2^e3^ni
</mv>
\end{verbatim}
  
If compression is done by group, each group of basis blades must be specified inside the {\tt mv} element inside a {\tt group} element. 
A group cannot contain basis blades of different grades. This example splits the coordinates of the 5-D conformal algebra into
three basic groups ({\tt no}, {\tt ni}, and {\tt e1, e2, e3}) for all grades. For example:
\begin{verbatim}
<mv compress="byGroup" coordinateOrder="custom" memAlloc="parityPure">
    <group>scalar</group>
    <group>no</group>
    <group>e1 e2 e3</group>
    <group>ni</group>
    <group>no^e1 no^e2 no^e3</group>
    <group>e1^e2 e2^e3 e3^e1</group> 
    <group>e1^ni e2^ni e3^ni</group>
    <group>no^ni</group>
    <group>e2^e3^ni e3^e1^ni e1^e2^ni</group>
    <group>no^e3^ni no^e1^ni no^e2^ni</group>
    <group>no^e2^e3 no^e1^e3 no^e1^e2</group>
    <group>e1^e2^e3</group>
    <group>e1^e2^e3^ni</group>
    <group>no^e2^e3^ni no^e1^e3^ni no^e1^e2^ni</group>
    <group>no^e1^e2^e3</group>
    <group>no^e1^e2^e3^ni</group>
</mv>
\end{verbatim}
 
 
\section{Supported Functions}
\label{s:functions}

The section lists the functions that Gaigen 2.5 can generate out of the box
(plugins may add more functions). Each entry lists the name of the function,
gives a short description and some examples.


\subsubsection*{add}

Adds two multivectors.
\begin{verbatim}
<function name="add" arg1="mv" arg2="mv" />
<function name="add" arg1="vectorE3GA" arg2="vectorE3GA" />
<function name="add" arg1="scalar" arg2="bivector" returnType="rotor" />
\end{verbatim}

\subsubsection*{subtract}

Subtracts two multivectors.
\begin{verbatim}
<function name="subtract" arg1="mv" arg2="mv" />
<function name="subtract" arg1="vectorE3GA" arg2="vectorE3GA" />
\end{verbatim}

\subsubsection*{applyOM}

Applies an outermorphism to a multivector.
\begin{verbatim}
<function name="applyOM" arg1="om" arg2="mv"/>
<function name="applyOM" arg1="om" arg2="normalizedPoint"/>
<function name="applyOM" arg1="grade1OM" arg2="vectorE3GA"/>
\end{verbatim}


\subsubsection*{applyVersor}

Applies a versor \gav{V} to a multivector \gav{X}.

\noindent For even versors, returns $\gav{V} \gp \gav{X} \gp \rev{\gav{V}} / (\gav{V} \gp \rev{\gav{V}})$.\\
For odd versors, returns $\gav{V} \gp \hat{\gav{X}} \gp \rev{\gav{V}} / (\gav{V} \gp \rev{\gav{V}})$.\\

\noindent A custom metric can be used via the {\tt metric="name"} attribute.
\begin{verbatim}
<function name="applyVersor" arg1="mv" arg2="mv"/>
<function name="applyUnitVersor" arg1="rotorE3GA" arg2="vectorE3GA"/>
<function name="applyVersor" arg1="rotorE3GA" arg2="normalizedPoint"  
          metric="euclidean"/>
\end{verbatim}

\subsubsection*{applyUnitVersor}

Applies a unit versor \gav{V} to a multivector \gav{X} under the assumption
that $\rev{\gav{V}} = \inv{\gav{V}}$. This identity does not hold generally 
in non-Euclidean metrics, so be careful.

\noindent For even versors, returns $\gav{V} \gp \gav{X} \gp \rev{\gav{V}}$.\\
For odd versors, returns $\gav{V} \gp \hat{\gav{X}} \gp \rev{\gav{V}}$.\\

\noindent A custom metric can be used via the {\tt metric="name"} attribute.
\begin{verbatim}
<function name="applyUnitVersor" arg1="mv" arg2="mv"/>
<function name="applyUnitVersor" arg1="evenVersor" arg2="line"/>
\end{verbatim}

\subsubsection*{applyVersorWI}

Applies a versor \gav{V} to a multivector \gav{X} given the explicit $\gav{VI} = \inv{\gav{V}}$.\\
Note that the function have three arguments (\gav{V}, \gav{X} and \gav{VI}).

\noindent For even versors, returns $\gav{V} \gp \gav{X} \gp \gav{VI}$.\\
For odd versors, returns $\gav{V} \gp \hat{\gav{X}} \gp \gav{VI}$.\\

\noindent A custom metric can be used via the {\tt metric="name"} attribute.
\begin{verbatim}
<function name="applyVersorWI" arg1="mv" arg2="mv" arg3="mv"/>
<function name="applyVersorWI" arg1="rotorE3GA" arg2="bivectorE3GA" 
          arg3="rotorE3GA"/>
\end{verbatim}

\subsubsection*{cgaPoint}

Returns a conformal point. The position of the point can be specified
using coordinates or as a vector.
\begin{verbatim}
<function name="cgaPoint" arg1="vectorE3GA"/>
<function name="cgaPoint" arg1="double" arg2="double" arg3="double" 
          floatType="double"/>
<function name="cgaPoint" arg1="float" arg2="float" arg3="float" 
          optionOrigin="no"  optionInfinity="ni" floatType="float"/>
\end{verbatim}

\subsubsection*{randomCgaPoint}

Returns a conformal point at a random position.
\begin{verbatim}
<function name="randomCgaPoint"/>
\end{verbatim}

\subsubsection*{div}

Divides a multivector by a scalar.
\begin{verbatim}
<function name="div" arg1="mv" arg2="double" 
          floatType="double"/>
<function name="div" arg1="vector" arg2="double" 
          floatType="double"/>
\end{verbatim}

\subsubsection*{dual}

Computes the dual ($\gav{D} = \gav{X} \gp \inv{\gav{I}}$) of a multivector. A custom metric can be specified.
\begin{verbatim}
<function name="dual" arg1="mv" />
<function name="dual" arg1="double" floatType="double" />
<function name="dual" arg1="pointPair" />
\end{verbatim}

\subsubsection*{undual}

Computes the undual ($\gav{U} = \gav{X} \gp \gav{I}$) of a multivector. A custom metric can be specified.
\begin{verbatim}
<function name="undual" arg1="mv" />
<function name="undual" outputName="undual_em" arg1="sphere" 
          metric="euclidean"/>
\end{verbatim}

\subsubsection*{equals}

Check for equality of two multivectors, up to a scalar epsilon (difference threshold) value.
\begin{verbatim}
<function name="equals" arg1="mv" arg2="mv" arg3="double" 
          floatType="double"/>
<function name="equals" arg1="rotor" arg2="bivector" arg3="double" 
          floatType="double"/>
\end{verbatim}

\subsubsection*{extractGrade}

Extracts one or more grade parts from a multivector.
\begin{verbatim}
<function name="extractGrade" arg1="mv"/>
<function name="extractGrade" arg1="evenVersor"/>
\end{verbatim}

\subsubsection*{extractGradeX}

Extracts grade X from a multivector.
\begin{verbatim}
<function name="extractGrade1" arg1="mv"/>
<function name="extractGrade4" arg1="evenVersor"/>
\end{verbatim}

\subsubsection*{gp}

Computes the geometric product of two multivectors. A custom metric can be specified.
\begin{verbatim}
<function name="gp" arg1="mv" arg2="mv"/>
<function name="gp" arg1="vectorE3GA" arg2="vectorE3GA" 
          returnType="evenVersor"/>
<function name="gp" outputName="gp_em" arg1="mv" arg2="mv" 
          metric="euclidean"/>
\end{verbatim}

\subsubsection*{gradeBitmap}

Computes a bitmap which specifies which grade parts of a multivector are non-zero, up to a scalar epsilon (difference threshold) value.
\begin{verbatim}
<function name="gradeBitmap" arg1="mv" arg2="double" 
          floatType="double"/>
<function name="gradeBitmap" arg1="rotor" arg2="double"
          floatType="double"/>
\end{verbatim}

\subsubsection*{hp}

Computes the hadamard product (coordinate-wise multiplication) of two multivectors. This
is not a true geometric algebra operations, and the hadamard product is not well-defined
when the orientation of basis-blades does not match between the two multivectors. It is useful
nonetheless, for example when modulating color vectors in computer graphics.
\begin{verbatim}
<function name="hp" arg1="mv" arg2="mv"/>
<function name="hp" arg1="vector" arg2="vector"/>
\end{verbatim}

\subsubsection*{ihp}

Computes the inverse hadamard product (coordinate-wise division) of two multivectors. 
See the limitations for {\tt hp} above.
\begin{verbatim}
<function name="ihp" arg1="mv" arg2="mv"/>
<function name="ihp" arg1="plane" arg2="sphere"/>
\end{verbatim}


\subsubsection*{igp}

Computes the inverse geometric product of two multivectors ($\gav{A} \gp \rev{\gav{B}} / (\gav{B} \gp \rev{\gav{B}})$).
A custom metric can be specified.
\begin{verbatim}
<function name="igp" arg1="mv" arg2="mv"/>
<function name="igp" arg1="line" arg2="circle" 
          metric="euclidean">
\end{verbatim}

\subsubsection*{increment}

Increments a multivector value by one.
\begin{verbatim}
<function name="increment" arg1="mv"/>
<function name="increment" arg1="bivector" returnType="rotor"/>
<function name="increment" arg1="rotor"/>
\end{verbatim}

\subsubsection*{decrement}

Decrements a multivector value by one.
\begin{verbatim}
<function name="increment" arg1="mv"/>
<function name="increment" arg1="bivector" returnType="rotor"/>
<function name="increment" arg1="rotor"/>
\end{verbatim}

\subsubsection*{hip}

Computes the Hestenes inner product of two multivectors (which is zero for scalars).
A custom metric can be specified.
\begin{verbatim}
<function name="hip" outputName="ip" arg1="mv" arg2="mv"/>
<function name="hip" outputName="ip" arg1="oddVersor"
          arg2="rotorE3GA"/>
\end{verbatim}

\subsubsection*{mhip}

Computes the modified Hestenes inner product of two multivectors.
A custom metric can be specified.
\begin{verbatim}
<function name="mhip" arg1="mv" arg2="mv"/>
<function name="mhip" arg1="bivector" arg2="scalar"/>
\end{verbatim}

\subsubsection*{lc}

Computes the left contraction inner product of two multivectors.
The left contraction is zero when the grade of the left argument
is higher than the grade of the right argument.
A custom metric can be specified.
\begin{verbatim}
<function name="lc" arg1="mv" arg2="mv"/>
<function name="lc" arg1="vector" arg2="bivector"/>
\end{verbatim}

\subsubsection*{rc}

Computes the right contraction inner product of two multivectors.
The right contraction is zero when the grade of the right argument
is higher than the grade of the left argument.
A custom metric can be specified.
\begin{verbatim}
<function name="rc" arg1="mv" arg2="mv"/>
<function name="rc" arg1="bivector" arg2="vector"/>
\end{verbatim}

\subsubsection*{sp}

Computes the scalar product (scalar part of the geometric product) of two multivectors.
A custom metric can be specified.
\begin{verbatim}
<function name="sp" arg1="mv" arg2="mv"/>
<function name="sp" outputName="dotProduct" 
          arg1="vector" arg2="vector"
          metric="euclidean"/>
\end{verbatim}


\subsubsection*{norm}

Computes the norm of a multivector.
The absolute norm squared is used, i.e., the value returned is $\sqrt{ \mid < \gav{X} \gp \rev{\gav{X}} >_{0} \mid}$.
A custom metric can be specified.
\begin{verbatim}
<function name="norm" arg1="mv"/>
<function name="norm" arg1="rotor"/>
\end{verbatim}

\subsubsection*{signedNorm}

Not implemented yet.

\subsubsection*{norm2}

Computes the squared norm of a multivector.
The value returned is $< \gav{X} \gp \rev{\gav{X}} >_{0}$.
A custom metric can be specified.
\begin{verbatim}
<function name="norm2" arg1="mv"/>
<function name="norm2" outputname="norm2_em"
          arg1="evenVersor" metric="euclidean"/>
\end{verbatim}

\subsubsection*{op}

Computes the outer product of two multivectors.
\begin{verbatim}
<function name="op" arg1="mv" arg2="mv"/>
<function name="op" arg1="vector" arg2="vector" />
\end{verbatim}

\subsubsection*{random\_blade}

Generates a random blade (stored in the general multivector type).
\begin{verbatim}
<function name="random_blade"/>
<function name="random_blade" floatType="float"/>
\end{verbatim}


\subsubsection*{random\_versor}

Generates a random versor (stored in the general multivector type).
A custom metric can be specified.
\begin{verbatim}
<function name="random_versor"/>
<function name="random_versor" outputName="random_versor_eucl" metric="euclidean"/>
\end{verbatim}


\subsubsection*{random\_scalar}

Generates a random floating point value. The {\tt scalar} part of the function
name should be replaced with a floating point type, as in the examples below.
Use the option {\tt optionGen } to specify the random generator. Currently
supported are Mersenne Twister {\tt mt} and the C standard library random
generator {\tt libc}.
\begin{verbatim}
<function name="random_double" outputName="genrand" optionGen="libc"/>
<function name="random_float" optionGen="mt"/>
\end{verbatim}

\subsubsection*{random\_smv}

Generates a random specialized multivector. The {\tt smv} part of the function
name should be replaced with the name of the specialized multivector type.

For scalar, pseudoscalar, vector, dual vector and types defined with
{\tt type="multivector"}, random coordinates are generated.

For all other types, random vectors are generated and multiplied using the 
geometric product. A custom metric can be specified.
\begin{verbatim}
<function name="random_dualSphere" floatType="double"/>
<function name="random_normalizedPoint" floatType="float"/>
<function name="random_sphere"/>
\end{verbatim}

\subsubsection*{sas}

{\tt sas} stands for \emph{scale, add scalar}. 
It is a function that is used internally
by the {\tt exp}, {\tt cos} and {\tt sin} functions.
It scales a multivector by a certain factor, then adds a scalar.
\begin{verbatim}
<function name="sas" arg1="mv" arg2="double" arg3="double" floatType="double"/>
<function name="sas" arg1="bivectorE3GA" arg2="double" arg3="double" floatType="double"/>
\end{verbatim}

\subsubsection*{exp}

Computes the exponential of a multivector.
A custom metric can be specified.

An option {\tt optionSquare="value"} can be used to specify the 
sign of the square. {\tt value} can be {\tt -1}, {\tt 0}, {\tt 1}.
If the sign of the square is known, much more effective code can be genererated, avoiding 
a (slow and inprecise) series evaluation. Most of the time though the option is
not needed since Gaigen can figure out the sign of the square on its own using symbolic GA. 
\begin{verbatim}
<function name="exp" arg1="mv" />
<function name="exp" outputName="exp_em" arg1="mv" metric="euclidean" />
<function name="exp" arg1="pointPair" />
<function name="exp" arg1="bivectorE3GA" optionSquare="1"/>
\end{verbatim}

\subsubsection*{sin}

Computes the sine of a multivector.
A custom metric can be specified.
\begin{verbatim}
<function name="sin" arg1="mv" />
<function name="sin" arg1="flatPoint" />
<function name="sin" arg1="bivectorE3GA" optionSquare="1"/>
\end{verbatim}

\subsubsection*{cos}

Computes the cosine of a multivector.
A custom metric can be specified.
\begin{verbatim}
<function name="cos" arg1="mv" />
<function name="cos" outputName="cos_em" arg1="bivector" metric="euclidean"/>
\end{verbatim}

\subsubsection*{sinh}

Computes the hyperbolic sine of a multivector.
A custom metric can be specified.
\begin{verbatim}
<function name="sinh" arg1="mv" />
<function name="sinh"arg1="bivector"/>
\end{verbatim}

\subsubsection*{cosh}

Computes the hyperbolic cosine of a multivector.
A custom metric can be specified.
\begin{verbatim}
<function name="cosh" arg1="mv" />
\end{verbatim}

\subsubsection*{negate}

Negate a multivector.
\begin{verbatim}
<function name="negate" arg1="mv"/>
<function name="negate" arg1="vector"/>
\end{verbatim}

\subsubsection*{reverse}

Reverses a multivector.
\begin{verbatim}
<function name="reverse" arg1="mv"/>
<function name="reverse" arg1="rotor"/>
\end{verbatim}

\subsubsection*{cliffordConjugate}

Computes the Clifford conjugate of a multivector.
\begin{verbatim}
<function name="cliffordConjugate" arg1="mv"/>
<function name="cliffordConjugate" arg1="evenVersor"/>
\end{verbatim}

\subsubsection*{gradeInvolution}

Computes the grade involution of a multivector.
\begin{verbatim}
<function name="gradeInvolution" arg1="mv"/>
<function name="gradeInvolution" arg1="vector"/>
\end{verbatim}

\subsubsection*{unit}

Computes the unit of a multivector. The norm is evaluated using
the {\tt norm} function. A custom metric can be specified.
\begin{verbatim}
<function name="unit" arg1="mv"/>
<function name="unit" outputName="unit_em" arg1="rotor" metric="euclidean"/>
\end{verbatim}

\subsubsection*{versorInverse}

Computes the versor inverse of a multivector ($\gav{X} / (\gav{X} \gp \rev{\gav{X}})$). 
The norm is evaluated using the {\tt norm} function. A custom metric can be specified.
\begin{verbatim}
<function name="versorInverse" arg1="mv"/>
<function name="versorInverse" arg1="rotor"/>
\end{verbatim}


\subsubsection*{zero}

Checks whether a multivector is zero, up to a scalar epsilon (difference threshold) value.
\begin{verbatim}
<function name="zero" arg1="mv" arg2="double" 
          floatType="double"/>
<function name="zero" arg1="rotor" arg2="float" 
          floatType="float"/>
\end{verbatim}


\section{Converters}
\label{s:converters}

Todo
Example: convert from normalizedPoint -> vector
convert from bivector -> rotor

Underscore constructors



\section{Why did you write Gaigen 2.5 in C\#?}

I wrote Gaigen 2.5 in C\# because I wanted to try out the .Net platform
(it's pretty nice).
I assumed that Mono would be good enough to run Gaigen 2.5 on OS X and
Linux, but it is slightly disappointing in speed. Hopefully the Mono
team will improve Mono's performance in the future.




\begin{thebibliography}{}


	
\bibitem{GA4CS} L.~Dorst and D.~Fontijne and S.~Mann.
	\emph{Geometric Algebra for Computer Science: An Object Oriented Approach to Geometry.}
	Morgan Kaufmann, revised edition 2009.

\bibitem{fontijnePhD} D.~Fontijne.
	\emph{Efficient Implementation of Geometric Algebra.}
	PhD. Thesis, University of Amsterdam, 2007.


\end{thebibliography}


\end{document}

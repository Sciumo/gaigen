\documentclass[10pt, a4paper]{article}
\usepackage{palatino}
\usepackage{graphics}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{longtable}
\usepackage{color}
  
\newtheorem{theorem}{Theorem}
\newtheorem{law}{Law}
\newtheorem{assumption}{Assumption}

\raggedbottom

\newcommand{\dist}{\mbox{distance}}
\newcommand{\gav}[1]{\ensuremath{\mathbf{#1}}}
\newcommand{\bev}[1]{\ensuremath{\mathbf{e}_{#1}}}
\newcommand{\op}{\wedge}
\newcommand{\ip}{\cdot}
\newcommand{\dual}[1]{{#1}^*}
\newcommand{\gp}{\,}
\newcommand{\inv}[1]{{#1}^{-1}}
\newcommand{\rev}[1]{\widetilde{#1}}
\newcommand{\no}{\ensuremath{{\bf o}}}
\renewcommand{\ni}{\ensuremath{{\bf  \infty}}}
\renewcommand{\no}{\ensuremath{e_{\bf  o}}}
\renewcommand{\ni}{\ensuremath{e_{\bf  \infty}}}
\newcommand{\grade}[1]{\mbox{\rm grade}}
\newcommand{\gradeop}[2]{{\langle {#1}\rangle_{#2}}}
\newcommand{\NOTE}[1]{\mbox{\bf [[~{#1}~]]}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\half}{{\mbox{$\frac{1}{2}$}}}

\definecolor{black}{gray}{0}
\definecolor{dark}{gray}{0.5}
\definecolor{red}{rgb}{1,0,0}
\definecolor{darkred}{rgb}{0.65,0,0}
\definecolor{blue}{rgb}{0,0,1}
\definecolor{darkgreen}{rgb}{0,0.65,0}
\newcommand{\tcb}[1]{\textcolor{blue}{#1}}
\newcommand{\tcr}[1]{\textcolor{red}{#1}}
\newcommand{\tcdr}[1]{\textcolor{darkred}{#1}}
\newcommand{\tcd}[1]{\textcolor{dark}{#1}}
\newcommand{\tcdg}[1]{\textcolor{darkgreen}{#1}}

\begin{document}

\title{Gaigen 2.5 User Manual}
\author{
Daniel Fontijne\\University of Amsterdam 
}
\date{\today}
\maketitle

\section{Introduction}

Gaigen 2.5 is a code generator for geometric algebra. It compiles an XML specification
of an algebra into an implementation. Supported output languages are C and C++.
Support for C\# and Java will be finished in May 2010. The tool itself is written in C\#.

\section{History, Background, Licensing}

Gaigen stands for \emph{Geometric Algebra Implementation GENerator}.
The first version of Gaigen was written in 2001. It supported only C++ as output language
and the performance of the generated code was two to five times slower than the equivalent
use of linear algebra. At that time it was the fastest general purpose GA implementation available. 
Gaigen 1 supported only one multivector type and used coordinate  compression and profiling to increase performance.
The tool itself was written in C++.

The second version of Gaigen was written in 2006. It added support for specialized multivector
types and supported C++ and Java. The tool itself was written in Java.
The generated code was competitive with linear algebra (faster for some problems, slower for others).
Again Gaigen~2 was the fastest general purpose GA implementation available, although a 
C++ template library named Clifford was equally fast (this library is no longer available,
it seems).

This version (2.5) is a re-implementation of Gaigen 2. It removes a lot of 'dead weight' and
primarily aims at making Gaigen suitable for a production environment, with an emphasis on
testing, programming language support, scalability and extendibility. Some functions may be
slightly faster in Gaigen~2.5 than Gaigen~2 due to minor optimizations.

The Gaigen~2.5 tool ({\tt g25}) is covered by a GPL license. 
The generated (compiled) code is your own and can be covered by any license.

See \cite{GA4CS} and \cite{fontijnePhD} for background information on (implementation of) geometric algebra.


\section{Installing}

An installer is provided on SourceForge for each platform.
On Linux and OSX, Mono is required because Gaigen 2.5 is written in C\#.
Mono is a free, open source implementation of Microsofts .Net platform.

\begin{itemize}
\item {\bf Windows: } Run {\tt InstallG25.msi}. By default, the files are installed in {\tt c:/program files/g25}.
The system path is updated to include this directory.
\item {\bf Linux: } Make sure Mono and ANTLR are installed, then install the RPM using 
{\tt rpm -i g25-2.5.X.rpm}. Use {\tt rpm -U g25-2.5.X.rpm} to update.
By default three small scripts are installed in {\tt /usr/bin}, the actual program is installed in {\tt /usr/share/g25}.
\item {\bf Mac OS X:} Install Mono, then run {\tt g25.pkg}. Three small scripts are installed in {\tt /usr/bin}, the actual 
program is installed in {\tt /usr/share/g25}.
\end{itemize}

ANTLR is only required to compile grammars for parsing multivector strings.
To avoid its use, simply ask for the built-in parser in the specification.

\section{Running}

To compile an algebra specification, run {\tt g25 specfile.xml} from the command line.
	
The first time you run {\tt g25} it may be a bit slow because it is compiling
a lot of code templates on the fly. Compiled templates are stored in a temporary 
directory and recycled in future runs.
On Linux and OSX, the first run can take a even more time because Mono is a bit
slower than Microsofts CLR implementation.

	
The following command line options are available:

\vspace*{2mm}

\noindent {\tt -h -help -?}: display help.\\
Example: {\tt g25 -h}

\vspace*{2mm}

\noindent {\tt -v, -version}: display version information.\\
Example: {\tt g25 -v}

\vspace*{2mm}

\noindent {\tt -s, -save}: read specification file, then save it.\\
Example: {\tt g25 -s spec\_out.xml spec\_in.xml}

\vspace*{2mm}

\noindent {\tt -f, -filelist}: save a list of generated files to a file.\\
Example: {\tt g25 -f filelist.txt spec.xml}

\section{Sample Algebras}
\label{s:sample_algebras}

Use the following command to generate a few algebra specifications that may be used
as a starting for your own specs: {\tt g25\_test\_generator -sa }.
This creates a directory {\tt TestG25}. In that directory will be four algebra specifications.
Make files, and scripts to build and test the algebras are also included, for each supported
language.

The sample algebras are:
\begin{itemize}
\item {\bf e2ga} 2-D Euclidean geometric algebra.
\item {\bf e3ga} 3-D Euclidean geometric algebra.
\item {\bf p3ga} Geometric algebra for the homogeneous model of 3-D space (so it is a 4-D algebra).
Multivector types for points, planes, lines and so on are defined.
\item {\bf c3ga} Geometric algebra for the conformal model of 3-D space (so it is a 5-D algebra).
Multivector types for points, spheres, circles, lines and so on are defined.
\end{itemize}

\section{Documentation of Generated Code}

The generated code is self-documenting, although this
feature is not fully finished yet. Run {\tt doxygen } to extract
the documentation from the code.

The generated test code is also a good way to get an example
of use of each function.

\section{Testing the Generated Code}

Gaigen 2.5 can generate a test suite with each algebra.
This is controlled via an option in the specification file.

The sample algebras (Section~\ref{s:sample_algebras}) generate the test 
code by default. Building them will result in an executables named 
{\tt test } which try to test whether the code is working correctly. 


\subsection{Testing of Gaigen 2.5}

A special tool called {\tt g25\_test\_generator} is included with Gaigen 2.5.
Its purpose is to generate variations on algebra specifications for thorough testing
Gaigen 2.5. It for regression testing during development. 

If you are interested in running it, run {\tt g25\_test\_generator -r 5000 -s} on
the command line.
This should generate a directory named {\tt TestG25}. 
Inside that directory, run the {\tt build} script to see if all the
generated algebras actually build. Run the {\tt test} script to see if
all algebras work correctly. Run the {\tt xml\_test} script to see if
loading and saving specification XML files works correctly.
Run the {\tt clean} script to get rid of all intermediate build and test
files.

The {\tt -r} option reduces the number of algebras generated. Without it,
many thousands of algebras would be generated, which would take a long time to build.
Building takes a long time anyway since the test algebras include an unrealistic
large number of functions.

The command line options to {\tt g25\_test\_generator} are:
\vspace*{2mm}

\noindent {\tt -r -reduce }: reduce the number of test algebras by approximately that factor.
Example: {\tt g25\_test\_generator -r 5000}

\vspace*{2mm}

\noindent {\tt -s -shuffle}: shuffle the order in which the test algebras are built, tested.
Example: {\tt g25\_test\_generator -s}

\vspace*{2mm}

\noindent {\tt -sa -sample\_algebras}: generate the sample algebras instead of the randomly
selected test algebras.
Example: {\tt g25\_test\_generator -sa}

\section{Building from source}

To build Gaigen 2.5 from source, first download the source code as a tarball {\tt g25-2.5.X.tar.gz}
or from SourceForge SVN.

Using Visual Studio or MonoDevelop, open the main project {\tt g25.sln} in {\tt g25/vs2008}.
(When using MonoDevelop you will get a warning that the Windows installer project cannot be loaded.)
Do {\tt Build->Build Solution} to build all. 

If you want to build from the command line on Windows, open a Visual Studio Command Prompt and
go to the directory {\tt g25/vs2008}. Do {\tt msbuild g25.sln /p:Configuration=Release}.

If you want to build from the command line on Linux or OSX, go to the directory {\tt g25/vs2008}
and do 
\begin{verbatim}
export MONO_IOMAP=all  # makes mono tools case and slash insensitive
cd g25/vs2008
xbuild g25.sln /p:Configuration=Release
cd ../../g25_diff/vs2008
xbuild g25_diff.csproj /p:Configuration=Release
cd ../../g25_test_generator/vs2008
xbuild g25_test_generator.csproj /p:Configuration=Release
\end{verbatim}

Installers / packagers for each platform are in {\tt g25/setup\_win}, 
{\tt g25/setup\_osx} and {\tt g25/setup\_linux}.


\section{XML file format}

A good starting point for writing you own specifications are the sample algebras
(Section~\ref{s:sample_algebras}). The format of the specification file is described
here.

The XML specification starts with the opening element {\tt g25spec}.

This element can have the following attributes, most of which are required:
\begin{itemize}
\item {\bf license} The license of the generated code. The value can be {\tt custom}, {\tt gpl} or {\tt bsd}. The license is case insensitive.
If the license is custom, a {\tt customLicense} element is expected later on in the specification.

\item {\bf language} The value can be {\tt c}, {\tt cpp}, {\tt java}, {\tt csharp}, {\tt python}, {\tt matlab} currently. 
(the fact that a value is valid does not means that it is actually implemented . . .). The language names are case insensitive.

\item {\bf namespace} The name and the namespace/package of the generated code (always required, because it is also used as a prefix/part of generated filenames).

\item {\bf coordStorage} The value can be {\tt array} (coordinates are stored in arrays) or {\tt variables} (one variable for each coordinate). 
Determines whether coordinates are stored in arrays or in single variables. This only applies to specialized multivectors. 

\item {\bf defaultOperatorBindings}. The value can be {\tt true} or {\tt false}. If {\tt true}, the default operator bindings for the output language are used 
(for example, the {\tt +} symbol is bound to the {\tt add} function).

\item {\bf dimension} The dimension of the space of the algebra. Must be $>= 1$. 
For values above 7, consider using {\tt gmvCode="runtime"}.
Values above 12 probably lead to code that cannot be compiled because it is too large.

\item {\bf reportUsage} The value can be {\tt true} or {\tt false}. If {\tt true}, print statements are added to the code to report usage of non-optimized functions
       (i.e., functions involving specialized multivectors which were implicitly converted to general multivectors). 
       When {\tt true}, a field is added to the general multivector type which keeps track of the original specialized 
       type of the multivector. This option has no effect in the {\tt C} language because it does not support implicit conversion.
 
\item {\bf gmvCode} Possible values are {\tt expand} and {\tt runtime}. The code for general multivectors can be very large. For example a geometric product of two GMVs in 10-D 
      takes in the order of 1024*1024 multiplication and additions. If the code for this product is written explicitly into the code (the default option),
      the code size would also be in the order of megabytes. Because of this, Gaigen 1 and Gaigen 2 could only generate algebras up to about 7-D.
      To overcome this limitation, Gaigen 2.5 supports 'run-time' computation of geometric products and all other functions without explicitly generating
      code for every single multiply/add. The default option {\tt expand} writes out all code, is fast, but cannot realistically be used above 7-D. 
      The option {\tt runtime} performs the computations at run-time, using (among others) tables which must be initialized at startup. 
      If the option {\tt runtime} is used, the metric must be diagonal. Otherwise Gaigen 2.5 cannot compute these tables at runtime
      This is because non-diagonal metrics requires symmetric eigenvalue computations, and 
      it would be a burden to require eigenvalue code for every output language. Note that the run-time code is slower than the expanded code.
      
\item {\bf parser} What type of multivector string parser to generate. The default is {\tt none}. Other options are
       {\tt builtin} (for a parser hand-written for Gaigen 2.5) and {\tt antlr} for an ANTLR based parser. Both these parsers have the
       same functionality and interface, but their internal implementation is different. For the ANTLR parser, you need to
       invoke {\tt java org.antlr.Tool} on the generated {\tt .g} grammar and link with the ANTLR run-time.
       
\item {\bf copyright} The copyright statement of the generated code.
\end{itemize}
 
  
Inside the main <c>g25spec</c> element, the following elements can be present:
\begin{itemize}
\item {\bf customLicense} The custom license text. This element must be present when {\tt license="custom"}. 
         The text is copied verbatim to the top of each the generated file.
         
\item {\bf outputDirectory} Where the generated files should go. The value {\tt path} attribute is the name of the path
	where the output should go
       By default, the output goes to the current working directory.
       
\item {\bf outputFilename} Allows the name of individual generated files to be modified. For example, if the code generator 
       would generate a file named 'foo.cpp', but the user wants this file to be named 'bar.cpp', then setting 
       attributes {\tt defaultName="foo.cpp"} and {\tt customName="bar.cpp"}
       allows the filename to be overridden. Attributes:
       \begin{itemize}
       \item {\bf defaultName} (required). Default name of the file (do not include the full path).
       \item {\bf customName} (required). Custom name for file (do not include the full path).
       \end{itemize}
         
\item {\bf inline} What types of functions to inline. Possible attributes are {\tt constructors}, 
      {\tt set}, {\tt assign}, {\tt operators} and {\tt functions}.
      The value of the attributes can be {\tt true} or {\tt false}.
      
\item {\bf floatType} This element can have the following attributes:
       \begin{itemize}
       \item {\bf type} (required). The value should be a floating point type (e.g. {\tt float} or {\tt double}).
       
       \item {\bf suffix} (optional). The suffix applied to multivector/outermorphism classes when instantiated with this
            floating point type. For example if there is a specialized multivector called {\tt vectorE3GA} and the suffix
            for the float type {\tt double} is {\tt \_f} then {\tt vectorE3GA} instantiated with {\tt double}
            will be called {\tt vectorE3GA\_f}.
            
            
       \item {\bf prefix} (optional). The prefix applied to multivector/outermorphism classes when instantiated with this
            floating point type.
            
       \end{itemize}
       
\item {\bf unaryOperator} This element allows you to bind a unary operator symbol to a one-argument function (in
      languages which support this feature). The attributes of this element are:
       \begin{itemize}
       \item {\tt symbol}. The operator symbol, for example {\tt ++}.
       \item {\tt prefix}. Only for operators {\tt ++} and {\tt --}:
            Whether this operator is prefix (e.g. {\tt ++a}) or postifx ({\tt a++}). Use {\tt true}
            for prefix, and {\tt false} for postfix. 
       \item {\tt function}. The name of the function to bind to, for example {\tt increment}.
       \end{itemize}
         
\item {\bf binaryOperator} This element allows you to bind an binary operator symbol to a two-argument function (in
      languages which support this feature). The attributes of this element are:
       \begin{itemize}
         \item {\tt symbol} The operator symbol, for example {\tt ^}.
         \item  {\tt function} The name of the function to bind to, for example {\tt op}.
       \end{itemize}
       
\item {\bf basisVectorNames}. This element lists the names of basis vectors of the algebra. The number of basis vectors
      must match the dimension {\tt N} of the space. The attributes of the element are {\tt name1}, {\tt name2}, 
      ..., {\tt nameN}. Each attribute is assigned the name of its respective basis vector, for example {\tt name1="e1" name2="e2"}.
      
\item {\bf metric} A {\tt metric} element specifies the inner product between one or more pairs of basis vectors.
      By default, all inner product between basis vectors are assumed to be 0. By using {\tt metric} elements, one can
      set the inner product to different values. Inside one algebra, different metrics can be used, e.g. a conformal one and
      a Euclidean one. This is used internally by Gaigen for generating the code for e.g. factorization, but may also be
      useful for end-users.
      
      An example of a metric element is {\tt <metric name="default">no.ni=-1</metric>}.
      This line says that the inner product between basis vectors {\tt no} and {\tt ni} is {\tt -1}.
      The attribute {\tt name="default"} says that this line belongs to the "default" metric and may be
      left out (because the default value for this attribute is {\tt "default"}.
      
      One may also specify multiple metrics at once, as in
      {\tt <metric>e1.e1=e2.e2=e3.e3=1</metric>}.
      
      Inside {\tt function} elements, a non-default metric may be specified by using the 
      {\tt metric="name"} attribute.
      
      Due to floating point roundoff errors in eigenvalue computation, a value or
      coordinates that should be (e.g.)1.0 may become (e.g., $1 + 1e^{-16}$).
      This makes the generated code less efficient, is annoying to read and propagates
      the roundoff errors.
      For that reason, there is the option to round coordinates after a metric product.
      The default is to round, but when the final metric is diagonal, it is forced
      to no rounding because there is not need to use it in that case. 
      The user can explicitly force the rounding using the {\tt round="false"} or {\tt round="true"} attribute,
      but when the metric is diagonal, it will still be forced to no rounding.
      When rounding is enabled, coordinates which are very close to an integer
      value are 'rounded' to that value. The threshold for being 'very close' is $1e^{-14}$.
      
\item {\bf mv} This element specifies the properties of the general multivector. It is one of the most involved elements.
      Its attributes are:
       \begin{itemize}
         \item {\tt name}. The name of the general multivector type, for example {\tt mv}.
         \item {\tt compress}. How to compress the multivector coordinates: {\tt byGrade} or {\tt byGroup} (explained in detail Section~\ref{sec:mv_coord_sec} below).
         \item {\tt coordinateOrder}. The order of coordinates: {\tt default} or {\tt custom} (explained in detail \ref mv_coord_sec "below").
         \item {\tt memAlloc}. How to allocate memory for coordinates: {\tt full}, {\tt parityPure} or {\tt dynamic} (explained in detail Section~\ref{sec:mv_coord_sec} below).
       \end{itemize}
         
         
\item {\bf smv} An {\tt smv} specifies a specialized multivector type. 
      The {\tt smv} element should contain the basis blades of the type. These may have constant assignments, and if the
      type is constant {\tt const="true"}, then all basis blades must have a constant assignment. An example of a specialized
      multivector definition is {\tt <smv name="normalizedPoint" type="blade">no=1 e1 e2 e3</smv>}.
      
      The attributes of a {\tt smv} element are:
       \begin{itemize}
       \item {\tt name}. The name of the specialized multivector type, for example {\tt vector}.
       \item {\tt const} (optional). Can either be {\tt true} or {\tt false}. When true, the type is to be a constant type with no
           variable coordinates. In that case, all basis blades must have a constant value assigned to it. If the {\tt const}
           attribute is not specified it is assumed to be {\tt false}.
       \item {\tt type}. The {\tt type} attribute specified whether instances of the specifialized multivector class will carry
           blade ({\tt type="blade"}), rotor ({\tt type="rotor"}), versor ({\tt type="versor"}) or any multivector 
           ({\tt type="multivector"}) values. This may be used for optimizations and sanity checks by code generator back-ends.
       \end{itemize}
       
\item {\bf constant} This element is used to generate a constant value in the output. This is useful is you
      want a constant value of non-constant type. The constant has a name, 
      a type, and a value. Some examples of a constant are:
      \begin{verbatim}
      <constant name="vectorE1" type="vectorE3GA">e1=1</constant>
      <constant name="pointAtOrigin" type="normalizedPoint">e1=0 e2=0 e3=0 ni=0</constant>
      \end{verbatim}
      Note that coordinates which are zero do not need to be specified. The attributes of a {\tt constant} element are:
      
       \begin{itemize}
       \item {\tt name}. The name of the constant.
       \item {\tt type}. The type of the constant. Currently only specialized multivector constants are supported ({\tt smv}).
       \end{itemize}
      The {\tt constant} contains the value of the coordinates of the constant, and optionally a {\tt comment} element.
      
\item {\bf om} Specifies the general outermorphism matrix representation type. The outermorphism has a domain and
      a range, both of which may be specified, but they can also be left to the defaults. An example of an outermorphism with default
      coordinate order is:
      \begin{verbatim}
      <om name="om" coordinateOrder="default" />
      \end{verbatim}
      A 3-D example of an outermorphism with a custom domain and range is:
      \begin{verbatim}
      <code>
      <om name="om" coordinateOrder="custom">
      <domain>scalar e1 e2 e3 e1^e2 e2^e3 e3^e1 e1^e2^e3</domain>
      <range>scalar e1 e2 e3 e1^e2 e2^e3 e3^e1 e1^e2^e3</range>
      </code>
      \end{verbatim}
      In this last example, it was redundant to specify the range since it is identical to the domain. Leaving the {\tt range} element
      out would have the same effect. Note that all basis blades must be present in an general outermorphism's range and domain.
      The attributes of a {\tt om} element are:
       \begin{itemize}
       \item {\tt name}. The name of the outermorphism type, for example {\tt om}.
       \item {\tt coordinateOrder}. This can be {\tt default} or {\tt custom}. If {\tt custom} is used, the {\tt domain}
            and possibly the {\tt range} should be specified. If the {\tt range} is left out, it is assumed to be identical to the {\tt domain}.
       \end{itemize}
       
\item {\bf som} A {\tt som} element specifies a specialized outermorphism. It is pretty much that same as a general outermorphism
      except it does not need to have all basis blades in its domain and range. An example of a {\tt som} element is:
      <code>
      <som name="flatPointOM">
      <domain>e1^ni e2^ni e3^ni no^ni</domain>
      <range>e1^ni e2^ni e3^ni no^ni</range> 
      </som>
      </code>
      The {\tt som} element has only one attribute, since the {\tt coordinateOrder} is always custom:
       \begin{itemize}
       \item {\tt name}. The name of the outermorphism type, for example {\tt om}.
       \end{itemize}
\item {\bf function} This element specifies a request to the code generator back-end to implement a specific function
 *     for specific arguments.
 *     The attributes are:
 *        - {\tt name}. The name of the function, as it is known to the code generator. This name is also the name of the
 *           generated function unless an {\tt outputName} attribute is specified. To generate a converter (underscore constructor),
 *           the name of the function should be the destination type plus an underscore, e.g., {\tt _vectorE3GA}. This first (and only)
 *           argument should be the source type.
 *        - {\tt outputName}. Optional. Changes the name of the generated function to the value of the attribute. For example, allows you
 *          to rename a function {\tt gp} to {\tt geometricProduct}
 *        - {\tt returnType}. Optional. By default, the code generator will determine the return type of the functions it generates, but it is possible to override this default by setting it explicitly. 
 *          The return type should be the name of a specialized mutlvector. However, the return type may also be 'scalar' or any of the floating point typenames used in the algebra.
 *          If the return type is 'scalar', then a float will be returned, automatically adapted to the floating point type of the function.
 *        - {\tt argN}. Specifies the type of argument {\tt N}. If no {\tt argN} attribute is given, the code generator should fill in the right number of general multivector or general 
 *           outermorphism types automatically. Otherwise, the correct number of {\tt argN} attributes should be specified for the function (running from 1 up
 *           to the number of arguments of the function). Not all combinations of argument types are possible. For example, currently it is not possible
 *           to mix general and specialized multivectors. It is possible to mix floating point types and general multivectors though.
 *        - {\tt argNameN}. Specifies the name of argument {\tt N}. This only affects the name of the argument inside
 *           the generated function. Specifying this name may be superfluous, but may improve readability, especially for code-completion
 *           wizards. 
 *        - {\tt optionX}. Specifies a optional option 'X'. For example, the {\tt exp} functions can generate more efficient code
 *           when it knows what the sign of the square of the argument is. In that case, one may use for example {\tt optionSquare="1.0"}.
 *        - {\tt floatType}. Multiple {\tt floatType} attributes may be present in a single {\tt function} element. 
 *          By default, the code generator will generate code for all floating point types of the specification, but using the 
 *          {\tt floatType} attribute(s) this may be limited to only the set of listed floating point types.
 *        - {\tt metric}. The optional {\tt metric} attribute specifies the usage of a non-default metric (case insensitive). By default,
 *          the metric {\tt "default"} is used. By using this attribute a different metric may be used for
 *          the function, e.g., {\tt metric="euclidean"}.
 *        - {\tt comment}. Use the this optional attribute to add any extra comment to the function documentation. For example, one could
 *          use the comment to explain what a certain function is used for.
\item {\bf verbatim} This element is used to add verbatim code to the output files. This may be useful to
 *     include some headers, to add some custom functions or documentation. The {\tt verbatim} element can contain
 *     the code as text, or can point to a file using the {\tt codeFilename} attribute. The attributes are:
 *        - {\tt filenameX}. The filename(s) of the files to modify. Multiple files can be modifed with one {\tt verbatim} element.
 *        The {\tt X} in the attribute can be any string (including empty). If multiple {\tt filenameX} attributes are specified, multiple
 *        files are modified.
 *        - {\tt position}. Where to place the verbatim code. The values can be {\tt top} (at the top of the file), 
 *           {\tt bottom} (at the bottom of the file), {\tt before} (before some marker string) or
 *           {\tt after} (before some marker string).
 *        - {\tt marker}. If {\tt position} is {\tt before} or {\tt after}, then this attribute specifies the string
 *           before or after which the verbatim code should be inserted.
 *        - {\tt codeFilename}. The verbatim code can be directly inside the {\tt verbatim} element but for long code
 *           it may be easier to put the code in a separate file. The name of this file is specified using this attribute.
 \end{itemize}
 
 * \subsection mv_coord_sec Multivector compression, coordinate order and memory allocation
 * 
 * Memory of general multivector variables can be allocated in different ways whose effictiveness will vary per code generator/language.
 * You can allocate memory for all possible coordinates (<c>memAlloc="full"</c>). This would for example allocate 32 coordinates for a 5-D algebra.
 * You can also allocate half of that if you know that you will always use parity-pure (only even-grade, or only odd-grade) multivectors
 * (<c>memAlloc="parityPure"</c>). Another option is dynamically allocate just the memory that is required (<c>memAlloc="dynamic"</c>).
 * 
 * Compression of multivector coordinates can be done per grade part (<c>compress="byGrade"</c>) or per user-defined group (<c>compress="byGroup"</c>).
 * 
 * If compression is done by grade, then the attribute value <c>coordinateOrder="default"</c> can be used. But it is also allowed to
 * have a custom coordinate order. In that case the <c>mv</c> element must contain a list of basis blades all, i.e., the order of coordinates.
 * The basis blades should not be in <c>group</c> elements, just listed in the order you want them to be. The basis blades
 * should be listed in ascending grade order. For example:
 * <code>
 <mv compress="byGrade" coordinateOrder="custom" memAlloc="parityPure">
    scalar
    no e1 e2 e3 ni
    no^e1 no^e2 no^e3 e1^e2 e2^e3 e3^e1 e1^ni e2^ni e3^ni no^ni
    e2^e3^ni e3^e1^ni e1^e2^ni no^e3^ni no^e1^ni no^e2^ni no^e2^e3 no^e1^e3 no^e1^e2 e1^e2^e3
    e1^e2^e3^ni no^e2^e3^ni no^e1^e3^ni no^e1^e2^ni no^e1^e2^e3
    no^e1^e2^e3^ni
</mv>
 *  </code>
 * If compression is done by group, each group of basis blades must be specified inside the <c>mv</c> element inside a <c>group</c> element. 
 * A group cannot contain basis blades of different grades. This example splits the coordinates of the 5-D conformal algebra into
 * three basic groups (<c>no</c>, <c>ni</c>, and <c>e1, e2, e3</c>) for all grades. For example:
 *  <code>
<mv compress="byGroup" coordinateOrder="custom" memAlloc="parityPure">
    <group>scalar</group>
    <group>no</group>
    <group>e1 e2 e3</group>
    <group>ni</group>
    <group>no^e1 no^e2 no^e3</group>
    <group>e1^e2 e2^e3 e3^e1</group> 
    <group>e1^ni e2^ni e3^ni</group>
    <group>no^ni</group>
    <group>e2^e3^ni e3^e1^ni e1^e2^ni</group>
    <group>no^e3^ni no^e1^ni no^e2^ni</group>
    <group>no^e2^e3 no^e1^e3 no^e1^e2</group>
    <group>e1^e2^e3</group>
    <group>e1^e2^e3^ni</group>
    <group>no^e2^e3^ni no^e1^e3^ni no^e1^e2^ni</group>
    <group>no^e1^e2^e3</group>
    <group>no^e1^e2^e3^ni</group>
</mv>
 *  </code>
 * 
 * 

\section{Why did you write Gaigen 2.5 C\#?}

I wrote Gaigen 2.5 in C\# because I wanted to try out the platform.
I assumed that Mono would be good enough to run Gaigen 2.5 on OS X and
Linux, but it is slightly disappointing in speed. Hopefully the Mono
team will improve Mono's performance in the future.




\begin{thebibliography}{}


	
\bibitem{GA4CS} L.~Dorst and D.~Fontijne and S.~Mann.
	\emph{Geometric Algebra for Computer Science: An Object Oriented Approach to Geometry.}
	Morgan Kaufmann, revised edition 2009.

\bibitem{fontijnePhD} D.~Fontijne.
	\emph{Efficient Implementation of Geometric Algebra.}
	PhD. Thesis, University of Amsterdam, 2007.


\end{thebibliography}


\end{document}

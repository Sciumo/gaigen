/*
This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

*/

/*! \mainpage c3ga documentation
 *
 * c3ga implementation generated by Gaigen 2.5. 
 * 
 * 
 * License: 
This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  
 * 
 * \section intro_sec Introduction
 *
 * Todo
 * 
 */
#ifndef _C3GA_H_
#define _C3GA_H_

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <string>
#include <map>
namespace c3ga {

// group: 1
#define GROUP_0 1
// group: no, e1, e2, e3, ni
#define GROUP_1 2
// group: no^e1, no^e2, e1^e2, no^e3, e1^e3, e2^e3, no^ni, e1^ni, e2^ni, e3^ni
#define GROUP_2 4
// group: no^e1^e2, no^e1^e3, no^e2^e3, e1^e2^e3, no^e1^ni, no^e2^ni, e1^e2^ni, no^e3^ni, e1^e3^ni, e2^e3^ni
#define GROUP_3 8
// group: no^e1^e2^e3, no^e1^e2^ni, no^e1^e3^ni, no^e2^e3^ni, e1^e2^e3^ni
#define GROUP_4 16
// group: no^e1^e2^e3^ni
#define GROUP_5 32
#define GRADE_0 1
#define GRADE_1 2
#define GRADE_2 4
#define GRADE_3 8
#define GRADE_4 16
#define GRADE_5 32


/// The dimension of the space:
extern const int c3ga_spaceDim;

/// Number of groups/grades of coordinates in a multivector:
extern const int c3ga_nbGroups;

/// The constants for the groups in an array:
extern const int c3ga_groups[];

/// The constants for the grades in an array:
extern const int c3ga_grades[];

/// Is the metric of the space Euclidean? (false or true)
extern const bool c3ga_metricEuclidean;

/// This array can be used to lookup the number of coordinates for a group part of a general multivector
extern const int c3ga_groupSize[6];

/// This array can be used to lookup the number of coordinates based on a group usage bitmap
extern const int c3ga_mvSize[64];

/// This array of ASCIIZ strings contains the names of the basis vectors
extern const char *c3ga_basisVectorNames[5];

/// This array of integers contains the order of basis elements in the general multivector
/// Use it to answer: 'what basis vectors are in the basis element at position [x]?
extern const int c3ga_basisElements[32][6];

/// This array of integers contains the 'sign' (even/odd permutation of canonical order) of basis elements in the general multivector
/// Use it to answer 'what is the permutation of the coordinate at index [x]'?
extern const double c3ga_basisElementSignByIndex[32];

/// This array of integers contains the 'sign' (even/odd permutation of canonical order) of basis elements in the general multivector
/// Use it to answer 'what is the permutation of the coordinate of bitmap [x]'?
extern const double c3ga_basisElementSignByBitmap[32];

/// This array of integers contains the order of basis elements in the general multivector
/// Use it to answer: 'at what index do I find basis element [x] (x = basis vector bitmap)?'
extern const int c3ga_basisElementIndexByBitmap[32];

/// This array of integers contains the indices of basis elements in the general multivector
/// Use it to answer: 'what basis element do I find at index [x]'?
extern const int c3ga_basisElementBitmapByIndex[32];

/// This array of grade of each basis elements in the general multivector
/// Use it to answer: 'what is the grade of basis element bitmap [x]'?
extern const int c3ga_basisElementGradeByBitmap[32];

/// This array of group of each basis elements in the general multivector
/// Use it to answer: 'what is the group of basis element bitmap [x]'?
extern const int c3ga_basisElementGroupByBitmap[32];

// These constants define a unique number for each specialized multivector type.
// They are used to report usage of non-optimized functions.
typedef enum {
	C3GA_NONE = -1,
	C3GA_MV = 0,
	C3GA_FLOAT = 1,
	C3GA_NORMALIZEDPOINT = 2,
	C3GA_FLATPOINT = 3,
	C3GA_LINE = 4,
	C3GA_PLANE = 5,
	C3GA_NO_T = 6,
	C3GA_E1_T = 7,
	C3GA_E2_T = 8,
	C3GA_E3_T = 9,
	C3GA_NI_T = 10,
	C3GA_POINTPAIR = 11,
	C3GA_CIRCLE = 12,
	C3GA_INVALID
} SMV_TYPE;

/// For each specialized multivector type, the mangled typename.
/// This is used to report usage of non-optimized functions.
extern const char *g_c3gaTypenames[];
class mv;
class normalizedPoint;
class flatPoint;
class line;
class plane;
class no_t;
class e1_t;
class e2_t;
class e3_t;
class ni_t;
class pointPair;
class circle;

/**
This function alters the formatting of 'string()'.
'format' = NULL will give you back the default.
*/
void setStringFormat(const char *what, const char *format);

extern const char *string_fp; /* = \"%2.2f\" */
extern const char *string_start; /* = \"\" */
extern const char *string_end; /* = \"\" */
extern const char *string_mul; /* = \"*\" */
extern const char *string_wedge; /* = \"^\" */
extern const char *string_plus; /* = \" + \" */
extern const char *string_minus; /* = \" - \" */

const char *c_str(const mv &obj, char *str, int maxLength, const char *fp = NULL);
std::string toString(const mv &obj, const char *fp = NULL);

inline const char *c_str_f(const mv &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%f");}
inline const char *c_str_e(const mv &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%e");}
inline const char *c_str_e20(const mv &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%2.20e");}

inline std::string toString_f(const mv &obj) {return toString(obj, "%f");}
inline std::string toString_e(const mv &obj) {return toString(obj, "%e");}
inline std::string toString_e20(const mv &obj) {return toString(obj, "%2.20e");}




/// This class can hold a general multivector.
/// 
/// The coordinates are stored in type float.
/// 
/// There are 6 coordinate groups:
/// group 0:1  (grade 0).
/// group 1:no, e1, e2, e3, ni  (grade 1).
/// group 2:no^e1, no^e2, e1^e2, no^e3, e1^e3, e2^e3, no^ni, e1^ni, e2^ni, e3^ni  (grade 2).
/// group 3:no^e1^e2, no^e1^e3, no^e2^e3, e1^e2^e3, no^e1^ni, no^e2^ni, e1^e2^ni, no^e3^ni, e1^e3^ni, e2^e3^ni  (grade 3).
/// group 4:no^e1^e2^e3, no^e1^e2^ni, no^e1^e3^ni, no^e2^e3^ni, e1^e2^e3^ni  (grade 4).
/// group 5:no^e1^e2^e3^ni  (grade 5).
/// 
/// 
class mv
{

public:
	/// group/grade usage (a bitmap which specifies which groups/grades are stored in 'c', below).
	int m_gu; 
	/// the coordinates (array is allocated using realloc())
	float *m_c; 
	/// Specialized multivector type. Used to report about non-optimized function usage.
	SMV_TYPE m_t; 
public:

	/// Floating point type used by mv 
	typedef float Float;

	/// Constructs a new mv with value 0.
	inline mv()  : m_c(NULL), m_gu(0) {set();}

	/// Copy constructor.
	inline mv(const mv&A)  : m_c(NULL), m_gu(0) {set(A);}


	/// Constructs a new mv with scalar value 'scalar'.
	inline mv(float scalar)  : m_c(NULL), m_gu(0) {set(scalar);}

	/// Constructs a new mv from compressed 'coordinates'.
	/// \param gu bitwise OR of the GRADEs or GROUPs that are non-zero.
	/// \param coordinates compressed coordinates.
	inline mv(int gu, const float *coordinates)  : m_c(NULL), m_gu(0) {set(gu, coordinates);}

	/// Converts a normalizedPoint to a mv.
	inline mv(const normalizedPoint&A)  : m_c(NULL), m_gu(0) {set(A);}
	/// Converts a flatPoint to a mv.
	inline mv(const flatPoint&A)  : m_c(NULL), m_gu(0) {set(A);}
	/// Converts a line to a mv.
	inline mv(const line&A)  : m_c(NULL), m_gu(0) {set(A);}
	/// Converts a plane to a mv.
	inline mv(const plane&A)  : m_c(NULL), m_gu(0) {set(A);}
	/// Converts a no_t to a mv.
	inline mv(const no_t&A)  : m_c(NULL), m_gu(0) {set(A);}
	/// Converts a e1_t to a mv.
	inline mv(const e1_t&A)  : m_c(NULL), m_gu(0) {set(A);}
	/// Converts a e2_t to a mv.
	inline mv(const e2_t&A)  : m_c(NULL), m_gu(0) {set(A);}
	/// Converts a e3_t to a mv.
	inline mv(const e3_t&A)  : m_c(NULL), m_gu(0) {set(A);}
	/// Converts a ni_t to a mv.
	inline mv(const ni_t&A)  : m_c(NULL), m_gu(0) {set(A);}
	/// Converts a pointPair to a mv.
	inline mv(const pointPair&A)  : m_c(NULL), m_gu(0) {set(A);}
	/// Converts a circle to a mv.
	inline mv(const circle&A)  : m_c(NULL), m_gu(0) {set(A);}

	/// Destructor (frees dynamically allocated memory).
	~mv() {if (m_c != NULL) free(m_c);}

	/// Assignment operator (mv).
	inline mv &operator=(const mv &A) {if (this != &A) {set(A);} return *this;}
	/// Assignment operator (float).
	inline mv &operator=(const float &scalar) {set(scalar); return *this;}
	
	
	/// Assignment operator (mv).
	inline mv &operator=(const normalizedPoint &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const flatPoint &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const line &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const plane &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const no_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const e1_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const e2_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const e3_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const ni_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const pointPair &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const circle &A) {set(A); return *this;}

	/// Sets this mv to 0.
	void set();

	/// Copies the value of 'A' to this.
	void set(const mv &A);

	
	/// Sets this mv to scalar value 'scalar'.
	void set(float scalar);

	/// Sets this mv from compressed 'coordinates'.
	/// \param gu bitwise OR of the GRADEs or GROUPs that are non-zero.
	/// \param coordinates compressed coordinates.
	void set(int gu, const float *coordinates);
	
	/// Sets this mv to the value of normalizedPoint A
	void set(const normalizedPoint &A);
	/// Sets this mv to the value of flatPoint A
	void set(const flatPoint &A);
	/// Sets this mv to the value of line A
	void set(const line &A);
	/// Sets this mv to the value of plane A
	void set(const plane &A);
	/// Sets this mv to the value of no_t A
	void set(const no_t &A);
	/// Sets this mv to the value of e1_t A
	void set(const e1_t &A);
	/// Sets this mv to the value of e2_t A
	void set(const e2_t &A);
	/// Sets this mv to the value of e3_t A
	void set(const e3_t &A);
	/// Sets this mv to the value of ni_t A
	void set(const ni_t &A);
	/// Sets this mv to the value of pointPair A
	void set(const pointPair &A);
	/// Sets this mv to the value of circle A
	void set(const circle &A);
	/// Returns the scalar coordinate of this mv.
	inline float get_scalar() const {
		return (m_gu & 1) ? m_c[c3ga_mvSize[m_gu & 0] + 0] : 0.0f;
	}
	/// Returns the no coordinate of this mv.
	inline float get_no() const {
		return (m_gu & 2) ? m_c[c3ga_mvSize[m_gu & 1] + 0] : 0.0f;
	}
	/// Returns the e1 coordinate of this mv.
	inline float get_e1() const {
		return (m_gu & 2) ? m_c[c3ga_mvSize[m_gu & 1] + 1] : 0.0f;
	}
	/// Returns the e2 coordinate of this mv.
	inline float get_e2() const {
		return (m_gu & 2) ? m_c[c3ga_mvSize[m_gu & 1] + 2] : 0.0f;
	}
	/// Returns the e3 coordinate of this mv.
	inline float get_e3() const {
		return (m_gu & 2) ? m_c[c3ga_mvSize[m_gu & 1] + 3] : 0.0f;
	}
	/// Returns the ni coordinate of this mv.
	inline float get_ni() const {
		return (m_gu & 2) ? m_c[c3ga_mvSize[m_gu & 1] + 4] : 0.0f;
	}
	/// Returns the no_e1 coordinate of this mv.
	inline float get_no_e1() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 0] : 0.0f;
	}
	/// Returns the no_e2 coordinate of this mv.
	inline float get_no_e2() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 1] : 0.0f;
	}
	/// Returns the e1_e2 coordinate of this mv.
	inline float get_e1_e2() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 2] : 0.0f;
	}
	/// Returns the no_e3 coordinate of this mv.
	inline float get_no_e3() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 3] : 0.0f;
	}
	/// Returns the e1_e3 coordinate of this mv.
	inline float get_e1_e3() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 4] : 0.0f;
	}
	/// Returns the e2_e3 coordinate of this mv.
	inline float get_e2_e3() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 5] : 0.0f;
	}
	/// Returns the no_ni coordinate of this mv.
	inline float get_no_ni() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 6] : 0.0f;
	}
	/// Returns the e1_ni coordinate of this mv.
	inline float get_e1_ni() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 7] : 0.0f;
	}
	/// Returns the e2_ni coordinate of this mv.
	inline float get_e2_ni() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 8] : 0.0f;
	}
	/// Returns the e3_ni coordinate of this mv.
	inline float get_e3_ni() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 9] : 0.0f;
	}
	/// Returns the no_e1_e2 coordinate of this mv.
	inline float get_no_e1_e2() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 0] : 0.0f;
	}
	/// Returns the no_e1_e3 coordinate of this mv.
	inline float get_no_e1_e3() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 1] : 0.0f;
	}
	/// Returns the no_e2_e3 coordinate of this mv.
	inline float get_no_e2_e3() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 2] : 0.0f;
	}
	/// Returns the e1_e2_e3 coordinate of this mv.
	inline float get_e1_e2_e3() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 3] : 0.0f;
	}
	/// Returns the no_e1_ni coordinate of this mv.
	inline float get_no_e1_ni() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 4] : 0.0f;
	}
	/// Returns the no_e2_ni coordinate of this mv.
	inline float get_no_e2_ni() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 5] : 0.0f;
	}
	/// Returns the e1_e2_ni coordinate of this mv.
	inline float get_e1_e2_ni() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 6] : 0.0f;
	}
	/// Returns the no_e3_ni coordinate of this mv.
	inline float get_no_e3_ni() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 7] : 0.0f;
	}
	/// Returns the e1_e3_ni coordinate of this mv.
	inline float get_e1_e3_ni() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 8] : 0.0f;
	}
	/// Returns the e2_e3_ni coordinate of this mv.
	inline float get_e2_e3_ni() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 9] : 0.0f;
	}
	/// Returns the no_e1_e2_e3 coordinate of this mv.
	inline float get_no_e1_e2_e3() const {
		return (m_gu & 16) ? m_c[c3ga_mvSize[m_gu & 15] + 0] : 0.0f;
	}
	/// Returns the no_e1_e2_ni coordinate of this mv.
	inline float get_no_e1_e2_ni() const {
		return (m_gu & 16) ? m_c[c3ga_mvSize[m_gu & 15] + 1] : 0.0f;
	}
	/// Returns the no_e1_e3_ni coordinate of this mv.
	inline float get_no_e1_e3_ni() const {
		return (m_gu & 16) ? m_c[c3ga_mvSize[m_gu & 15] + 2] : 0.0f;
	}
	/// Returns the no_e2_e3_ni coordinate of this mv.
	inline float get_no_e2_e3_ni() const {
		return (m_gu & 16) ? m_c[c3ga_mvSize[m_gu & 15] + 3] : 0.0f;
	}
	/// Returns the e1_e2_e3_ni coordinate of this mv.
	inline float get_e1_e2_e3_ni() const {
		return (m_gu & 16) ? m_c[c3ga_mvSize[m_gu & 15] + 4] : 0.0f;
	}
	/// Returns the no_e1_e2_e3_ni coordinate of this mv.
	inline float get_no_e1_e2_e3_ni() const {
		return (m_gu & 32) ? m_c[c3ga_mvSize[m_gu & 31] + 0] : 0.0f;
	}
	/// Returns array of compressed coordinates.
	inline const float *getC() const { return m_c;}
	/// Sets the scalar coordinate of this mv.
	inline void set_scalar(float val)  {
		reserveGroup_0();
		m_c[c3ga_mvSize[m_gu & 0] + 0] = val;
	}
	/// Sets the no coordinate of this mv.
	inline void set_no(float val)  {
		reserveGroup_1();
		m_c[c3ga_mvSize[m_gu & 1] + 0] = val;
	}
	/// Sets the e1 coordinate of this mv.
	inline void set_e1(float val)  {
		reserveGroup_1();
		m_c[c3ga_mvSize[m_gu & 1] + 1] = val;
	}
	/// Sets the e2 coordinate of this mv.
	inline void set_e2(float val)  {
		reserveGroup_1();
		m_c[c3ga_mvSize[m_gu & 1] + 2] = val;
	}
	/// Sets the e3 coordinate of this mv.
	inline void set_e3(float val)  {
		reserveGroup_1();
		m_c[c3ga_mvSize[m_gu & 1] + 3] = val;
	}
	/// Sets the ni coordinate of this mv.
	inline void set_ni(float val)  {
		reserveGroup_1();
		m_c[c3ga_mvSize[m_gu & 1] + 4] = val;
	}
	/// Sets the no_e1 coordinate of this mv.
	inline void set_no_e1(float val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 0] = val;
	}
	/// Sets the no_e2 coordinate of this mv.
	inline void set_no_e2(float val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 1] = val;
	}
	/// Sets the e1_e2 coordinate of this mv.
	inline void set_e1_e2(float val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 2] = val;
	}
	/// Sets the no_e3 coordinate of this mv.
	inline void set_no_e3(float val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 3] = val;
	}
	/// Sets the e1_e3 coordinate of this mv.
	inline void set_e1_e3(float val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 4] = val;
	}
	/// Sets the e2_e3 coordinate of this mv.
	inline void set_e2_e3(float val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 5] = val;
	}
	/// Sets the no_ni coordinate of this mv.
	inline void set_no_ni(float val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 6] = val;
	}
	/// Sets the e1_ni coordinate of this mv.
	inline void set_e1_ni(float val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 7] = val;
	}
	/// Sets the e2_ni coordinate of this mv.
	inline void set_e2_ni(float val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 8] = val;
	}
	/// Sets the e3_ni coordinate of this mv.
	inline void set_e3_ni(float val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 9] = val;
	}
	/// Sets the no_e1_e2 coordinate of this mv.
	inline void set_no_e1_e2(float val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 0] = val;
	}
	/// Sets the no_e1_e3 coordinate of this mv.
	inline void set_no_e1_e3(float val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 1] = val;
	}
	/// Sets the no_e2_e3 coordinate of this mv.
	inline void set_no_e2_e3(float val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 2] = val;
	}
	/// Sets the e1_e2_e3 coordinate of this mv.
	inline void set_e1_e2_e3(float val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 3] = val;
	}
	/// Sets the no_e1_ni coordinate of this mv.
	inline void set_no_e1_ni(float val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 4] = val;
	}
	/// Sets the no_e2_ni coordinate of this mv.
	inline void set_no_e2_ni(float val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 5] = val;
	}
	/// Sets the e1_e2_ni coordinate of this mv.
	inline void set_e1_e2_ni(float val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 6] = val;
	}
	/// Sets the no_e3_ni coordinate of this mv.
	inline void set_no_e3_ni(float val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 7] = val;
	}
	/// Sets the e1_e3_ni coordinate of this mv.
	inline void set_e1_e3_ni(float val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 8] = val;
	}
	/// Sets the e2_e3_ni coordinate of this mv.
	inline void set_e2_e3_ni(float val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 9] = val;
	}
	/// Sets the no_e1_e2_e3 coordinate of this mv.
	inline void set_no_e1_e2_e3(float val)  {
		reserveGroup_4();
		m_c[c3ga_mvSize[m_gu & 15] + 0] = val;
	}
	/// Sets the no_e1_e2_ni coordinate of this mv.
	inline void set_no_e1_e2_ni(float val)  {
		reserveGroup_4();
		m_c[c3ga_mvSize[m_gu & 15] + 1] = val;
	}
	/// Sets the no_e1_e3_ni coordinate of this mv.
	inline void set_no_e1_e3_ni(float val)  {
		reserveGroup_4();
		m_c[c3ga_mvSize[m_gu & 15] + 2] = val;
	}
	/// Sets the no_e2_e3_ni coordinate of this mv.
	inline void set_no_e2_e3_ni(float val)  {
		reserveGroup_4();
		m_c[c3ga_mvSize[m_gu & 15] + 3] = val;
	}
	/// Sets the e1_e2_e3_ni coordinate of this mv.
	inline void set_e1_e2_e3_ni(float val)  {
		reserveGroup_4();
		m_c[c3ga_mvSize[m_gu & 15] + 4] = val;
	}
	/// Sets the no_e1_e2_e3_ni coordinate of this mv.
	inline void set_no_e1_e2_e3_ni(float val)  {
		reserveGroup_5();
		m_c[c3ga_mvSize[m_gu & 31] + 0] = val;
	}

	/// Compresses this mv by removing groups/grades with coordinates are smaller than epsilon.
	void compress(float epsilon = 0.0f);
	/// Sets each entry in 'ptrs' to a pointer to the coordinates for the respective grade / group.
	/// \param ptrs Array of pointers to grades/groups. The pointers are set by this function.
	/// \param nulls When true, pointers are set to NULL for empty grades/groups; otherwise a pointer to an array filled with zeros is used.
	void expand(const float *ptrs[6], bool nulls = true) const;

	/// returns the absolute largest coordinate.
	float largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap (in 'bm').
	float largestBasisBlade(unsigned int &bm) const;
	/// returns grade/group.
	inline int gu() const {return m_gu;}

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}
public:
	inline float const *nullFloats() const {
		static float *nf = NULL;
		return (nf == NULL) ? (nf = new float[32]) : nf;
	}

public:
	/// Set m_gu, reallocates m_c to the size required by gu
	inline void setGroupUsage(int gu) {
		if (m_gu == gu) return;
		m_gu = gu;
		int nbCoords = c3ga_mvSize[m_gu];
		if (nbCoords > 0)
			m_c = (float*)realloc(m_c, nbCoords * sizeof(float));
	}

	/**
	Allocates memory for coordinate GROUP_0.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_0() {
		if ((m_gu & 1) == 0) {
			const int groupUsageBelow = m_gu & 0;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 1;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 1;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			float *dst = m_c + c3ga_mvSize[newGroupUsageBelowNextGroup];
			float *src = m_c + c3ga_mvSize[groupUsageBelow];
			for (int i = c3ga_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			float *ptr = m_c + c3ga_mvSize[groupUsageBelow];
			ptr[0] = 0.0f;
		}
	}
	/**
	Allocates memory for coordinate GROUP_1.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_1() {
		if ((m_gu & 2) == 0) {
			const int groupUsageBelow = m_gu & 1;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 2;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 3;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			float *dst = m_c + c3ga_mvSize[newGroupUsageBelowNextGroup];
			float *src = m_c + c3ga_mvSize[groupUsageBelow];
			for (int i = c3ga_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			float *ptr = m_c + c3ga_mvSize[groupUsageBelow];
			ptr[0] = ptr[1] = ptr[2] = ptr[3] = ptr[4] = 0.0f;
		}
	}
	/**
	Allocates memory for coordinate GROUP_2.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_2() {
		if ((m_gu & 4) == 0) {
			const int groupUsageBelow = m_gu & 3;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 4;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 7;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			float *dst = m_c + c3ga_mvSize[newGroupUsageBelowNextGroup];
			float *src = m_c + c3ga_mvSize[groupUsageBelow];
			for (int i = c3ga_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			float *ptr = m_c + c3ga_mvSize[groupUsageBelow];
			ptr[0] = ptr[1] = ptr[2] = ptr[3] = ptr[4] = ptr[5] = ptr[6] = ptr[7] = ptr[8] = ptr[9] = 0.0f;
		}
	}
	/**
	Allocates memory for coordinate GROUP_3.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_3() {
		if ((m_gu & 8) == 0) {
			const int groupUsageBelow = m_gu & 7;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 8;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 15;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			float *dst = m_c + c3ga_mvSize[newGroupUsageBelowNextGroup];
			float *src = m_c + c3ga_mvSize[groupUsageBelow];
			for (int i = c3ga_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			float *ptr = m_c + c3ga_mvSize[groupUsageBelow];
			ptr[0] = ptr[1] = ptr[2] = ptr[3] = ptr[4] = ptr[5] = ptr[6] = ptr[7] = ptr[8] = ptr[9] = 0.0f;
		}
	}
	/**
	Allocates memory for coordinate GROUP_4.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_4() {
		if ((m_gu & 16) == 0) {
			const int groupUsageBelow = m_gu & 15;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 16;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 31;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			float *dst = m_c + c3ga_mvSize[newGroupUsageBelowNextGroup];
			float *src = m_c + c3ga_mvSize[groupUsageBelow];
			for (int i = c3ga_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			float *ptr = m_c + c3ga_mvSize[groupUsageBelow];
			ptr[0] = ptr[1] = ptr[2] = ptr[3] = ptr[4] = 0.0f;
		}
	}
	/**
	Allocates memory for coordinate GROUP_5.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_5() {
		if ((m_gu & 32) == 0) {
			const int groupUsageBelow = m_gu & 31;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 32;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 63;

			setGroupUsage(newGroupUsage);


			// set coordinates of new group to 0
			float *ptr = m_c + c3ga_mvSize[groupUsageBelow];
			ptr[0] = 0.0f;
		}
	}
}; // end of class mv

/// This class can hold a specialized multivector of type normalizedPoint.
/// 
/// The coordinates are stored in type float.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1  (array index: E1 = 0)
///   - coordinate e2  (array index: E2 = 1)
///   - coordinate e3  (array index: E3 = 2)
///   - coordinate ni  (array index: NI = 3)
/// 
/// The constant non-zero coordinates are:
///   - no = 1
/// 
/// 
class normalizedPoint
{
public:
	/// The coordinates (stored in an array).
	float m_c[4]; // e1, e2, e3, ni
public:

	/// Floating point type used by normalizedPoint 
	typedef float Float;
	/// Array indices of normalizedPoint coordinates.
	typedef enum {
		/// index of coordinate for e1 in normalizedPoint
		E1 = 0, 
		/// index of coordinate for e2 in normalizedPoint
		E2 = 1, 
		/// index of coordinate for e3 in normalizedPoint
		E3 = 2, 
		/// index of coordinate for ni in normalizedPoint
		NI = 3, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1_e2_e3_ni
	} CoordinateOrder;

	/// Constructs a new normalizedPoint with variable coordinates set to 0.
	inline normalizedPoint() {set();}

	/// Copy constructor.
	inline normalizedPoint(const normalizedPoint &A) {set(A);}



	/// Constructs a new normalizedPoint from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline normalizedPoint(const mv &A, int filler) {set(A);}

	/// Constructs a new normalizedPoint. Coordinate values come from 'A'.
	inline normalizedPoint(const CoordinateOrder co, const float A[4]) {set(co, A);}
	
	/// Constructs a new normalizedPoint with each coordinate specified.
	inline normalizedPoint(const CoordinateOrder co,  float e1, float e2, float e3, float ni) {
		set(co, e1, e2, e3, ni);
	}

	/// Assignment operator (normalizedPoint).
	inline normalizedPoint &operator=(const normalizedPoint &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline normalizedPoint &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const normalizedPoint &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const float A[4]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  float e1, float e2, float e3, float ni);

	/// returns the absolute largest coordinate.
	float largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	float largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1 coordinate.
	inline float get_e1() const { return m_c[0];}
	/// Sets the e1 coordinate.
	inline void set_e1(float e1) { m_c[0] = e1;}
	/// Returns the e2 coordinate.
	inline float get_e2() const { return m_c[1];}
	/// Sets the e2 coordinate.
	inline void set_e2(float e2) { m_c[1] = e2;}
	/// Returns the e3 coordinate.
	inline float get_e3() const { return m_c[2];}
	/// Sets the e3 coordinate.
	inline void set_e3(float e3) { m_c[2] = e3;}
	/// Returns the ni coordinate.
	inline float get_ni() const { return m_c[3];}
	/// Sets the ni coordinate.
	inline void set_ni(float ni) { m_c[3] = ni;}
	/// Returns the no coordinate.
	inline float get_no() const { return 1.0f;}
	/// Returns the scalar coordinate (which is always 0).
	inline float get_scalar() const { return 0.0f;}
	/// Returns array of coordinates.
	inline const float *getC(CoordinateOrder) const { return m_c;}
}; // end of class normalizedPoint

/// This class can hold a specialized multivector of type flatPoint.
/// 
/// The coordinates are stored in type float.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1^ni  (array index: E1_NI = 0)
///   - coordinate e2^ni  (array index: E2_NI = 1)
///   - coordinate e3^ni  (array index: E3_NI = 2)
///   - coordinate no^ni  (array index: NO_NI = 3)
/// 
/// The type has no constant coordinates.
/// 
/// 
class flatPoint
{
public:
	/// The coordinates (stored in an array).
	float m_c[4]; // e1^ni, e2^ni, e3^ni, no^ni
public:

	/// Floating point type used by flatPoint 
	typedef float Float;
	/// Array indices of flatPoint coordinates.
	typedef enum {
		/// index of coordinate for e1^ni in flatPoint
		E1_NI = 0, 
		/// index of coordinate for e2^ni in flatPoint
		E2_NI = 1, 
		/// index of coordinate for e3^ni in flatPoint
		E3_NI = 2, 
		/// index of coordinate for no^ni in flatPoint
		NO_NI = 3, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1ni_e2ni_e3ni_noni
	} CoordinateOrder;

	/// Constructs a new flatPoint with variable coordinates set to 0.
	inline flatPoint() {set();}

	/// Copy constructor.
	inline flatPoint(const flatPoint &A) {set(A);}



	/// Constructs a new flatPoint from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline flatPoint(const mv &A, int filler) {set(A);}

	/// Constructs a new flatPoint. Coordinate values come from 'A'.
	inline flatPoint(const CoordinateOrder co, const float A[4]) {set(co, A);}
	
	/// Constructs a new flatPoint with each coordinate specified.
	inline flatPoint(const CoordinateOrder co,  float e1_ni, float e2_ni, float e3_ni, float no_ni) {
		set(co, e1_ni, e2_ni, e3_ni, no_ni);
	}

	/// Assignment operator (flatPoint).
	inline flatPoint &operator=(const flatPoint &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline flatPoint &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const flatPoint &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const float A[4]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  float e1_ni, float e2_ni, float e3_ni, float no_ni);

	/// returns the absolute largest coordinate.
	float largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	float largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1^ni coordinate.
	inline float get_e1_ni() const { return m_c[0];}
	/// Sets the e1^ni coordinate.
	inline void set_e1_ni(float e1_ni) { m_c[0] = e1_ni;}
	/// Returns the e2^ni coordinate.
	inline float get_e2_ni() const { return m_c[1];}
	/// Sets the e2^ni coordinate.
	inline void set_e2_ni(float e2_ni) { m_c[1] = e2_ni;}
	/// Returns the e3^ni coordinate.
	inline float get_e3_ni() const { return m_c[2];}
	/// Sets the e3^ni coordinate.
	inline void set_e3_ni(float e3_ni) { m_c[2] = e3_ni;}
	/// Returns the no^ni coordinate.
	inline float get_no_ni() const { return m_c[3];}
	/// Sets the no^ni coordinate.
	inline void set_no_ni(float no_ni) { m_c[3] = no_ni;}
	/// Returns the scalar coordinate (which is always 0).
	inline float get_scalar() const { return 0.0f;}
	/// Returns array of coordinates.
	inline const float *getC(CoordinateOrder) const { return m_c;}
}; // end of class flatPoint

/// This class can hold a specialized multivector of type line.
/// 
/// The coordinates are stored in type float.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1^e2^ni  (array index: E1_E2_NI = 0)
///   - coordinate e1^e3^ni  (array index: E1_E3_NI = 1)
///   - coordinate e2^e3^ni  (array index: E2_E3_NI = 2)
///   - coordinate -1*no^e1^ni  (array index: E1_NO_NI = 3)
///   - coordinate -1*no^e2^ni  (array index: E2_NO_NI = 4)
///   - coordinate -1*no^e3^ni  (array index: E3_NO_NI = 5)
/// 
/// The type has no constant coordinates.
/// 
/// 
class line
{
public:
	/// The coordinates (stored in an array).
	float m_c[6]; // e1^e2^ni, e1^e3^ni, e2^e3^ni, -1*no^e1^ni, -1*no^e2^ni, -1*no^e3^ni
public:

	/// Floating point type used by line 
	typedef float Float;
	/// Array indices of line coordinates.
	typedef enum {
		/// index of coordinate for e1^e2^ni in line
		E1_E2_NI = 0, 
		/// index of coordinate for e1^e3^ni in line
		E1_E3_NI = 1, 
		/// index of coordinate for e2^e3^ni in line
		E2_E3_NI = 2, 
		/// index of coordinate for -1*no^e1^ni in line
		E1_NO_NI = 3, 
		/// index of coordinate for -1*no^e2^ni in line
		E2_NO_NI = 4, 
		/// index of coordinate for -1*no^e3^ni in line
		E3_NO_NI = 5, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1e2ni_e1e3ni_e2e3ni_e1noni_e2noni_e3noni
	} CoordinateOrder;

	/// Constructs a new line with variable coordinates set to 0.
	inline line() {set();}

	/// Copy constructor.
	inline line(const line &A) {set(A);}



	/// Constructs a new line from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline line(const mv &A, int filler) {set(A);}

	/// Constructs a new line. Coordinate values come from 'A'.
	inline line(const CoordinateOrder co, const float A[6]) {set(co, A);}
	
	/// Constructs a new line with each coordinate specified.
	inline line(const CoordinateOrder co,  float e1_e2_ni, float e1_e3_ni, float e2_e3_ni, float e1_no_ni, float e2_no_ni, float e3_no_ni) {
		set(co, e1_e2_ni, e1_e3_ni, e2_e3_ni, e1_no_ni, e2_no_ni, e3_no_ni);
	}

	/// Assignment operator (line).
	inline line &operator=(const line &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline line &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const line &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const float A[6]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  float e1_e2_ni, float e1_e3_ni, float e2_e3_ni, float e1_no_ni, float e2_no_ni, float e3_no_ni);

	/// returns the absolute largest coordinate.
	float largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	float largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1^e2^ni coordinate.
	inline float get_e1_e2_ni() const { return m_c[0];}
	/// Sets the e1^e2^ni coordinate.
	inline void set_e1_e2_ni(float e1_e2_ni) { m_c[0] = e1_e2_ni;}
	/// Returns the e1^e3^ni coordinate.
	inline float get_e1_e3_ni() const { return m_c[1];}
	/// Sets the e1^e3^ni coordinate.
	inline void set_e1_e3_ni(float e1_e3_ni) { m_c[1] = e1_e3_ni;}
	/// Returns the e2^e3^ni coordinate.
	inline float get_e2_e3_ni() const { return m_c[2];}
	/// Sets the e2^e3^ni coordinate.
	inline void set_e2_e3_ni(float e2_e3_ni) { m_c[2] = e2_e3_ni;}
	/// Returns the -1*no^e1^ni coordinate.
	inline float get_e1_no_ni() const { return m_c[3];}
	/// Sets the -1*no^e1^ni coordinate.
	inline void set_e1_no_ni(float e1_no_ni) { m_c[3] = e1_no_ni;}
	/// Returns the -1*no^e2^ni coordinate.
	inline float get_e2_no_ni() const { return m_c[4];}
	/// Sets the -1*no^e2^ni coordinate.
	inline void set_e2_no_ni(float e2_no_ni) { m_c[4] = e2_no_ni;}
	/// Returns the -1*no^e3^ni coordinate.
	inline float get_e3_no_ni() const { return m_c[5];}
	/// Sets the -1*no^e3^ni coordinate.
	inline void set_e3_no_ni(float e3_no_ni) { m_c[5] = e3_no_ni;}
	/// Returns the scalar coordinate (which is always 0).
	inline float get_scalar() const { return 0.0f;}
	/// Returns array of coordinates.
	inline const float *getC(CoordinateOrder) const { return m_c;}
}; // end of class line

/// This class can hold a specialized multivector of type plane.
/// 
/// The coordinates are stored in type float.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1^e2^e3^ni  (array index: E1_E2_E3_NI = 0)
///   - coordinate no^e2^e3^ni  (array index: NO_E2_E3_NI = 1)
///   - coordinate no^e1^e3^ni  (array index: NO_E1_E3_NI = 2)
///   - coordinate no^e1^e2^ni  (array index: NO_E1_E2_NI = 3)
/// 
/// The type has no constant coordinates.
/// 
/// 
class plane
{
public:
	/// The coordinates (stored in an array).
	float m_c[4]; // e1^e2^e3^ni, no^e2^e3^ni, no^e1^e3^ni, no^e1^e2^ni
public:

	/// Floating point type used by plane 
	typedef float Float;
	/// Array indices of plane coordinates.
	typedef enum {
		/// index of coordinate for e1^e2^e3^ni in plane
		E1_E2_E3_NI = 0, 
		/// index of coordinate for no^e2^e3^ni in plane
		NO_E2_E3_NI = 1, 
		/// index of coordinate for no^e1^e3^ni in plane
		NO_E1_E3_NI = 2, 
		/// index of coordinate for no^e1^e2^ni in plane
		NO_E1_E2_NI = 3, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni
	} CoordinateOrder;

	/// Constructs a new plane with variable coordinates set to 0.
	inline plane() {set();}

	/// Copy constructor.
	inline plane(const plane &A) {set(A);}



	/// Constructs a new plane from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline plane(const mv &A, int filler) {set(A);}

	/// Constructs a new plane. Coordinate values come from 'A'.
	inline plane(const CoordinateOrder co, const float A[4]) {set(co, A);}
	
	/// Constructs a new plane with each coordinate specified.
	inline plane(const CoordinateOrder co,  float e1_e2_e3_ni, float no_e2_e3_ni, float no_e1_e3_ni, float no_e1_e2_ni) {
		set(co, e1_e2_e3_ni, no_e2_e3_ni, no_e1_e3_ni, no_e1_e2_ni);
	}

	/// Assignment operator (plane).
	inline plane &operator=(const plane &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline plane &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const plane &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const float A[4]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  float e1_e2_e3_ni, float no_e2_e3_ni, float no_e1_e3_ni, float no_e1_e2_ni);

	/// returns the absolute largest coordinate.
	float largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	float largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1^e2^e3^ni coordinate.
	inline float get_e1_e2_e3_ni() const { return m_c[0];}
	/// Sets the e1^e2^e3^ni coordinate.
	inline void set_e1_e2_e3_ni(float e1_e2_e3_ni) { m_c[0] = e1_e2_e3_ni;}
	/// Returns the no^e2^e3^ni coordinate.
	inline float get_no_e2_e3_ni() const { return m_c[1];}
	/// Sets the no^e2^e3^ni coordinate.
	inline void set_no_e2_e3_ni(float no_e2_e3_ni) { m_c[1] = no_e2_e3_ni;}
	/// Returns the no^e1^e3^ni coordinate.
	inline float get_no_e1_e3_ni() const { return m_c[2];}
	/// Sets the no^e1^e3^ni coordinate.
	inline void set_no_e1_e3_ni(float no_e1_e3_ni) { m_c[2] = no_e1_e3_ni;}
	/// Returns the no^e1^e2^ni coordinate.
	inline float get_no_e1_e2_ni() const { return m_c[3];}
	/// Sets the no^e1^e2^ni coordinate.
	inline void set_no_e1_e2_ni(float no_e1_e2_ni) { m_c[3] = no_e1_e2_ni;}
	/// Returns the scalar coordinate (which is always 0).
	inline float get_scalar() const { return 0.0f;}
	/// Returns array of coordinates.
	inline const float *getC(CoordinateOrder) const { return m_c;}
}; // end of class plane

/// This class can hold a specialized multivector of type no_t.
/// 
/// The coordinates are stored in type float.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - no = 1
/// 
/// 
class no_t
{
public:
public:

	/// Floating point type used by no_t 
	typedef float Float;
	/// Array indices of no_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new no_t with variable coordinates set to 0.
	inline no_t() {set();}

	/// Copy constructor.
	inline no_t(const no_t &A) {set(A);}



	/// Constructs a new no_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline no_t(const mv &A, int filler) {set(A);}


	/// Assignment operator (no_t).
	inline no_t &operator=(const no_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline no_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const no_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	float largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	float largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the no coordinate.
	inline float get_no() const { return 1.0f;}
	/// Returns the scalar coordinate (which is always 0).
	inline float get_scalar() const { return 0.0f;}
}; // end of class no_t

/// This class can hold a specialized multivector of type e1_t.
/// 
/// The coordinates are stored in type float.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - e1 = 1
/// 
/// 
class e1_t
{
public:
public:

	/// Floating point type used by e1_t 
	typedef float Float;
	/// Array indices of e1_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new e1_t with variable coordinates set to 0.
	inline e1_t() {set();}

	/// Copy constructor.
	inline e1_t(const e1_t &A) {set(A);}



	/// Constructs a new e1_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline e1_t(const mv &A, int filler) {set(A);}


	/// Assignment operator (e1_t).
	inline e1_t &operator=(const e1_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline e1_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const e1_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	float largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	float largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1 coordinate.
	inline float get_e1() const { return 1.0f;}
	/// Returns the scalar coordinate (which is always 0).
	inline float get_scalar() const { return 0.0f;}
}; // end of class e1_t

/// This class can hold a specialized multivector of type e2_t.
/// 
/// The coordinates are stored in type float.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - e2 = 1
/// 
/// 
class e2_t
{
public:
public:

	/// Floating point type used by e2_t 
	typedef float Float;
	/// Array indices of e2_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new e2_t with variable coordinates set to 0.
	inline e2_t() {set();}

	/// Copy constructor.
	inline e2_t(const e2_t &A) {set(A);}



	/// Constructs a new e2_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline e2_t(const mv &A, int filler) {set(A);}


	/// Assignment operator (e2_t).
	inline e2_t &operator=(const e2_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline e2_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const e2_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	float largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	float largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e2 coordinate.
	inline float get_e2() const { return 1.0f;}
	/// Returns the scalar coordinate (which is always 0).
	inline float get_scalar() const { return 0.0f;}
}; // end of class e2_t

/// This class can hold a specialized multivector of type e3_t.
/// 
/// The coordinates are stored in type float.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - e3 = 1
/// 
/// 
class e3_t
{
public:
public:

	/// Floating point type used by e3_t 
	typedef float Float;
	/// Array indices of e3_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new e3_t with variable coordinates set to 0.
	inline e3_t() {set();}

	/// Copy constructor.
	inline e3_t(const e3_t &A) {set(A);}



	/// Constructs a new e3_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline e3_t(const mv &A, int filler) {set(A);}


	/// Assignment operator (e3_t).
	inline e3_t &operator=(const e3_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline e3_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const e3_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	float largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	float largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e3 coordinate.
	inline float get_e3() const { return 1.0f;}
	/// Returns the scalar coordinate (which is always 0).
	inline float get_scalar() const { return 0.0f;}
}; // end of class e3_t

/// This class can hold a specialized multivector of type ni_t.
/// 
/// The coordinates are stored in type float.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - ni = 1
/// 
/// 
class ni_t
{
public:
public:

	/// Floating point type used by ni_t 
	typedef float Float;
	/// Array indices of ni_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new ni_t with variable coordinates set to 0.
	inline ni_t() {set();}

	/// Copy constructor.
	inline ni_t(const ni_t &A) {set(A);}



	/// Constructs a new ni_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline ni_t(const mv &A, int filler) {set(A);}


	/// Assignment operator (ni_t).
	inline ni_t &operator=(const ni_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline ni_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const ni_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	float largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	float largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the ni coordinate.
	inline float get_ni() const { return 1.0f;}
	/// Returns the scalar coordinate (which is always 0).
	inline float get_scalar() const { return 0.0f;}
}; // end of class ni_t

/// This class can hold a specialized multivector of type pointPair.
/// 
/// The coordinates are stored in type float.
/// 
/// The variable non-zero coordinates are:
///   - coordinate no^e1  (array index: NO_E1 = 0)
///   - coordinate no^e2  (array index: NO_E2 = 1)
///   - coordinate e1^e2  (array index: E1_E2 = 2)
///   - coordinate no^e3  (array index: NO_E3 = 3)
///   - coordinate e1^e3  (array index: E1_E3 = 4)
///   - coordinate e2^e3  (array index: E2_E3 = 5)
///   - coordinate no^ni  (array index: NO_NI = 6)
///   - coordinate e1^ni  (array index: E1_NI = 7)
///   - coordinate e2^ni  (array index: E2_NI = 8)
///   - coordinate e3^ni  (array index: E3_NI = 9)
/// 
/// The type has no constant coordinates.
/// 
/// 
class pointPair
{
public:
	/// The coordinates (stored in an array).
	float m_c[10]; // no^e1, no^e2, e1^e2, no^e3, e1^e3, e2^e3, no^ni, e1^ni, e2^ni, e3^ni
public:

	/// Floating point type used by pointPair 
	typedef float Float;
	/// Array indices of pointPair coordinates.
	typedef enum {
		/// index of coordinate for no^e1 in pointPair
		NO_E1 = 0, 
		/// index of coordinate for no^e2 in pointPair
		NO_E2 = 1, 
		/// index of coordinate for e1^e2 in pointPair
		E1_E2 = 2, 
		/// index of coordinate for no^e3 in pointPair
		NO_E3 = 3, 
		/// index of coordinate for e1^e3 in pointPair
		E1_E3 = 4, 
		/// index of coordinate for e2^e3 in pointPair
		E2_E3 = 5, 
		/// index of coordinate for no^ni in pointPair
		NO_NI = 6, 
		/// index of coordinate for e1^ni in pointPair
		E1_NI = 7, 
		/// index of coordinate for e2^ni in pointPair
		E2_NI = 8, 
		/// index of coordinate for e3^ni in pointPair
		E3_NI = 9, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_noe1_noe2_e1e2_noe3_e1e3_e2e3_noni_e1ni_e2ni_e3ni
	} CoordinateOrder;

	/// Constructs a new pointPair with variable coordinates set to 0.
	inline pointPair() {set();}

	/// Copy constructor.
	inline pointPair(const pointPair &A) {set(A);}



	/// Constructs a new pointPair from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline pointPair(const mv &A, int filler) {set(A);}

	/// Constructs a new pointPair. Coordinate values come from 'A'.
	inline pointPair(const CoordinateOrder co, const float A[10]) {set(co, A);}
	
	/// Constructs a new pointPair with each coordinate specified.
	inline pointPair(const CoordinateOrder co,  float no_e1, float no_e2, float e1_e2, float no_e3, float e1_e3, float e2_e3, float no_ni, float e1_ni, float e2_ni, float e3_ni) {
		set(co, no_e1, no_e2, e1_e2, no_e3, e1_e3, e2_e3, no_ni, e1_ni, e2_ni, e3_ni);
	}

	/// Assignment operator (pointPair).
	inline pointPair &operator=(const pointPair &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline pointPair &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const pointPair &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const float A[10]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  float no_e1, float no_e2, float e1_e2, float no_e3, float e1_e3, float e2_e3, float no_ni, float e1_ni, float e2_ni, float e3_ni);

	/// returns the absolute largest coordinate.
	float largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	float largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the no^e1 coordinate.
	inline float get_no_e1() const { return m_c[0];}
	/// Sets the no^e1 coordinate.
	inline void set_no_e1(float no_e1) { m_c[0] = no_e1;}
	/// Returns the no^e2 coordinate.
	inline float get_no_e2() const { return m_c[1];}
	/// Sets the no^e2 coordinate.
	inline void set_no_e2(float no_e2) { m_c[1] = no_e2;}
	/// Returns the e1^e2 coordinate.
	inline float get_e1_e2() const { return m_c[2];}
	/// Sets the e1^e2 coordinate.
	inline void set_e1_e2(float e1_e2) { m_c[2] = e1_e2;}
	/// Returns the no^e3 coordinate.
	inline float get_no_e3() const { return m_c[3];}
	/// Sets the no^e3 coordinate.
	inline void set_no_e3(float no_e3) { m_c[3] = no_e3;}
	/// Returns the e1^e3 coordinate.
	inline float get_e1_e3() const { return m_c[4];}
	/// Sets the e1^e3 coordinate.
	inline void set_e1_e3(float e1_e3) { m_c[4] = e1_e3;}
	/// Returns the e2^e3 coordinate.
	inline float get_e2_e3() const { return m_c[5];}
	/// Sets the e2^e3 coordinate.
	inline void set_e2_e3(float e2_e3) { m_c[5] = e2_e3;}
	/// Returns the no^ni coordinate.
	inline float get_no_ni() const { return m_c[6];}
	/// Sets the no^ni coordinate.
	inline void set_no_ni(float no_ni) { m_c[6] = no_ni;}
	/// Returns the e1^ni coordinate.
	inline float get_e1_ni() const { return m_c[7];}
	/// Sets the e1^ni coordinate.
	inline void set_e1_ni(float e1_ni) { m_c[7] = e1_ni;}
	/// Returns the e2^ni coordinate.
	inline float get_e2_ni() const { return m_c[8];}
	/// Sets the e2^ni coordinate.
	inline void set_e2_ni(float e2_ni) { m_c[8] = e2_ni;}
	/// Returns the e3^ni coordinate.
	inline float get_e3_ni() const { return m_c[9];}
	/// Sets the e3^ni coordinate.
	inline void set_e3_ni(float e3_ni) { m_c[9] = e3_ni;}
	/// Returns the scalar coordinate (which is always 0).
	inline float get_scalar() const { return 0.0f;}
	/// Returns array of coordinates.
	inline const float *getC(CoordinateOrder) const { return m_c;}
}; // end of class pointPair

/// This class can hold a specialized multivector of type circle.
/// 
/// The coordinates are stored in type float.
/// 
/// The variable non-zero coordinates are:
///   - coordinate no^e1^e2  (array index: NO_E1_E2 = 0)
///   - coordinate no^e1^e3  (array index: NO_E1_E3 = 1)
///   - coordinate no^e2^e3  (array index: NO_E2_E3 = 2)
///   - coordinate e1^e2^e3  (array index: E1_E2_E3 = 3)
///   - coordinate no^e1^ni  (array index: NO_E1_NI = 4)
///   - coordinate no^e2^ni  (array index: NO_E2_NI = 5)
///   - coordinate e1^e2^ni  (array index: E1_E2_NI = 6)
///   - coordinate no^e3^ni  (array index: NO_E3_NI = 7)
///   - coordinate e1^e3^ni  (array index: E1_E3_NI = 8)
///   - coordinate e2^e3^ni  (array index: E2_E3_NI = 9)
/// 
/// The type has no constant coordinates.
/// 
/// 
class circle
{
public:
	/// The coordinates (stored in an array).
	float m_c[10]; // no^e1^e2, no^e1^e3, no^e2^e3, e1^e2^e3, no^e1^ni, no^e2^ni, e1^e2^ni, no^e3^ni, e1^e3^ni, e2^e3^ni
public:

	/// Floating point type used by circle 
	typedef float Float;
	/// Array indices of circle coordinates.
	typedef enum {
		/// index of coordinate for no^e1^e2 in circle
		NO_E1_E2 = 0, 
		/// index of coordinate for no^e1^e3 in circle
		NO_E1_E3 = 1, 
		/// index of coordinate for no^e2^e3 in circle
		NO_E2_E3 = 2, 
		/// index of coordinate for e1^e2^e3 in circle
		E1_E2_E3 = 3, 
		/// index of coordinate for no^e1^ni in circle
		NO_E1_NI = 4, 
		/// index of coordinate for no^e2^ni in circle
		NO_E2_NI = 5, 
		/// index of coordinate for e1^e2^ni in circle
		E1_E2_NI = 6, 
		/// index of coordinate for no^e3^ni in circle
		NO_E3_NI = 7, 
		/// index of coordinate for e1^e3^ni in circle
		E1_E3_NI = 8, 
		/// index of coordinate for e2^e3^ni in circle
		E2_E3_NI = 9, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni
	} CoordinateOrder;

	/// Constructs a new circle with variable coordinates set to 0.
	inline circle() {set();}

	/// Copy constructor.
	inline circle(const circle &A) {set(A);}



	/// Constructs a new circle from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline circle(const mv &A, int filler) {set(A);}

	/// Constructs a new circle. Coordinate values come from 'A'.
	inline circle(const CoordinateOrder co, const float A[10]) {set(co, A);}
	
	/// Constructs a new circle with each coordinate specified.
	inline circle(const CoordinateOrder co,  float no_e1_e2, float no_e1_e3, float no_e2_e3, float e1_e2_e3, float no_e1_ni, float no_e2_ni, float e1_e2_ni, float no_e3_ni, float e1_e3_ni, float e2_e3_ni) {
		set(co, no_e1_e2, no_e1_e3, no_e2_e3, e1_e2_e3, no_e1_ni, no_e2_ni, e1_e2_ni, no_e3_ni, e1_e3_ni, e2_e3_ni);
	}

	/// Assignment operator (circle).
	inline circle &operator=(const circle &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline circle &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const circle &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const float A[10]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  float no_e1_e2, float no_e1_e3, float no_e2_e3, float e1_e2_e3, float no_e1_ni, float no_e2_ni, float e1_e2_ni, float no_e3_ni, float e1_e3_ni, float e2_e3_ni);

	/// returns the absolute largest coordinate.
	float largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	float largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the no^e1^e2 coordinate.
	inline float get_no_e1_e2() const { return m_c[0];}
	/// Sets the no^e1^e2 coordinate.
	inline void set_no_e1_e2(float no_e1_e2) { m_c[0] = no_e1_e2;}
	/// Returns the no^e1^e3 coordinate.
	inline float get_no_e1_e3() const { return m_c[1];}
	/// Sets the no^e1^e3 coordinate.
	inline void set_no_e1_e3(float no_e1_e3) { m_c[1] = no_e1_e3;}
	/// Returns the no^e2^e3 coordinate.
	inline float get_no_e2_e3() const { return m_c[2];}
	/// Sets the no^e2^e3 coordinate.
	inline void set_no_e2_e3(float no_e2_e3) { m_c[2] = no_e2_e3;}
	/// Returns the e1^e2^e3 coordinate.
	inline float get_e1_e2_e3() const { return m_c[3];}
	/// Sets the e1^e2^e3 coordinate.
	inline void set_e1_e2_e3(float e1_e2_e3) { m_c[3] = e1_e2_e3;}
	/// Returns the no^e1^ni coordinate.
	inline float get_no_e1_ni() const { return m_c[4];}
	/// Sets the no^e1^ni coordinate.
	inline void set_no_e1_ni(float no_e1_ni) { m_c[4] = no_e1_ni;}
	/// Returns the no^e2^ni coordinate.
	inline float get_no_e2_ni() const { return m_c[5];}
	/// Sets the no^e2^ni coordinate.
	inline void set_no_e2_ni(float no_e2_ni) { m_c[5] = no_e2_ni;}
	/// Returns the e1^e2^ni coordinate.
	inline float get_e1_e2_ni() const { return m_c[6];}
	/// Sets the e1^e2^ni coordinate.
	inline void set_e1_e2_ni(float e1_e2_ni) { m_c[6] = e1_e2_ni;}
	/// Returns the no^e3^ni coordinate.
	inline float get_no_e3_ni() const { return m_c[7];}
	/// Sets the no^e3^ni coordinate.
	inline void set_no_e3_ni(float no_e3_ni) { m_c[7] = no_e3_ni;}
	/// Returns the e1^e3^ni coordinate.
	inline float get_e1_e3_ni() const { return m_c[8];}
	/// Sets the e1^e3^ni coordinate.
	inline void set_e1_e3_ni(float e1_e3_ni) { m_c[8] = e1_e3_ni;}
	/// Returns the e2^e3^ni coordinate.
	inline float get_e2_e3_ni() const { return m_c[9];}
	/// Sets the e2^e3^ni coordinate.
	inline void set_e2_e3_ni(float e2_e3_ni) { m_c[9] = e2_e3_ni;}
	/// Returns the scalar coordinate (which is always 0).
	inline float get_scalar() const { return 0.0f;}
	/// Returns array of coordinates.
	inline const float *getC(CoordinateOrder) const { return m_c;}
}; // end of class circle
extern no_t no;
extern e1_t e1;
extern e2_t e2;
extern e3_t e3;
extern ni_t ni;


/**
This class is used to report usage of converted specialized multivectors.

The class is designed to be pretty safe with multi-threading without locking.
In the worst case, some memory leaks occur and some counts are missed. 
The amount of memory leaked is bounded (does not grow beyond a certain
point). Since the report-usage functionality is for
development/debugging only, this is not considered non-harmful.
*/
class ReportUsage {
public:
	inline ReportUsage(std::string str, unsigned int initialCount = 1) : 
		m_hash(computeHash(str)),
		m_str(str), 
		m_count(initialCount), 
		m_left(NULL),
		m_right(NULL)
	{
	}

	static void mergeReport(ReportUsage *RU);

	/// prints out all reports, sorted by m_str
	static void printReport(FILE *F = stdout, bool includeCount = true);

protected:
	/// Turns a string into a hashcode which is used to efficiently search the tree
	static inline int computeHash(const std::string &str) {
		unsigned int hash = 0x83BA056E; // just a number
		int shift = 0;
		const int SHIFT_INC = 7;
		for (int i = 0; i < (int)str.length(); i++) {
			hash ^= (unsigned int)(str[i] << shift);
			shift += SHIFT_INC;
			if (shift > (sizeof(unsigned int) - SHIFT_INC))
				shift &= SHIFT_INC;
		}
		return hash;
	}

	/// return true if m_str is equal (checks the hash first)
	inline bool equals(const ReportUsage *RU) const {
		if (m_hash != RU->m_hash) return false;
		else return (m_str == RU->m_str);
	}

	/// Returns -1 for this < RU, 0 for equals, +1 for this > RU
	/// First compares the hash, then the string.
	inline int compare(const ReportUsage *RU) const {
		if (equals(RU)) return 0;
		else if (m_hash == RU->m_hash) {
			return m_str.compare(RU->m_str);
		}
		else return (m_hash < RU->m_hash) ? -1 : 1;
	}

	/// Merges 'RU' with the reports
	inline void mergeReportInternal(ReportUsage *RU) {
		if (equals(RU)) { // just increment the count?
			if ((m_count + RU->m_count) > m_count) // prevent overflow of unsigned int
				m_count += RU->m_count;
			delete RU;
		}
		else { // either recurse or set m_left or m_right
			int comp = compare(RU);
			if (comp < 0) {
				if (m_left == NULL) m_left = RU;
				else m_left->mergeReportInternal(RU);
			}
			else {
				if (m_right == NULL) m_right = RU;
				else m_right->mergeReportInternal(RU);
			}
		}
	}

	inline void getMap(std::map<std::string, const ReportUsage*> &M) const {
		M[m_str] = this;
		if (m_left) m_left->getMap(M);
		if (m_right) m_right->getMap(M);
	}

	static ReportUsage *s_reportTree;

	/// hashcode of m_str.
	unsigned int m_hash;
	/// string describing the report.
	std::string m_str;
	/// how many times this report hash been filed.
	unsigned int m_count;

	/// left branch of tree
	ReportUsage *m_left;
	/// right branch of tree
	ReportUsage *m_right;
}; // end of class ReportUsage

/** Sets 1 float to zero */
void zero_1(float *dst);
/** Copies 1 float from 'src' to 'dst' */
void copy_1(float *dst, const float *src);
/** Sets 2 floats to zero */
void zero_2(float *dst);
/** Copies 2 floats from 'src' to 'dst' */
void copy_2(float *dst, const float *src);
/** Sets 3 floats to zero */
void zero_3(float *dst);
/** Copies 3 floats from 'src' to 'dst' */
void copy_3(float *dst, const float *src);
/** Sets 4 floats to zero */
void zero_4(float *dst);
/** Copies 4 floats from 'src' to 'dst' */
void copy_4(float *dst, const float *src);
/** Sets 5 floats to zero */
void zero_5(float *dst);
/** Copies 5 floats from 'src' to 'dst' */
void copy_5(float *dst, const float *src);
/** Sets 6 floats to zero */
void zero_6(float *dst);
/** Copies 6 floats from 'src' to 'dst' */
void copy_6(float *dst, const float *src);
/** Sets 7 floats to zero */
void zero_7(float *dst);
/** Copies 7 floats from 'src' to 'dst' */
void copy_7(float *dst, const float *src);
/** Sets 8 floats to zero */
void zero_8(float *dst);
/** Copies 8 floats from 'src' to 'dst' */
void copy_8(float *dst, const float *src);
/** Sets 9 floats to zero */
void zero_9(float *dst);
/** Copies 9 floats from 'src' to 'dst' */
void copy_9(float *dst, const float *src);
/** Sets 10 floats to zero */
void zero_10(float *dst);
/** Copies 10 floats from 'src' to 'dst' */
void copy_10(float *dst, const float *src);
/** Sets 11 floats to zero */
void zero_11(float *dst);
/** Copies 11 floats from 'src' to 'dst' */
void copy_11(float *dst, const float *src);
/** Sets 12 floats to zero */
void zero_12(float *dst);
/** Copies 12 floats from 'src' to 'dst' */
void copy_12(float *dst, const float *src);
/** Sets 13 floats to zero */
void zero_13(float *dst);
/** Copies 13 floats from 'src' to 'dst' */
void copy_13(float *dst, const float *src);
/** Sets 14 floats to zero */
void zero_14(float *dst);
/** Copies 14 floats from 'src' to 'dst' */
void copy_14(float *dst, const float *src);
/** Sets 15 floats to zero */
void zero_15(float *dst);
/** Copies 15 floats from 'src' to 'dst' */
void copy_15(float *dst, const float *src);
/** Sets 16 floats to zero */
void zero_16(float *dst);
/** Copies 16 floats from 'src' to 'dst' */
void copy_16(float *dst, const float *src);
/** Sets N floats to zero */
void zero_N(float *dst, int N);
/** Copies N floats from 'src' to 'dst' */
void copy_N(float *dst, const float *src, int N);
// decl SB:

/// Returns scalar part of  mv
float _float(const mv &x);
/// Returns scalar part of  mv
inline float _Float(const mv &x) {return _float(x); };

/// Compresses coordinates 'c' into a new multivector.
/// \param c the coordinates (may already be partially compressed, see argument 'gu').
/// \param epsilon value with a abs magnitude < epsilon are considered to be 0.
/// \param gu optionally specifies which groups/grades are present in 'c'.
mv mv_compress(const float *c, float epsilon = 0.0f, int gu = 63);
/// Compresses an array of coordinates/basis blade bitmaps into a new multivector.
mv mv_compress(int nbBlades, const unsigned int *bitmaps, const float *coords);


/// Returns scalar part of  normalizedPoint
float _float(const normalizedPoint &x);
/// Returns scalar part of  normalizedPoint
inline float _Float(const normalizedPoint &x) {return _float(x); };
/// Returns scalar part of  flatPoint
float _float(const flatPoint &x);
/// Returns scalar part of  flatPoint
inline float _Float(const flatPoint &x) {return _float(x); };
/// Returns scalar part of  line
float _float(const line &x);
/// Returns scalar part of  line
inline float _Float(const line &x) {return _float(x); };
/// Returns scalar part of  plane
float _float(const plane &x);
/// Returns scalar part of  plane
inline float _Float(const plane &x) {return _float(x); };
/// Returns scalar part of  no_t
float _float(const no_t &x);
/// Returns scalar part of  no_t
inline float _Float(const no_t &x) {return _float(x); };
/// Returns scalar part of  e1_t
float _float(const e1_t &x);
/// Returns scalar part of  e1_t
inline float _Float(const e1_t &x) {return _float(x); };
/// Returns scalar part of  e2_t
float _float(const e2_t &x);
/// Returns scalar part of  e2_t
inline float _Float(const e2_t &x) {return _float(x); };
/// Returns scalar part of  e3_t
float _float(const e3_t &x);
/// Returns scalar part of  e3_t
inline float _Float(const e3_t &x) {return _float(x); };
/// Returns scalar part of  ni_t
float _float(const ni_t &x);
/// Returns scalar part of  ni_t
inline float _Float(const ni_t &x) {return _float(x); };
/// Returns scalar part of  pointPair
float _float(const pointPair &x);
/// Returns scalar part of  pointPair
inline float _Float(const pointPair &x) {return _float(x); };
/// Returns scalar part of  circle
float _float(const circle &x);
/// Returns scalar part of  circle
inline float _Float(const circle &x) {return _float(x); };
	/// Converts pointPair to flatPoint: dst = a.
flatPoint _flatPoint(const pointPair &a);
	/// Converts mv to normalizedPoint: dst = a. Automatically generated converter.
/// Converts mv to normalizedPoint: dst = a. Automatically generated converter.
normalizedPoint _normalizedPoint(const mv &a);
	/// Converts mv to flatPoint: dst = a. Automatically generated converter.
/// Converts mv to flatPoint: dst = a. Automatically generated converter.
flatPoint _flatPoint(const mv &a);
	/// Converts mv to line: dst = a. Automatically generated converter.
/// Converts mv to line: dst = a. Automatically generated converter.
line _line(const mv &a);
	/// Converts mv to plane: dst = a. Automatically generated converter.
/// Converts mv to plane: dst = a. Automatically generated converter.
plane _plane(const mv &a);
	/// Converts mv to no_t: dst = a. Automatically generated converter.
/// Converts mv to no_t: dst = a. Automatically generated converter.
no_t _no_t(const mv &a);
	/// Converts mv to e1_t: dst = a. Automatically generated converter.
/// Converts mv to e1_t: dst = a. Automatically generated converter.
e1_t _e1_t(const mv &a);
	/// Converts mv to e2_t: dst = a. Automatically generated converter.
/// Converts mv to e2_t: dst = a. Automatically generated converter.
e2_t _e2_t(const mv &a);
	/// Converts mv to e3_t: dst = a. Automatically generated converter.
/// Converts mv to e3_t: dst = a. Automatically generated converter.
e3_t _e3_t(const mv &a);
	/// Converts mv to ni_t: dst = a. Automatically generated converter.
/// Converts mv to ni_t: dst = a. Automatically generated converter.
ni_t _ni_t(const mv &a);
	/// Converts mv to pointPair: dst = a. Automatically generated converter.
/// Converts mv to pointPair: dst = a. Automatically generated converter.
pointPair _pointPair(const mv &a);
	/// Converts mv to circle: dst = a. Automatically generated converter.
/// Converts mv to circle: dst = a. Automatically generated converter.
circle _circle(const mv &a);
	/// Converts normalizedPoint to normalizedPoint: dst = a. Automatically generated converter.
/// Converts normalizedPoint to normalizedPoint: dst = a. Automatically generated converter.
normalizedPoint _normalizedPoint(const normalizedPoint &a);
	/// Converts flatPoint to flatPoint: dst = a. Automatically generated converter.
/// Converts flatPoint to flatPoint: dst = a. Automatically generated converter.
flatPoint _flatPoint(const flatPoint &a);
	/// Converts line to line: dst = a. Automatically generated converter.
/// Converts line to line: dst = a. Automatically generated converter.
line _line(const line &a);
	/// Converts plane to plane: dst = a. Automatically generated converter.
/// Converts plane to plane: dst = a. Automatically generated converter.
plane _plane(const plane &a);
	/// Converts no_t to no_t: dst = a. Automatically generated converter.
/// Converts no_t to no_t: dst = a. Automatically generated converter.
no_t _no_t(const no_t &a);
	/// Converts e1_t to e1_t: dst = a. Automatically generated converter.
/// Converts e1_t to e1_t: dst = a. Automatically generated converter.
e1_t _e1_t(const e1_t &a);
	/// Converts e2_t to e2_t: dst = a. Automatically generated converter.
/// Converts e2_t to e2_t: dst = a. Automatically generated converter.
e2_t _e2_t(const e2_t &a);
	/// Converts e3_t to e3_t: dst = a. Automatically generated converter.
/// Converts e3_t to e3_t: dst = a. Automatically generated converter.
e3_t _e3_t(const e3_t &a);
	/// Converts ni_t to ni_t: dst = a. Automatically generated converter.
/// Converts ni_t to ni_t: dst = a. Automatically generated converter.
ni_t _ni_t(const ni_t &a);
	/// Converts pointPair to pointPair: dst = a. Automatically generated converter.
/// Converts pointPair to pointPair: dst = a. Automatically generated converter.
pointPair _pointPair(const pointPair &a);
	/// Converts circle to circle: dst = a. Automatically generated converter.
/// Converts circle to circle: dst = a. Automatically generated converter.
circle _circle(const circle &a);
/// Returns mv + mv.
mv add(const mv &a, const mv &b);
/// Returns mv - mv.
mv subtract(const mv &a, const mv &b);
/// Returns conformal point.
normalizedPoint cgaPoint(const float a, const float b, const float c);
/// Returns grade groupBitmap of  mv.
mv extractGrade(const mv &a, const int groupBitmap);
/// Returns negation of mv.
mv negate(const mv &a);
/// Returns reverse of mv.
mv reverse(const mv &a);
/// Returns grade involution of mv.
mv gradeInvolution(const mv &a);
/// Returns Clifford conjugate of mv.
mv cliffordConjugate(const mv &a);
/// Returns geometric product of mv and mv.
mv gp(const mv &a, const mv &b);
/// Returns outer product of mv and mv.
mv op(const mv &a, const mv &b);
/// Returns scalar product of mv and mv.
float sp(const mv &a, const mv &b);
/// Returns Modified Hestenes inner product of mv and mv.
mv mhip(const mv &a, const mv &b);
/// Returns left contraction of mv and mv.
mv lc(const mv &a, const mv &b);
/// Returns norm of mv using default metric.
float norm(const mv &a);
/// internal conversion function
float norm_returns_scalar(const mv &a);
/// Returns unit of mv using default metric.
mv unit(const mv &a);
/// Returns a * b * inverse(a) using default metric.
mv applyVersor(const mv &a, const mv &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
mv applyUnitVersor(const mv &a, const mv &b);
/// Returns versor inverse of a using default metric.
mv versorInverse(const mv &a);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const mv &a, const mv &b, const float c);
/// Returns true if all coordinates of a are abs <= b
bool zero(const mv &a, const float b);
/// Returns dual of mv using default metric.
mv dual(const mv &a);
/// Returns undual of mv using default metric.
mv undual(const mv &a);

/** Computes exp of mv.
 */
mv exp(const mv &x, int order = 12);
/// Returns geometric product of mv and float.
mv gp(const mv &a, const float b);
/// Returns norm2 of mv using default metric.
float norm2(const mv &a);
/// internal conversion function
float norm2_returns_scalar(const mv &a);
/// Returns float b * mv a + float c.
mv sas(const mv &a, const float b, const float c);
/// Returns outer product of normalizedPoint and normalizedPoint.
pointPair op(const normalizedPoint &a, const normalizedPoint &b);
/// Returns outer product of pointPair and ni_t.
line op(const pointPair &a, const ni_t &b);
/// Returns outer product of pointPair and normalizedPoint.
circle op(const pointPair &a, const normalizedPoint &b);
/// Returns dual of line using default metric.
pointPair dual(const line &a);
/// Returns outer product of circle and ni_t.
plane op(const circle &a, const ni_t &b);
/// Returns left contraction of pointPair and plane.
pointPair lc(const pointPair &a, const plane &b);
/// returns add(a, b)
inline mv operator+(const mv &a, const mv &b) {
	return add(a, b);
}
/// returns (a = add(a, b))
inline mv &operator+=(mv &a, const mv &b) {
	return (a = add(a, b));
}
/// returns subtract(a, b)
inline mv operator-(const mv &a, const mv &b) {
	return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline mv &operator-=(mv &a, const mv &b) {
	return (a = subtract(a, b));
}
/// returns negate(a)
inline mv operator-(const mv &a) {
	return negate(a);
}
/// returns reverse(a)
inline mv operator~(const mv &a) {
	return reverse(a);
}
/// returns gp(a, b)
inline mv operator*(const mv &a, const mv &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline mv &operator*=(mv &a, const mv &b) {
	return (a = gp(a, b));
}
/// returns op(a, b)
inline mv operator^(const mv &a, const mv &b) {
	return op(a, b);
}
/// returns (a = op(a, b))
inline mv &operator^=(mv &a, const mv &b) {
	return (a = op(a, b));
}
/// returns sp(a, b)
inline float operator%(const mv &a, const mv &b) {
	return sp(a, b);
}
/// returns lc(a, b)
inline mv operator<<(const mv &a, const mv &b) {
	return lc(a, b);
}
/// returns (a = lc(a, b))
inline mv &operator<<=(mv &a, const mv &b) {
	return (a = lc(a, b));
}
/// returns versorInverse(a)
inline mv operator!(const mv &a) {
	return versorInverse(a);
}
/// returns dual(a)
inline mv operator*(const mv &a) {
	return dual(a);
}
/// returns gp(a, b)
inline mv operator*(const mv &a, const float &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline mv &operator*=(mv &a, const float &b) {
	return (a = gp(a, b));
}
/// returns op(a, b)
inline pointPair operator^(const normalizedPoint &a, const normalizedPoint &b) {
	return op(a, b);
}
/// returns op(a, b)
inline line operator^(const pointPair &a, const ni_t &b) {
	return op(a, b);
}
/// returns op(a, b)
inline circle operator^(const pointPair &a, const normalizedPoint &b) {
	return op(a, b);
}
/// returns dual(a)
inline pointPair operator*(const line &a) {
	return dual(a);
}
/// returns op(a, b)
inline plane operator^(const circle &a, const ni_t &b) {
	return op(a, b);
}
/// returns lc(a, b)
inline pointPair operator<<(const pointPair &a, const plane &b) {
	return lc(a, b);
}
/// returns (a = lc(a, b))
inline pointPair &operator<<=(pointPair &a, const plane &b) {
	return (a = lc(a, b));
}

inline void zero_1(float *dst) {
	dst[0]=0.0f;
}
inline void copy_1(float *dst, const float *src) {
	dst[0] = src[0];
}
inline void zero_2(float *dst) {
	dst[0]=dst[1]=0.0f;
}
inline void copy_2(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
}
inline void zero_3(float *dst) {
	dst[0]=dst[1]=dst[2]=0.0f;
}
inline void copy_3(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
}
inline void zero_4(float *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=0.0f;
}
inline void copy_4(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
}
inline void zero_5(float *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=0.0f;
}
inline void copy_5(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
}
inline void zero_6(float *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=0.0f;
}
inline void copy_6(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
}
inline void zero_7(float *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=0.0f;
}
inline void copy_7(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
}
inline void zero_8(float *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=0.0f;
}
inline void copy_8(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
}
inline void zero_9(float *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=0.0f;
}
inline void copy_9(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
}
inline void zero_10(float *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=0.0f;
}
inline void copy_10(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
}
inline void zero_11(float *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=0.0f;
}
inline void copy_11(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
}
inline void zero_12(float *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=0.0f;
}
inline void copy_12(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
}
inline void zero_13(float *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=0.0f;
}
inline void copy_13(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
}
inline void zero_14(float *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=dst[13]=0.0f;
}
inline void copy_14(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
	dst[13] = src[13];
}
inline void zero_15(float *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=dst[13]=dst[14]=0.0f;
}
inline void copy_15(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
	dst[13] = src[13];
	dst[14] = src[14];
}
inline void zero_16(float *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=dst[13]=dst[14]=dst[15]=0.0f;
}
inline void copy_16(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
	dst[13] = src[13];
	dst[14] = src[14];
	dst[15] = src[15];
}
/** Sets N floats to zero */
inline void zero_N(float *dst, int N) {
	int i = 0;
	while ((N-i) > 16) {
		zero_16(dst + i);
		i += 16;
	}
	for (; i < N; i++)
		dst[i] = 0.0f;
}
/** Copies N floats from 'src' to 'dst' */
inline void copy_N(float *dst, const float *src, int N) {
	int i = 0;
	while ((N-i) > 16) {
		copy_16(dst + i, src + i);
		i += 16;
	}
	for (; i < N; i++)
		dst[i] = src[i];
}
// inline def SB:
inline void mv::set() {
	setGroupUsage(0);
	m_t = C3GA_MV;
}
inline void mv::set(float val) {
	setGroupUsage(1);
	m_c[0] = val;
	m_t = C3GA_FLOAT;
}
inline void mv::set(int gu, const float *arr) {
	setGroupUsage(gu);
	c3ga::copy_N(m_c, arr, c3ga_mvSize[gu]);

	m_t = C3GA_MV;
}
inline void mv::set(const mv &src) {
	setGroupUsage(src.gu());
	const float*srcC = src.getC();
	c3ga::copy_N(m_c, srcC, c3ga_mvSize[src.gu()]);

	m_t = src.m_t;
}
inline void normalizedPoint::set(const mv &src) {
	const float *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		m_c[0] = ptr[1];
		m_c[1] = ptr[2];
		m_c[2] = ptr[3];
		m_c[3] = ptr[4];
	}
	else {
		m_c[0] = 0.0f;
		m_c[1] = 0.0f;
		m_c[2] = 0.0f;
		m_c[3] = 0.0f;
	}
}
inline void flatPoint::set(const mv &src) {
	const float *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 5;
	}
	if (src.gu() & 4) {
		m_c[0] = ptr[7];
		m_c[1] = ptr[8];
		m_c[2] = ptr[9];
		m_c[3] = ptr[6];
	}
	else {
		m_c[0] = 0.0f;
		m_c[1] = 0.0f;
		m_c[2] = 0.0f;
		m_c[3] = 0.0f;
	}
}
inline void line::set(const mv &src) {
	const float *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 5;
	}
	if (src.gu() & 4) {
		ptr += 10;
	}
	if (src.gu() & 8) {
		m_c[0] = ptr[6];
		m_c[1] = ptr[8];
		m_c[2] = ptr[9];
		m_c[3] = -ptr[4];
		m_c[4] = -ptr[5];
		m_c[5] = -ptr[7];
	}
	else {
		m_c[0] = 0.0f;
		m_c[1] = 0.0f;
		m_c[2] = 0.0f;
		m_c[3] = 0.0f;
		m_c[4] = 0.0f;
		m_c[5] = 0.0f;
	}
}
inline void plane::set(const mv &src) {
	const float *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 5;
	}
	if (src.gu() & 4) {
		ptr += 10;
	}
	if (src.gu() & 8) {
		ptr += 10;
	}
	if (src.gu() & 16) {
		m_c[0] = ptr[4];
		m_c[1] = ptr[3];
		m_c[2] = ptr[2];
		m_c[3] = ptr[1];
	}
	else {
		m_c[0] = 0.0f;
		m_c[1] = 0.0f;
		m_c[2] = 0.0f;
		m_c[3] = 0.0f;
	}
}
inline void no_t::set(const mv &src) {
	const float *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void e1_t::set(const mv &src) {
	const float *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void e2_t::set(const mv &src) {
	const float *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void e3_t::set(const mv &src) {
	const float *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void ni_t::set(const mv &src) {
	const float *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void pointPair::set(const mv &src) {
	const float *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 5;
	}
	if (src.gu() & 4) {
		m_c[0] = ptr[0];
		m_c[1] = ptr[1];
		m_c[2] = ptr[2];
		m_c[3] = ptr[3];
		m_c[4] = ptr[4];
		m_c[5] = ptr[5];
		m_c[6] = ptr[6];
		m_c[7] = ptr[7];
		m_c[8] = ptr[8];
		m_c[9] = ptr[9];
	}
	else {
		m_c[0] = 0.0f;
		m_c[1] = 0.0f;
		m_c[2] = 0.0f;
		m_c[3] = 0.0f;
		m_c[4] = 0.0f;
		m_c[5] = 0.0f;
		m_c[6] = 0.0f;
		m_c[7] = 0.0f;
		m_c[8] = 0.0f;
		m_c[9] = 0.0f;
	}
}
inline void circle::set(const mv &src) {
	const float *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 5;
	}
	if (src.gu() & 4) {
		ptr += 10;
	}
	if (src.gu() & 8) {
		m_c[0] = ptr[0];
		m_c[1] = ptr[1];
		m_c[2] = ptr[2];
		m_c[3] = ptr[3];
		m_c[4] = ptr[4];
		m_c[5] = ptr[5];
		m_c[6] = ptr[6];
		m_c[7] = ptr[7];
		m_c[8] = ptr[8];
		m_c[9] = ptr[9];
	}
	else {
		m_c[0] = 0.0f;
		m_c[1] = 0.0f;
		m_c[2] = 0.0f;
		m_c[3] = 0.0f;
		m_c[4] = 0.0f;
		m_c[5] = 0.0f;
		m_c[6] = 0.0f;
		m_c[7] = 0.0f;
		m_c[8] = 0.0f;
		m_c[9] = 0.0f;
	}
}
inline void mv::set(const normalizedPoint &src) {
	setGroupUsage(2);
	float *ptr = m_c;
	ptr[0] = 1.0f;
	ptr[1] = src.m_c[0];
	ptr[2] = src.m_c[1];
	ptr[3] = src.m_c[2];
	ptr[4] = src.m_c[3];
	m_t = C3GA_NORMALIZEDPOINT;
}
inline void mv::set(const flatPoint &src) {
	setGroupUsage(4);
	float *ptr = m_c;
	ptr[0] = ptr[1] = ptr[2] = ptr[3] = ptr[4] = ptr[5] = 0.0f;
	ptr[6] = src.m_c[3];
	ptr[7] = src.m_c[0];
	ptr[8] = src.m_c[1];
	ptr[9] = src.m_c[2];
	m_t = C3GA_FLATPOINT;
}
inline void mv::set(const line &src) {
	setGroupUsage(8);
	float *ptr = m_c;
	ptr[0] = ptr[1] = ptr[2] = ptr[3] = 0.0f;
	ptr[4] = -src.m_c[3];
	ptr[5] = -src.m_c[4];
	ptr[6] = src.m_c[0];
	ptr[7] = -src.m_c[5];
	ptr[8] = src.m_c[1];
	ptr[9] = src.m_c[2];
	m_t = C3GA_LINE;
}
inline void mv::set(const plane &src) {
	setGroupUsage(16);
	float *ptr = m_c;
	ptr[0] = 0.0f;
	ptr[1] = src.m_c[3];
	ptr[2] = src.m_c[2];
	ptr[3] = src.m_c[1];
	ptr[4] = src.m_c[0];
	m_t = C3GA_PLANE;
}
inline void mv::set(const no_t &src) {
	setGroupUsage(2);
	float *ptr = m_c;
	ptr[0] = 1.0f;
	ptr[1] = ptr[2] = ptr[3] = ptr[4] = 0.0f;
	m_t = C3GA_NO_T;
}
inline void mv::set(const e1_t &src) {
	setGroupUsage(2);
	float *ptr = m_c;
	ptr[0] = ptr[2] = ptr[3] = ptr[4] = 0.0f;
	ptr[1] = 1.0f;
	m_t = C3GA_E1_T;
}
inline void mv::set(const e2_t &src) {
	setGroupUsage(2);
	float *ptr = m_c;
	ptr[0] = ptr[1] = ptr[3] = ptr[4] = 0.0f;
	ptr[2] = 1.0f;
	m_t = C3GA_E2_T;
}
inline void mv::set(const e3_t &src) {
	setGroupUsage(2);
	float *ptr = m_c;
	ptr[0] = ptr[1] = ptr[2] = ptr[4] = 0.0f;
	ptr[3] = 1.0f;
	m_t = C3GA_E3_T;
}
inline void mv::set(const ni_t &src) {
	setGroupUsage(2);
	float *ptr = m_c;
	ptr[0] = ptr[1] = ptr[2] = ptr[3] = 0.0f;
	ptr[4] = 1.0f;
	m_t = C3GA_NI_T;
}
inline void mv::set(const pointPair &src) {
	setGroupUsage(4);
	float *ptr = m_c;
	ptr[0] = src.m_c[0];
	ptr[1] = src.m_c[1];
	ptr[2] = src.m_c[2];
	ptr[3] = src.m_c[3];
	ptr[4] = src.m_c[4];
	ptr[5] = src.m_c[5];
	ptr[6] = src.m_c[6];
	ptr[7] = src.m_c[7];
	ptr[8] = src.m_c[8];
	ptr[9] = src.m_c[9];
	m_t = C3GA_POINTPAIR;
}
inline void mv::set(const circle &src) {
	setGroupUsage(8);
	float *ptr = m_c;
	ptr[0] = src.m_c[0];
	ptr[1] = src.m_c[1];
	ptr[2] = src.m_c[2];
	ptr[3] = src.m_c[3];
	ptr[4] = src.m_c[4];
	ptr[5] = src.m_c[5];
	ptr[6] = src.m_c[6];
	ptr[7] = src.m_c[7];
	ptr[8] = src.m_c[8];
	ptr[9] = src.m_c[9];
	m_t = C3GA_CIRCLE;
}

inline float _float(const mv &x) {
	return ((x.gu() & 1) != 0) ? x.getC()[0] : 0.0f;
}

inline void normalizedPoint::set()
{
	m_c[0] = m_c[1] = m_c[2] = m_c[3] = 0.0f;

}
inline void flatPoint::set()
{
	m_c[0] = m_c[1] = m_c[2] = m_c[3] = 0.0f;

}
inline void line::set()
{
	m_c[0] = m_c[1] = m_c[2] = m_c[3] = m_c[4] = m_c[5] = 0.0f;

}
inline void plane::set()
{
	m_c[0] = m_c[1] = m_c[2] = m_c[3] = 0.0f;

}
inline void pointPair::set()
{
	m_c[0] = m_c[1] = m_c[2] = m_c[3] = m_c[4] = m_c[5] = m_c[6] = m_c[7] = m_c[8] = m_c[9] = 0.0f;

}
inline void circle::set()
{
	m_c[0] = m_c[1] = m_c[2] = m_c[3] = m_c[4] = m_c[5] = m_c[6] = m_c[7] = m_c[8] = m_c[9] = 0.0f;

}


inline void normalizedPoint::set(const CoordinateOrder co, const float _e1, const float _e2, const float _e3, const float _ni)
{
	m_c[0] = _e1;
	m_c[1] = _e2;
	m_c[2] = _e3;
	m_c[3] = _ni;

}
inline void flatPoint::set(const CoordinateOrder co, const float _e1_ni, const float _e2_ni, const float _e3_ni, const float _no_ni)
{
	m_c[0] = _e1_ni;
	m_c[1] = _e2_ni;
	m_c[2] = _e3_ni;
	m_c[3] = _no_ni;

}
inline void line::set(const CoordinateOrder co, const float _e1_e2_ni, const float _e1_e3_ni, const float _e2_e3_ni, const float _e1_no_ni, const float _e2_no_ni, const float _e3_no_ni)
{
	m_c[0] = _e1_e2_ni;
	m_c[1] = _e1_e3_ni;
	m_c[2] = _e2_e3_ni;
	m_c[3] = _e1_no_ni;
	m_c[4] = _e2_no_ni;
	m_c[5] = _e3_no_ni;

}
inline void plane::set(const CoordinateOrder co, const float _e1_e2_e3_ni, const float _no_e2_e3_ni, const float _no_e1_e3_ni, const float _no_e1_e2_ni)
{
	m_c[0] = _e1_e2_e3_ni;
	m_c[1] = _no_e2_e3_ni;
	m_c[2] = _no_e1_e3_ni;
	m_c[3] = _no_e1_e2_ni;

}
inline void pointPair::set(const CoordinateOrder co, const float _no_e1, const float _no_e2, const float _e1_e2, const float _no_e3, const float _e1_e3, const float _e2_e3, const float _no_ni, const float _e1_ni, const float _e2_ni, const float _e3_ni)
{
	m_c[0] = _no_e1;
	m_c[1] = _no_e2;
	m_c[2] = _e1_e2;
	m_c[3] = _no_e3;
	m_c[4] = _e1_e3;
	m_c[5] = _e2_e3;
	m_c[6] = _no_ni;
	m_c[7] = _e1_ni;
	m_c[8] = _e2_ni;
	m_c[9] = _e3_ni;

}
inline void circle::set(const CoordinateOrder co, const float _no_e1_e2, const float _no_e1_e3, const float _no_e2_e3, const float _e1_e2_e3, const float _no_e1_ni, const float _no_e2_ni, const float _e1_e2_ni, const float _no_e3_ni, const float _e1_e3_ni, const float _e2_e3_ni)
{
	m_c[0] = _no_e1_e2;
	m_c[1] = _no_e1_e3;
	m_c[2] = _no_e2_e3;
	m_c[3] = _e1_e2_e3;
	m_c[4] = _no_e1_ni;
	m_c[5] = _no_e2_ni;
	m_c[6] = _e1_e2_ni;
	m_c[7] = _no_e3_ni;
	m_c[8] = _e1_e3_ni;
	m_c[9] = _e2_e3_ni;

}

inline void normalizedPoint::set(const CoordinateOrder co, const float *A)
{
	m_c[0] = A[0];
	m_c[1] = A[1];
	m_c[2] = A[2];
	m_c[3] = A[3];

}
inline void flatPoint::set(const CoordinateOrder co, const float *A)
{
	m_c[0] = A[0];
	m_c[1] = A[1];
	m_c[2] = A[2];
	m_c[3] = A[3];

}
inline void line::set(const CoordinateOrder co, const float *A)
{
	m_c[0] = A[0];
	m_c[1] = A[1];
	m_c[2] = A[2];
	m_c[3] = A[3];
	m_c[4] = A[4];
	m_c[5] = A[5];

}
inline void plane::set(const CoordinateOrder co, const float *A)
{
	m_c[0] = A[0];
	m_c[1] = A[1];
	m_c[2] = A[2];
	m_c[3] = A[3];

}
inline void pointPair::set(const CoordinateOrder co, const float *A)
{
	m_c[0] = A[0];
	m_c[1] = A[1];
	m_c[2] = A[2];
	m_c[3] = A[3];
	m_c[4] = A[4];
	m_c[5] = A[5];
	m_c[6] = A[6];
	m_c[7] = A[7];
	m_c[8] = A[8];
	m_c[9] = A[9];

}
inline void circle::set(const CoordinateOrder co, const float *A)
{
	m_c[0] = A[0];
	m_c[1] = A[1];
	m_c[2] = A[2];
	m_c[3] = A[3];
	m_c[4] = A[4];
	m_c[5] = A[5];
	m_c[6] = A[6];
	m_c[7] = A[7];
	m_c[8] = A[8];
	m_c[9] = A[9];

}

inline void normalizedPoint::set(const normalizedPoint &a)
{
	m_c[0] = a.m_c[0];
	m_c[1] = a.m_c[1];
	m_c[2] = a.m_c[2];
	m_c[3] = a.m_c[3];

}
inline void flatPoint::set(const flatPoint &a)
{
	m_c[0] = a.m_c[0];
	m_c[1] = a.m_c[1];
	m_c[2] = a.m_c[2];
	m_c[3] = a.m_c[3];

}
inline void line::set(const line &a)
{
	m_c[0] = a.m_c[0];
	m_c[1] = a.m_c[1];
	m_c[2] = a.m_c[2];
	m_c[3] = a.m_c[3];
	m_c[4] = a.m_c[4];
	m_c[5] = a.m_c[5];

}
inline void plane::set(const plane &a)
{
	m_c[0] = a.m_c[0];
	m_c[1] = a.m_c[1];
	m_c[2] = a.m_c[2];
	m_c[3] = a.m_c[3];

}
inline void no_t::set(const no_t &a)
{

}
inline void e1_t::set(const e1_t &a)
{

}
inline void e2_t::set(const e2_t &a)
{

}
inline void e3_t::set(const e3_t &a)
{

}
inline void ni_t::set(const ni_t &a)
{

}
inline void pointPair::set(const pointPair &a)
{
	m_c[0] = a.m_c[0];
	m_c[1] = a.m_c[1];
	m_c[2] = a.m_c[2];
	m_c[3] = a.m_c[3];
	m_c[4] = a.m_c[4];
	m_c[5] = a.m_c[5];
	m_c[6] = a.m_c[6];
	m_c[7] = a.m_c[7];
	m_c[8] = a.m_c[8];
	m_c[9] = a.m_c[9];

}
inline void circle::set(const circle &a)
{
	m_c[0] = a.m_c[0];
	m_c[1] = a.m_c[1];
	m_c[2] = a.m_c[2];
	m_c[3] = a.m_c[3];
	m_c[4] = a.m_c[4];
	m_c[5] = a.m_c[5];
	m_c[6] = a.m_c[6];
	m_c[7] = a.m_c[7];
	m_c[8] = a.m_c[8];
	m_c[9] = a.m_c[9];

}


inline float normalizedPoint::largestCoordinate() const {
	float maxValue = 1.0f;
	if (::fabsf(m_c[0]) > maxValue) { maxValue = ::fabsf(m_c[0]); }
	if (::fabsf(m_c[1]) > maxValue) { maxValue = ::fabsf(m_c[1]); }
	if (::fabsf(m_c[2]) > maxValue) { maxValue = ::fabsf(m_c[2]); }
	if (::fabsf(m_c[3]) > maxValue) { maxValue = ::fabsf(m_c[3]); }
	return maxValue;
}
inline float normalizedPoint::largestBasisBlade(unsigned int &bm) const {
	float maxValue = 1.0f;
	bm = 1;
	if (::fabsf(m_c[0]) > maxValue) { maxValue = ::fabsf(m_c[0]); bm = 2; }
	if (::fabsf(m_c[1]) > maxValue) { maxValue = ::fabsf(m_c[1]); bm = 4; }
	if (::fabsf(m_c[2]) > maxValue) { maxValue = ::fabsf(m_c[2]); bm = 8; }
	if (::fabsf(m_c[3]) > maxValue) { maxValue = ::fabsf(m_c[3]); bm = 16; }
	return maxValue;
}
inline float flatPoint::largestCoordinate() const {
	float maxValue = ::fabsf(m_c[0]);
	if (::fabsf(m_c[1]) > maxValue) { maxValue = ::fabsf(m_c[1]); }
	if (::fabsf(m_c[2]) > maxValue) { maxValue = ::fabsf(m_c[2]); }
	if (::fabsf(m_c[3]) > maxValue) { maxValue = ::fabsf(m_c[3]); }
	return maxValue;
}
inline float flatPoint::largestBasisBlade(unsigned int &bm) const {
	float maxValue = ::fabsf(m_c[0]);
	bm = 0;
	if (::fabsf(m_c[1]) > maxValue) { maxValue = ::fabsf(m_c[1]); bm = 20; }
	if (::fabsf(m_c[2]) > maxValue) { maxValue = ::fabsf(m_c[2]); bm = 24; }
	if (::fabsf(m_c[3]) > maxValue) { maxValue = ::fabsf(m_c[3]); bm = 17; }
	return maxValue;
}
inline float line::largestCoordinate() const {
	float maxValue = ::fabsf(m_c[0]);
	if (::fabsf(m_c[1]) > maxValue) { maxValue = ::fabsf(m_c[1]); }
	if (::fabsf(m_c[2]) > maxValue) { maxValue = ::fabsf(m_c[2]); }
	if (::fabsf(m_c[3]) > maxValue) { maxValue = ::fabsf(m_c[3]); }
	if (::fabsf(m_c[4]) > maxValue) { maxValue = ::fabsf(m_c[4]); }
	if (::fabsf(m_c[5]) > maxValue) { maxValue = ::fabsf(m_c[5]); }
	return maxValue;
}
inline float line::largestBasisBlade(unsigned int &bm) const {
	float maxValue = ::fabsf(m_c[0]);
	bm = 0;
	if (::fabsf(m_c[1]) > maxValue) { maxValue = ::fabsf(m_c[1]); bm = 26; }
	if (::fabsf(m_c[2]) > maxValue) { maxValue = ::fabsf(m_c[2]); bm = 28; }
	if (::fabsf(m_c[3]) > maxValue) { maxValue = ::fabsf(m_c[3]); bm = 19; }
	if (::fabsf(m_c[4]) > maxValue) { maxValue = ::fabsf(m_c[4]); bm = 21; }
	if (::fabsf(m_c[5]) > maxValue) { maxValue = ::fabsf(m_c[5]); bm = 25; }
	return maxValue;
}
inline float plane::largestCoordinate() const {
	float maxValue = ::fabsf(m_c[0]);
	if (::fabsf(m_c[1]) > maxValue) { maxValue = ::fabsf(m_c[1]); }
	if (::fabsf(m_c[2]) > maxValue) { maxValue = ::fabsf(m_c[2]); }
	if (::fabsf(m_c[3]) > maxValue) { maxValue = ::fabsf(m_c[3]); }
	return maxValue;
}
inline float plane::largestBasisBlade(unsigned int &bm) const {
	float maxValue = ::fabsf(m_c[0]);
	bm = 0;
	if (::fabsf(m_c[1]) > maxValue) { maxValue = ::fabsf(m_c[1]); bm = 29; }
	if (::fabsf(m_c[2]) > maxValue) { maxValue = ::fabsf(m_c[2]); bm = 27; }
	if (::fabsf(m_c[3]) > maxValue) { maxValue = ::fabsf(m_c[3]); bm = 23; }
	return maxValue;
}
inline float no_t::largestCoordinate() const {
	float maxValue = 1.0f;
	return maxValue;
}
inline float no_t::largestBasisBlade(unsigned int &bm) const {
	float maxValue = 1.0f;
	bm = 1;
	return maxValue;
}
inline float e1_t::largestCoordinate() const {
	float maxValue = 1.0f;
	return maxValue;
}
inline float e1_t::largestBasisBlade(unsigned int &bm) const {
	float maxValue = 1.0f;
	bm = 2;
	return maxValue;
}
inline float e2_t::largestCoordinate() const {
	float maxValue = 1.0f;
	return maxValue;
}
inline float e2_t::largestBasisBlade(unsigned int &bm) const {
	float maxValue = 1.0f;
	bm = 4;
	return maxValue;
}
inline float e3_t::largestCoordinate() const {
	float maxValue = 1.0f;
	return maxValue;
}
inline float e3_t::largestBasisBlade(unsigned int &bm) const {
	float maxValue = 1.0f;
	bm = 8;
	return maxValue;
}
inline float ni_t::largestCoordinate() const {
	float maxValue = 1.0f;
	return maxValue;
}
inline float ni_t::largestBasisBlade(unsigned int &bm) const {
	float maxValue = 1.0f;
	bm = 16;
	return maxValue;
}
inline float pointPair::largestCoordinate() const {
	float maxValue = ::fabsf(m_c[0]);
	if (::fabsf(m_c[1]) > maxValue) { maxValue = ::fabsf(m_c[1]); }
	if (::fabsf(m_c[2]) > maxValue) { maxValue = ::fabsf(m_c[2]); }
	if (::fabsf(m_c[3]) > maxValue) { maxValue = ::fabsf(m_c[3]); }
	if (::fabsf(m_c[4]) > maxValue) { maxValue = ::fabsf(m_c[4]); }
	if (::fabsf(m_c[5]) > maxValue) { maxValue = ::fabsf(m_c[5]); }
	if (::fabsf(m_c[6]) > maxValue) { maxValue = ::fabsf(m_c[6]); }
	if (::fabsf(m_c[7]) > maxValue) { maxValue = ::fabsf(m_c[7]); }
	if (::fabsf(m_c[8]) > maxValue) { maxValue = ::fabsf(m_c[8]); }
	if (::fabsf(m_c[9]) > maxValue) { maxValue = ::fabsf(m_c[9]); }
	return maxValue;
}
inline float pointPair::largestBasisBlade(unsigned int &bm) const {
	float maxValue = ::fabsf(m_c[0]);
	bm = 0;
	if (::fabsf(m_c[1]) > maxValue) { maxValue = ::fabsf(m_c[1]); bm = 5; }
	if (::fabsf(m_c[2]) > maxValue) { maxValue = ::fabsf(m_c[2]); bm = 6; }
	if (::fabsf(m_c[3]) > maxValue) { maxValue = ::fabsf(m_c[3]); bm = 9; }
	if (::fabsf(m_c[4]) > maxValue) { maxValue = ::fabsf(m_c[4]); bm = 10; }
	if (::fabsf(m_c[5]) > maxValue) { maxValue = ::fabsf(m_c[5]); bm = 12; }
	if (::fabsf(m_c[6]) > maxValue) { maxValue = ::fabsf(m_c[6]); bm = 17; }
	if (::fabsf(m_c[7]) > maxValue) { maxValue = ::fabsf(m_c[7]); bm = 18; }
	if (::fabsf(m_c[8]) > maxValue) { maxValue = ::fabsf(m_c[8]); bm = 20; }
	if (::fabsf(m_c[9]) > maxValue) { maxValue = ::fabsf(m_c[9]); bm = 24; }
	return maxValue;
}
inline float circle::largestCoordinate() const {
	float maxValue = ::fabsf(m_c[0]);
	if (::fabsf(m_c[1]) > maxValue) { maxValue = ::fabsf(m_c[1]); }
	if (::fabsf(m_c[2]) > maxValue) { maxValue = ::fabsf(m_c[2]); }
	if (::fabsf(m_c[3]) > maxValue) { maxValue = ::fabsf(m_c[3]); }
	if (::fabsf(m_c[4]) > maxValue) { maxValue = ::fabsf(m_c[4]); }
	if (::fabsf(m_c[5]) > maxValue) { maxValue = ::fabsf(m_c[5]); }
	if (::fabsf(m_c[6]) > maxValue) { maxValue = ::fabsf(m_c[6]); }
	if (::fabsf(m_c[7]) > maxValue) { maxValue = ::fabsf(m_c[7]); }
	if (::fabsf(m_c[8]) > maxValue) { maxValue = ::fabsf(m_c[8]); }
	if (::fabsf(m_c[9]) > maxValue) { maxValue = ::fabsf(m_c[9]); }
	return maxValue;
}
inline float circle::largestBasisBlade(unsigned int &bm) const {
	float maxValue = ::fabsf(m_c[0]);
	bm = 0;
	if (::fabsf(m_c[1]) > maxValue) { maxValue = ::fabsf(m_c[1]); bm = 11; }
	if (::fabsf(m_c[2]) > maxValue) { maxValue = ::fabsf(m_c[2]); bm = 13; }
	if (::fabsf(m_c[3]) > maxValue) { maxValue = ::fabsf(m_c[3]); bm = 14; }
	if (::fabsf(m_c[4]) > maxValue) { maxValue = ::fabsf(m_c[4]); bm = 19; }
	if (::fabsf(m_c[5]) > maxValue) { maxValue = ::fabsf(m_c[5]); bm = 21; }
	if (::fabsf(m_c[6]) > maxValue) { maxValue = ::fabsf(m_c[6]); bm = 22; }
	if (::fabsf(m_c[7]) > maxValue) { maxValue = ::fabsf(m_c[7]); bm = 25; }
	if (::fabsf(m_c[8]) > maxValue) { maxValue = ::fabsf(m_c[8]); bm = 26; }
	if (::fabsf(m_c[9]) > maxValue) { maxValue = ::fabsf(m_c[9]); bm = 28; }
	return maxValue;
}

inline float _float(const normalizedPoint &x) {
	return 0.0f;
}
inline float _float(const flatPoint &x) {
	return 0.0f;
}
inline float _float(const line &x) {
	return 0.0f;
}
inline float _float(const plane &x) {
	return 0.0f;
}
inline float _float(const no_t &x) {
	return 0.0f;
}
inline float _float(const e1_t &x) {
	return 0.0f;
}
inline float _float(const e2_t &x) {
	return 0.0f;
}
inline float _float(const e3_t &x) {
	return 0.0f;
}
inline float _float(const ni_t &x) {
	return 0.0f;
}
inline float _float(const pointPair &x) {
	return 0.0f;
}
inline float _float(const circle &x) {
	return 0.0f;
}
inline flatPoint _flatPoint(const pointPair &a)
{
	return flatPoint(flatPoint::coord_e1ni_e2ni_e3ni_noni,
			a.m_c[7], // e1_ni
			a.m_c[8], // e2_ni
			a.m_c[9], // e3_ni
			a.m_c[6] // no_ni
		);

}
inline normalizedPoint _normalizedPoint(const mv &a)
{
	if ((a.m_t > C3GA_MV) && (a.m_t < C3GA_INVALID)) {
			std::string reportUsageString = std::string("") + "<function name=\"_normalizedPoint\" arg1=\""+ g_c3gaTypenames[a.m_t] + "\" comment=\" Automatically generated converter.\"/>";
			ReportUsage::mergeReport(new ReportUsage(reportUsageString));
	}
	return normalizedPoint(a, 0);
}
inline flatPoint _flatPoint(const mv &a)
{
	if ((a.m_t > C3GA_MV) && (a.m_t < C3GA_INVALID)) {
			std::string reportUsageString = std::string("") + "<function name=\"_flatPoint\" arg1=\""+ g_c3gaTypenames[a.m_t] + "\" comment=\" Automatically generated converter.\"/>";
			ReportUsage::mergeReport(new ReportUsage(reportUsageString));
	}
	return flatPoint(a, 0);
}
inline line _line(const mv &a)
{
	if ((a.m_t > C3GA_MV) && (a.m_t < C3GA_INVALID)) {
			std::string reportUsageString = std::string("") + "<function name=\"_line\" arg1=\""+ g_c3gaTypenames[a.m_t] + "\" comment=\" Automatically generated converter.\"/>";
			ReportUsage::mergeReport(new ReportUsage(reportUsageString));
	}
	return line(a, 0);
}
inline plane _plane(const mv &a)
{
	if ((a.m_t > C3GA_MV) && (a.m_t < C3GA_INVALID)) {
			std::string reportUsageString = std::string("") + "<function name=\"_plane\" arg1=\""+ g_c3gaTypenames[a.m_t] + "\" comment=\" Automatically generated converter.\"/>";
			ReportUsage::mergeReport(new ReportUsage(reportUsageString));
	}
	return plane(a, 0);
}
inline no_t _no_t(const mv &a)
{
	if ((a.m_t > C3GA_MV) && (a.m_t < C3GA_INVALID)) {
			std::string reportUsageString = std::string("") + "<function name=\"_no_t\" arg1=\""+ g_c3gaTypenames[a.m_t] + "\" comment=\" Automatically generated converter.\"/>";
			ReportUsage::mergeReport(new ReportUsage(reportUsageString));
	}
	return no_t(a, 0);
}
inline e1_t _e1_t(const mv &a)
{
	if ((a.m_t > C3GA_MV) && (a.m_t < C3GA_INVALID)) {
			std::string reportUsageString = std::string("") + "<function name=\"_e1_t\" arg1=\""+ g_c3gaTypenames[a.m_t] + "\" comment=\" Automatically generated converter.\"/>";
			ReportUsage::mergeReport(new ReportUsage(reportUsageString));
	}
	return e1_t(a, 0);
}
inline e2_t _e2_t(const mv &a)
{
	if ((a.m_t > C3GA_MV) && (a.m_t < C3GA_INVALID)) {
			std::string reportUsageString = std::string("") + "<function name=\"_e2_t\" arg1=\""+ g_c3gaTypenames[a.m_t] + "\" comment=\" Automatically generated converter.\"/>";
			ReportUsage::mergeReport(new ReportUsage(reportUsageString));
	}
	return e2_t(a, 0);
}
inline e3_t _e3_t(const mv &a)
{
	if ((a.m_t > C3GA_MV) && (a.m_t < C3GA_INVALID)) {
			std::string reportUsageString = std::string("") + "<function name=\"_e3_t\" arg1=\""+ g_c3gaTypenames[a.m_t] + "\" comment=\" Automatically generated converter.\"/>";
			ReportUsage::mergeReport(new ReportUsage(reportUsageString));
	}
	return e3_t(a, 0);
}
inline ni_t _ni_t(const mv &a)
{
	if ((a.m_t > C3GA_MV) && (a.m_t < C3GA_INVALID)) {
			std::string reportUsageString = std::string("") + "<function name=\"_ni_t\" arg1=\""+ g_c3gaTypenames[a.m_t] + "\" comment=\" Automatically generated converter.\"/>";
			ReportUsage::mergeReport(new ReportUsage(reportUsageString));
	}
	return ni_t(a, 0);
}
inline pointPair _pointPair(const mv &a)
{
	if ((a.m_t > C3GA_MV) && (a.m_t < C3GA_INVALID)) {
			std::string reportUsageString = std::string("") + "<function name=\"_pointPair\" arg1=\""+ g_c3gaTypenames[a.m_t] + "\" comment=\" Automatically generated converter.\"/>";
			ReportUsage::mergeReport(new ReportUsage(reportUsageString));
	}
	return pointPair(a, 0);
}
inline circle _circle(const mv &a)
{
	if ((a.m_t > C3GA_MV) && (a.m_t < C3GA_INVALID)) {
			std::string reportUsageString = std::string("") + "<function name=\"_circle\" arg1=\""+ g_c3gaTypenames[a.m_t] + "\" comment=\" Automatically generated converter.\"/>";
			ReportUsage::mergeReport(new ReportUsage(reportUsageString));
	}
	return circle(a, 0);
}
inline normalizedPoint _normalizedPoint(const normalizedPoint &a)
{
	return a;
}
inline flatPoint _flatPoint(const flatPoint &a)
{
	return a;
}
inline line _line(const line &a)
{
	return a;
}
inline plane _plane(const plane &a)
{
	return a;
}
inline no_t _no_t(const no_t &a)
{
	return a;
}
inline e1_t _e1_t(const e1_t &a)
{
	return a;
}
inline e2_t _e2_t(const e2_t &a)
{
	return a;
}
inline e3_t _e3_t(const e3_t &a)
{
	return a;
}
inline ni_t _ni_t(const ni_t &a)
{
	return a;
}
inline pointPair _pointPair(const pointPair &a)
{
	return a;
}
inline circle _circle(const circle &a)
{
	return a;
}
inline normalizedPoint cgaPoint(const float a, const float b, const float c)
{
	return normalizedPoint(normalizedPoint::coord_e1_e2_e3_ni,
			a, // e1
			b, // e2
			c, // e3
			(0.5f*a*a+0.5f*b*b+0.5f*c*c) // ni
		);
}
inline float norm_returns_scalar(const mv &a) {
	return norm(a);
}
inline float norm2_returns_scalar(const mv &a) {
	return norm2(a);
}
inline pointPair op(const normalizedPoint &a, const normalizedPoint &b)
{
	return pointPair(pointPair::coord_noe1_noe2_e1e2_noe3_e1e3_e2e3_noni_e1ni_e2ni_e3ni,
			(-a.m_c[0]+b.m_c[0]), // no_e1
			(-a.m_c[1]+b.m_c[1]), // no_e2
			(a.m_c[0]*b.m_c[1]-a.m_c[1]*b.m_c[0]), // e1_e2
			(-a.m_c[2]+b.m_c[2]), // no_e3
			(a.m_c[0]*b.m_c[2]-a.m_c[2]*b.m_c[0]), // e1_e3
			(a.m_c[1]*b.m_c[2]-a.m_c[2]*b.m_c[1]), // e2_e3
			(-a.m_c[3]+b.m_c[3]), // no_ni
			(a.m_c[0]*b.m_c[3]-a.m_c[3]*b.m_c[0]), // e1_ni
			(a.m_c[1]*b.m_c[3]-a.m_c[3]*b.m_c[1]), // e2_ni
			(a.m_c[2]*b.m_c[3]-a.m_c[3]*b.m_c[2]) // e3_ni
		);

}
inline line op(const pointPair &a, const ni_t &b)
{
	return line(line::coord_e1e2ni_e1e3ni_e2e3ni_e1noni_e2noni_e3noni,
			a.m_c[2], // e1_e2_ni
			a.m_c[4], // e1_e3_ni
			a.m_c[5], // e2_e3_ni
			-a.m_c[0], // e1_no_ni
			-a.m_c[1], // e2_no_ni
			-a.m_c[3] // e3_no_ni
		);

}
inline circle op(const pointPair &a, const normalizedPoint &b)
{
	return circle(circle::coord_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni,
			(a.m_c[0]*b.m_c[1]-a.m_c[1]*b.m_c[0]+a.m_c[2]), // no_e1_e2
			(a.m_c[0]*b.m_c[2]-a.m_c[3]*b.m_c[0]+a.m_c[4]), // no_e1_e3
			(a.m_c[1]*b.m_c[2]-a.m_c[3]*b.m_c[1]+a.m_c[5]), // no_e2_e3
			(a.m_c[2]*b.m_c[2]-a.m_c[4]*b.m_c[1]+a.m_c[5]*b.m_c[0]), // e1_e2_e3
			(a.m_c[0]*b.m_c[3]-a.m_c[6]*b.m_c[0]+a.m_c[7]), // no_e1_ni
			(a.m_c[1]*b.m_c[3]-a.m_c[6]*b.m_c[1]+a.m_c[8]), // no_e2_ni
			(a.m_c[2]*b.m_c[3]-a.m_c[7]*b.m_c[1]+a.m_c[8]*b.m_c[0]), // e1_e2_ni
			(a.m_c[3]*b.m_c[3]-a.m_c[6]*b.m_c[2]+a.m_c[9]), // no_e3_ni
			(a.m_c[4]*b.m_c[3]-a.m_c[7]*b.m_c[2]+a.m_c[9]*b.m_c[0]), // e1_e3_ni
			(a.m_c[5]*b.m_c[3]-a.m_c[8]*b.m_c[2]+a.m_c[9]*b.m_c[1]) // e2_e3_ni
		);

}
inline pointPair dual(const line &a)
{
	return pointPair(pointPair::coord_noe1_noe2_e1e2_noe3_e1e3_e2e3_noni_e1ni_e2ni_e3ni,
			0.0f, // no_e1
			0.0f, // no_e2
			a.m_c[5], // e1_e2
			0.0f, // no_e3
			-a.m_c[4], // e1_e3
			a.m_c[3], // e2_e3
			0.0f, // no_ni
			-a.m_c[2], // e1_ni
			a.m_c[1], // e2_ni
			-a.m_c[0] // e3_ni
		);

}
inline plane op(const circle &a, const ni_t &b)
{
	return plane(plane::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni,
			a.m_c[3], // e1_e2_e3_ni
			a.m_c[2], // no_e2_e3_ni
			a.m_c[1], // no_e1_e3_ni
			a.m_c[0] // no_e1_e2_ni
		);

}
inline pointPair lc(const pointPair &a, const plane &b)
{
	return pointPair(pointPair::coord_noe1_noe2_e1e2_noe3_e1e3_e2e3_noni_e1ni_e2ni_e3ni,
			(-a.m_c[1]*b.m_c[3]-a.m_c[3]*b.m_c[2]), // no_e1
			(a.m_c[0]*b.m_c[3]-a.m_c[3]*b.m_c[1]), // no_e2
			(-a.m_c[3]*b.m_c[0]+a.m_c[6]*b.m_c[3]), // e1_e2
			(a.m_c[0]*b.m_c[2]+a.m_c[1]*b.m_c[1]), // no_e3
			(a.m_c[1]*b.m_c[0]+a.m_c[6]*b.m_c[2]), // e1_e3
			(-a.m_c[0]*b.m_c[0]+a.m_c[6]*b.m_c[1]), // e2_e3
			(-a.m_c[2]*b.m_c[3]-a.m_c[4]*b.m_c[2]-a.m_c[5]*b.m_c[1]), // no_ni
			(-a.m_c[5]*b.m_c[0]+a.m_c[8]*b.m_c[3]+a.m_c[9]*b.m_c[2]), // e1_ni
			(a.m_c[4]*b.m_c[0]-a.m_c[7]*b.m_c[3]+a.m_c[9]*b.m_c[1]), // e2_ni
			(-a.m_c[2]*b.m_c[0]-a.m_c[7]*b.m_c[2]-a.m_c[8]*b.m_c[1]) // e3_ni
		);

}


/** structure used by custom parser */
struct c3gaParseMultivectorData {
	/** the parsed value */
	mv value;
	/** this string will contain an error message when error is true */
	char message[256];
};

/** 
Parses 'str' (output of toString_mv()) and stores result in 'val' 
Throws std::string on error.
*/
mv parse(const std::string &str);

/** 
Parses 'str' (output of toString_mv()) and stores result in 'data'. 
'strSourceName' is the name of the source of 'str' (for example, a filename).
It is used for error messages.

	Returns true when 'str' parsed correctly.
Otherwise a lexer or parser error occured and you can check 
the errors in 'data->message'.
*/
bool parseEx(struct c3gaParseMultivectorData &data, const std::string &str, const std::string &strSourceName);
} // end of namespace c3ga
#endif /* _C3GA_H_ */

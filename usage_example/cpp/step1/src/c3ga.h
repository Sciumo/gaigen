/*
This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

*/

/*! \mainpage c3ga documentation
 *
 * c3ga implementation generated by Gaigen 2.5. 
 * 
 * 
 * License: 
This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  
 * 
 * \section intro_sec Introduction
 *
 * Todo
 * 
 */
#ifndef _C3GA_H_
#define _C3GA_H_

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <string>
#include <map>
namespace c3ga {

// group: 1
#define GROUP_0 1
// group: no, e1, e2, e3, ni
#define GROUP_1 2
// group: no^e1, no^e2, e1^e2, no^e3, e1^e3, e2^e3, no^ni, e1^ni, e2^ni, e3^ni
#define GROUP_2 4
// group: no^e1^e2, no^e1^e3, no^e2^e3, e1^e2^e3, no^e1^ni, no^e2^ni, e1^e2^ni, no^e3^ni, e1^e3^ni, e2^e3^ni
#define GROUP_3 8
// group: no^e1^e2^e3, no^e1^e2^ni, no^e1^e3^ni, no^e2^e3^ni, e1^e2^e3^ni
#define GROUP_4 16
// group: no^e1^e2^e3^ni
#define GROUP_5 32
#define GRADE_0 1
#define GRADE_1 2
#define GRADE_2 4
#define GRADE_3 8
#define GRADE_4 16
#define GRADE_5 32


/// The dimension of the space:
extern const int c3ga_spaceDim;

/// Number of groups/grades of coordinates in a multivector:
extern const int c3ga_nbGroups;

/// The constants for the groups in an array:
extern const int c3ga_groups[];

/// The constants for the grades in an array:
extern const int c3ga_grades[];

/// Is the metric of the space Euclidean? (false or true)
extern const bool c3ga_metricEuclidean;

/// This array can be used to lookup the number of coordinates for a group part of a general multivector
extern const int c3ga_groupSize[6];

/// This array can be used to lookup the number of coordinates based on a group usage bitmap
extern const int c3ga_mvSize[64];

/// This array of ASCIIZ strings contains the names of the basis vectors
extern const char *c3ga_basisVectorNames[5];

/// This array of integers contains the order of basis elements in the general multivector
/// Use it to answer: 'what basis vectors are in the basis element at position [x]?
extern const int c3ga_basisElements[32][6];

/// This array of integers contains the 'sign' (even/odd permutation of canonical order) of basis elements in the general multivector
/// Use it to answer 'what is the permutation of the coordinate at index [x]'?
extern const double c3ga_basisElementSignByIndex[32];

/// This array of integers contains the 'sign' (even/odd permutation of canonical order) of basis elements in the general multivector
/// Use it to answer 'what is the permutation of the coordinate of bitmap [x]'?
extern const double c3ga_basisElementSignByBitmap[32];

/// This array of integers contains the order of basis elements in the general multivector
/// Use it to answer: 'at what index do I find basis element [x] (x = basis vector bitmap)?'
extern const int c3ga_basisElementIndexByBitmap[32];

/// This array of integers contains the indices of basis elements in the general multivector
/// Use it to answer: 'what basis element do I find at index [x]'?
extern const int c3ga_basisElementBitmapByIndex[32];

/// This array of grade of each basis elements in the general multivector
/// Use it to answer: 'what is the grade of basis element bitmap [x]'?
extern const int c3ga_basisElementGradeByBitmap[32];

/// This array of group of each basis elements in the general multivector
/// Use it to answer: 'what is the group of basis element bitmap [x]'?
extern const int c3ga_basisElementGroupByBitmap[32];

// These constants define a unique number for each specialized multivector type.
// They are used to report usage of non-optimized functions.
typedef enum {
	C3GA_NONE = -1,
	C3GA_MV = 0,
	C3GA_FLOAT = 1,
	C3GA_NORMALIZEDPOINT = 2,
	C3GA_NO_T = 3,
	C3GA_E1_T = 4,
	C3GA_E2_T = 5,
	C3GA_E3_T = 6,
	C3GA_NI_T = 7,
	C3GA_INVALID
} SMV_TYPE;

/// For each specialized multivector type, the mangled typename.
/// This is used to report usage of non-optimized functions.
extern const char *g_c3gaTypenames[];
class mv;
class normalizedPoint;
class no_t;
class e1_t;
class e2_t;
class e3_t;
class ni_t;

/**
This function alters the formatting of 'string()'.
'format' = NULL will give you back the default.
*/
void setStringFormat(const char *what, const char *format);

extern const char *string_fp; /* = \"%2.2f\" */
extern const char *string_start; /* = \"\" */
extern const char *string_end; /* = \"\" */
extern const char *string_mul; /* = \"*\" */
extern const char *string_wedge; /* = \"^\" */
extern const char *string_plus; /* = \" + \" */
extern const char *string_minus; /* = \" - \" */

const char *c_str(const mv &obj, char *str, int maxLength, const char *fp = NULL);
std::string toString(const mv &obj, const char *fp = NULL);

inline const char *c_str_f(const mv &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%f");}
inline const char *c_str_e(const mv &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%e");}
inline const char *c_str_e20(const mv &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%2.20e");}

inline std::string toString_f(const mv &obj) {return toString(obj, "%f");}
inline std::string toString_e(const mv &obj) {return toString(obj, "%e");}
inline std::string toString_e20(const mv &obj) {return toString(obj, "%2.20e");}




/// This class can hold a general multivector.
/// 
/// The coordinates are stored in type float.
/// 
/// There are 6 coordinate groups:
/// group 0:1  (grade 0).
/// group 1:no, e1, e2, e3, ni  (grade 1).
/// group 2:no^e1, no^e2, e1^e2, no^e3, e1^e3, e2^e3, no^ni, e1^ni, e2^ni, e3^ni  (grade 2).
/// group 3:no^e1^e2, no^e1^e3, no^e2^e3, e1^e2^e3, no^e1^ni, no^e2^ni, e1^e2^ni, no^e3^ni, e1^e3^ni, e2^e3^ni  (grade 3).
/// group 4:no^e1^e2^e3, no^e1^e2^ni, no^e1^e3^ni, no^e2^e3^ni, e1^e2^e3^ni  (grade 4).
/// group 5:no^e1^e2^e3^ni  (grade 5).
/// 
/// 
class mv
{

public:
	/// group/grade usage (a bitmap which specifies which groups/grades are stored in 'c', below).
	int m_gu; 
	/// the coordinates (array is allocated using realloc())
	float *m_c; 
	/// Specialized multivector type. Used to report about non-optimized function usage.
	SMV_TYPE m_t; 
public:

	/// Floating point type used by mv 
	typedef float Float;

	/// Constructs a new mv with value 0.
	inline mv()  : m_c(NULL), m_gu(0) {set();}

	/// Copy constructor.
	inline mv(const mv&A)  : m_c(NULL), m_gu(0) {set(A);}


	/// Constructs a new mv with scalar value 'scalar'.
	inline mv(float scalar)  : m_c(NULL), m_gu(0) {set(scalar);}

	/// Constructs a new mv from compressed 'coordinates'.
	/// \param gu bitwise OR of the GRADEs or GROUPs that are non-zero.
	/// \param coordinates compressed coordinates.
	inline mv(int gu, const float *coordinates)  : m_c(NULL), m_gu(0) {set(gu, coordinates);}

	/// Converts a normalizedPoint to a mv.
	inline mv(const normalizedPoint&A)  : m_c(NULL), m_gu(0) {set(A);}
	/// Converts a no_t to a mv.
	inline mv(const no_t&A)  : m_c(NULL), m_gu(0) {set(A);}
	/// Converts a e1_t to a mv.
	inline mv(const e1_t&A)  : m_c(NULL), m_gu(0) {set(A);}
	/// Converts a e2_t to a mv.
	inline mv(const e2_t&A)  : m_c(NULL), m_gu(0) {set(A);}
	/// Converts a e3_t to a mv.
	inline mv(const e3_t&A)  : m_c(NULL), m_gu(0) {set(A);}
	/// Converts a ni_t to a mv.
	inline mv(const ni_t&A)  : m_c(NULL), m_gu(0) {set(A);}

	/// Destructor (frees dynamically allocated memory).
	~mv() {if (m_c != NULL) free(m_c);}

	/// Assignment operator (mv).
	inline mv &operator=(const mv &A) {if (this != &A) {set(A);} return *this;}
	/// Assignment operator (float).
	inline mv &operator=(const float &scalar) {set(scalar); return *this;}
	
	
	/// Assignment operator (mv).
	inline mv &operator=(const normalizedPoint &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const no_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const e1_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const e2_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const e3_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const ni_t &A) {set(A); return *this;}

	/// Sets this mv to 0.
	void set();

	/// Copies the value of 'A' to this.
	void set(const mv &A);

	
	/// Sets this mv to scalar value 'scalar'.
	void set(float scalar);

	/// Sets this mv from compressed 'coordinates'.
	/// \param gu bitwise OR of the GRADEs or GROUPs that are non-zero.
	/// \param coordinates compressed coordinates.
	void set(int gu, const float *coordinates);
	
	/// Sets this mv to the value of normalizedPoint A
	void set(const normalizedPoint &A);
	/// Sets this mv to the value of no_t A
	void set(const no_t &A);
	/// Sets this mv to the value of e1_t A
	void set(const e1_t &A);
	/// Sets this mv to the value of e2_t A
	void set(const e2_t &A);
	/// Sets this mv to the value of e3_t A
	void set(const e3_t &A);
	/// Sets this mv to the value of ni_t A
	void set(const ni_t &A);
	/// Returns the scalar coordinate of this mv.
	inline float get_scalar() const {
		return (m_gu & 1) ? m_c[c3ga_mvSize[m_gu & 0] + 0] : 0.0f;
	}
	/// Returns the no coordinate of this mv.
	inline float get_no() const {
		return (m_gu & 2) ? m_c[c3ga_mvSize[m_gu & 1] + 0] : 0.0f;
	}
	/// Returns the e1 coordinate of this mv.
	inline float get_e1() const {
		return (m_gu & 2) ? m_c[c3ga_mvSize[m_gu & 1] + 1] : 0.0f;
	}
	/// Returns the e2 coordinate of this mv.
	inline float get_e2() const {
		return (m_gu & 2) ? m_c[c3ga_mvSize[m_gu & 1] + 2] : 0.0f;
	}
	/// Returns the e3 coordinate of this mv.
	inline float get_e3() const {
		return (m_gu & 2) ? m_c[c3ga_mvSize[m_gu & 1] + 3] : 0.0f;
	}
	/// Returns the ni coordinate of this mv.
	inline float get_ni() const {
		return (m_gu & 2) ? m_c[c3ga_mvSize[m_gu & 1] + 4] : 0.0f;
	}
	/// Returns the no_e1 coordinate of this mv.
	inline float get_no_e1() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 0] : 0.0f;
	}
	/// Returns the no_e2 coordinate of this mv.
	inline float get_no_e2() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 1] : 0.0f;
	}
	/// Returns the e1_e2 coordinate of this mv.
	inline float get_e1_e2() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 2] : 0.0f;
	}
	/// Returns the no_e3 coordinate of this mv.
	inline float get_no_e3() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 3] : 0.0f;
	}
	/// Returns the e1_e3 coordinate of this mv.
	inline float get_e1_e3() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 4] : 0.0f;
	}
	/// Returns the e2_e3 coordinate of this mv.
	inline float get_e2_e3() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 5] : 0.0f;
	}
	/// Returns the no_ni coordinate of this mv.
	inline float get_no_ni() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 6] : 0.0f;
	}
	/// Returns the e1_ni coordinate of this mv.
	inline float get_e1_ni() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 7] : 0.0f;
	}
	/// Returns the e2_ni coordinate of this mv.
	inline float get_e2_ni() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 8] : 0.0f;
	}
	/// Returns the e3_ni coordinate of this mv.
	inline float get_e3_ni() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 9] : 0.0f;
	}
	/// Returns the no_e1_e2 coordinate of this mv.
	inline float get_no_e1_e2() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 0] : 0.0f;
	}
	/// Returns the no_e1_e3 coordinate of this mv.
	inline float get_no_e1_e3() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 1] : 0.0f;
	}
	/// Returns the no_e2_e3 coordinate of this mv.
	inline float get_no_e2_e3() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 2] : 0.0f;
	}
	/// Returns the e1_e2_e3 coordinate of this mv.
	inline float get_e1_e2_e3() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 3] : 0.0f;
	}
	/// Returns the no_e1_ni coordinate of this mv.
	inline float get_no_e1_ni() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 4] : 0.0f;
	}
	/// Returns the no_e2_ni coordinate of this mv.
	inline float get_no_e2_ni() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 5] : 0.0f;
	}
	/// Returns the e1_e2_ni coordinate of this mv.
	inline float get_e1_e2_ni() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 6] : 0.0f;
	}
	/// Returns the no_e3_ni coordinate of this mv.
	inline float get_no_e3_ni() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 7] : 0.0f;
	}
	/// Returns the e1_e3_ni coordinate of this mv.
	inline float get_e1_e3_ni() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 8] : 0.0f;
	}
	/// Returns the e2_e3_ni coordinate of this mv.
	inline float get_e2_e3_ni() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 9] : 0.0f;
	}
	/// Returns the no_e1_e2_e3 coordinate of this mv.
	inline float get_no_e1_e2_e3() const {
		return (m_gu & 16) ? m_c[c3ga_mvSize[m_gu & 15] + 0] : 0.0f;
	}
	/// Returns the no_e1_e2_ni coordinate of this mv.
	inline float get_no_e1_e2_ni() const {
		return (m_gu & 16) ? m_c[c3ga_mvSize[m_gu & 15] + 1] : 0.0f;
	}
	/// Returns the no_e1_e3_ni coordinate of this mv.
	inline float get_no_e1_e3_ni() const {
		return (m_gu & 16) ? m_c[c3ga_mvSize[m_gu & 15] + 2] : 0.0f;
	}
	/// Returns the no_e2_e3_ni coordinate of this mv.
	inline float get_no_e2_e3_ni() const {
		return (m_gu & 16) ? m_c[c3ga_mvSize[m_gu & 15] + 3] : 0.0f;
	}
	/// Returns the e1_e2_e3_ni coordinate of this mv.
	inline float get_e1_e2_e3_ni() const {
		return (m_gu & 16) ? m_c[c3ga_mvSize[m_gu & 15] + 4] : 0.0f;
	}
	/// Returns the no_e1_e2_e3_ni coordinate of this mv.
	inline float get_no_e1_e2_e3_ni() const {
		return (m_gu & 32) ? m_c[c3ga_mvSize[m_gu & 31] + 0] : 0.0f;
	}
	/// Returns array of compressed coordinates.
	inline const float *getC() const { return m_c;}
	/// Sets the scalar coordinate of this mv.
	inline void set_scalar(float val)  {
		reserveGroup_0();
		m_c[c3ga_mvSize[m_gu & 0] + 0] = val;
	}
	/// Sets the no coordinate of this mv.
	inline void set_no(float val)  {
		reserveGroup_1();
		m_c[c3ga_mvSize[m_gu & 1] + 0] = val;
	}
	/// Sets the e1 coordinate of this mv.
	inline void set_e1(float val)  {
		reserveGroup_1();
		m_c[c3ga_mvSize[m_gu & 1] + 1] = val;
	}
	/// Sets the e2 coordinate of this mv.
	inline void set_e2(float val)  {
		reserveGroup_1();
		m_c[c3ga_mvSize[m_gu & 1] + 2] = val;
	}
	/// Sets the e3 coordinate of this mv.
	inline void set_e3(float val)  {
		reserveGroup_1();
		m_c[c3ga_mvSize[m_gu & 1] + 3] = val;
	}
	/// Sets the ni coordinate of this mv.
	inline void set_ni(float val)  {
		reserveGroup_1();
		m_c[c3ga_mvSize[m_gu & 1] + 4] = val;
	}
	/// Sets the no_e1 coordinate of this mv.
	inline void set_no_e1(float val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 0] = val;
	}
	/// Sets the no_e2 coordinate of this mv.
	inline void set_no_e2(float val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 1] = val;
	}
	/// Sets the e1_e2 coordinate of this mv.
	inline void set_e1_e2(float val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 2] = val;
	}
	/// Sets the no_e3 coordinate of this mv.
	inline void set_no_e3(float val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 3] = val;
	}
	/// Sets the e1_e3 coordinate of this mv.
	inline void set_e1_e3(float val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 4] = val;
	}
	/// Sets the e2_e3 coordinate of this mv.
	inline void set_e2_e3(float val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 5] = val;
	}
	/// Sets the no_ni coordinate of this mv.
	inline void set_no_ni(float val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 6] = val;
	}
	/// Sets the e1_ni coordinate of this mv.
	inline void set_e1_ni(float val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 7] = val;
	}
	/// Sets the e2_ni coordinate of this mv.
	inline void set_e2_ni(float val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 8] = val;
	}
	/// Sets the e3_ni coordinate of this mv.
	inline void set_e3_ni(float val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 9] = val;
	}
	/// Sets the no_e1_e2 coordinate of this mv.
	inline void set_no_e1_e2(float val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 0] = val;
	}
	/// Sets the no_e1_e3 coordinate of this mv.
	inline void set_no_e1_e3(float val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 1] = val;
	}
	/// Sets the no_e2_e3 coordinate of this mv.
	inline void set_no_e2_e3(float val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 2] = val;
	}
	/// Sets the e1_e2_e3 coordinate of this mv.
	inline void set_e1_e2_e3(float val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 3] = val;
	}
	/// Sets the no_e1_ni coordinate of this mv.
	inline void set_no_e1_ni(float val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 4] = val;
	}
	/// Sets the no_e2_ni coordinate of this mv.
	inline void set_no_e2_ni(float val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 5] = val;
	}
	/// Sets the e1_e2_ni coordinate of this mv.
	inline void set_e1_e2_ni(float val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 6] = val;
	}
	/// Sets the no_e3_ni coordinate of this mv.
	inline void set_no_e3_ni(float val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 7] = val;
	}
	/// Sets the e1_e3_ni coordinate of this mv.
	inline void set_e1_e3_ni(float val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 8] = val;
	}
	/// Sets the e2_e3_ni coordinate of this mv.
	inline void set_e2_e3_ni(float val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 9] = val;
	}
	/// Sets the no_e1_e2_e3 coordinate of this mv.
	inline void set_no_e1_e2_e3(float val)  {
		reserveGroup_4();
		m_c[c3ga_mvSize[m_gu & 15] + 0] = val;
	}
	/// Sets the no_e1_e2_ni coordinate of this mv.
	inline void set_no_e1_e2_ni(float val)  {
		reserveGroup_4();
		m_c[c3ga_mvSize[m_gu & 15] + 1] = val;
	}
	/// Sets the no_e1_e3_ni coordinate of this mv.
	inline void set_no_e1_e3_ni(float val)  {
		reserveGroup_4();
		m_c[c3ga_mvSize[m_gu & 15] + 2] = val;
	}
	/// Sets the no_e2_e3_ni coordinate of this mv.
	inline void set_no_e2_e3_ni(float val)  {
		reserveGroup_4();
		m_c[c3ga_mvSize[m_gu & 15] + 3] = val;
	}
	/// Sets the e1_e2_e3_ni coordinate of this mv.
	inline void set_e1_e2_e3_ni(float val)  {
		reserveGroup_4();
		m_c[c3ga_mvSize[m_gu & 15] + 4] = val;
	}
	/// Sets the no_e1_e2_e3_ni coordinate of this mv.
	inline void set_no_e1_e2_e3_ni(float val)  {
		reserveGroup_5();
		m_c[c3ga_mvSize[m_gu & 31] + 0] = val;
	}

	/// Compresses this mv by removing groups/grades with coordinates are smaller than epsilon.
	void compress(float epsilon = 0.0f);
	/// Sets each entry in 'ptrs' to a pointer to the coordinates for the respective grade / group.
	/// \param ptrs Array of pointers to grades/groups. The pointers are set by this function.
	/// \param nulls When true, pointers are set to NULL for empty grades/groups; otherwise a pointer to an array filled with zeros is used.
	void expand(const float *ptrs[6], bool nulls = true) const;

	/// returns the absolute largest coordinate.
	float largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap (in 'bm').
	float largestBasisBlade(unsigned int &bm) const;
	/// returns grade/group.
	inline int gu() const {return m_gu;}

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}
public:
	inline float const *nullFloats() const {
		static float *nf = NULL;
		return (nf == NULL) ? (nf = new float[32]) : nf;
	}

public:
	/// Set m_gu, reallocates m_c to the size required by gu
	inline void setGroupUsage(int gu) {
		if (m_gu == gu) return;
		m_gu = gu;
		int nbCoords = c3ga_mvSize[m_gu];
		if (nbCoords > 0)
			m_c = (float*)realloc(m_c, nbCoords * sizeof(float));
	}

	/**
	Allocates memory for coordinate GROUP_0.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_0() {
		if ((m_gu & 1) == 0) {
			const int groupUsageBelow = m_gu & 0;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 1;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 1;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			float *dst = m_c + c3ga_mvSize[newGroupUsageBelowNextGroup];
			float *src = m_c + c3ga_mvSize[groupUsageBelow];
			for (int i = c3ga_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			float *ptr = m_c + c3ga_mvSize[groupUsageBelow];
			ptr[0] = 0.0f;
		}
	}
	/**
	Allocates memory for coordinate GROUP_1.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_1() {
		if ((m_gu & 2) == 0) {
			const int groupUsageBelow = m_gu & 1;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 2;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 3;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			float *dst = m_c + c3ga_mvSize[newGroupUsageBelowNextGroup];
			float *src = m_c + c3ga_mvSize[groupUsageBelow];
			for (int i = c3ga_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			float *ptr = m_c + c3ga_mvSize[groupUsageBelow];
			ptr[0] = ptr[1] = ptr[2] = ptr[3] = ptr[4] = 0.0f;
		}
	}
	/**
	Allocates memory for coordinate GROUP_2.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_2() {
		if ((m_gu & 4) == 0) {
			const int groupUsageBelow = m_gu & 3;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 4;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 7;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			float *dst = m_c + c3ga_mvSize[newGroupUsageBelowNextGroup];
			float *src = m_c + c3ga_mvSize[groupUsageBelow];
			for (int i = c3ga_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			float *ptr = m_c + c3ga_mvSize[groupUsageBelow];
			ptr[0] = ptr[1] = ptr[2] = ptr[3] = ptr[4] = ptr[5] = ptr[6] = ptr[7] = ptr[8] = ptr[9] = 0.0f;
		}
	}
	/**
	Allocates memory for coordinate GROUP_3.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_3() {
		if ((m_gu & 8) == 0) {
			const int groupUsageBelow = m_gu & 7;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 8;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 15;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			float *dst = m_c + c3ga_mvSize[newGroupUsageBelowNextGroup];
			float *src = m_c + c3ga_mvSize[groupUsageBelow];
			for (int i = c3ga_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			float *ptr = m_c + c3ga_mvSize[groupUsageBelow];
			ptr[0] = ptr[1] = ptr[2] = ptr[3] = ptr[4] = ptr[5] = ptr[6] = ptr[7] = ptr[8] = ptr[9] = 0.0f;
		}
	}
	/**
	Allocates memory for coordinate GROUP_4.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_4() {
		if ((m_gu & 16) == 0) {
			const int groupUsageBelow = m_gu & 15;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 16;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 31;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			float *dst = m_c + c3ga_mvSize[newGroupUsageBelowNextGroup];
			float *src = m_c + c3ga_mvSize[groupUsageBelow];
			for (int i = c3ga_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			float *ptr = m_c + c3ga_mvSize[groupUsageBelow];
			ptr[0] = ptr[1] = ptr[2] = ptr[3] = ptr[4] = 0.0f;
		}
	}
	/**
	Allocates memory for coordinate GROUP_5.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_5() {
		if ((m_gu & 32) == 0) {
			const int groupUsageBelow = m_gu & 31;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 32;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 63;

			setGroupUsage(newGroupUsage);


			// set coordinates of new group to 0
			float *ptr = m_c + c3ga_mvSize[groupUsageBelow];
			ptr[0] = 0.0f;
		}
	}
}; // end of class mv

/// This class can hold a specialized multivector of type normalizedPoint.
/// 
/// The coordinates are stored in type float.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1  (array index: E1 = 0)
///   - coordinate e2  (array index: E2 = 1)
///   - coordinate e3  (array index: E3 = 2)
///   - coordinate ni  (array index: NI = 3)
/// 
/// The constant non-zero coordinates are:
///   - no = 1
/// 
/// 
class normalizedPoint
{
public:
	/// The coordinates (stored in an array).
	float m_c[4]; // e1, e2, e3, ni
public:

	/// Floating point type used by normalizedPoint 
	typedef float Float;
	/// Array indices of normalizedPoint coordinates.
	typedef enum {
		/// index of coordinate for e1 in normalizedPoint
		E1 = 0, 
		/// index of coordinate for e2 in normalizedPoint
		E2 = 1, 
		/// index of coordinate for e3 in normalizedPoint
		E3 = 2, 
		/// index of coordinate for ni in normalizedPoint
		NI = 3, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1_e2_e3_ni
	} CoordinateOrder;

	/// Constructs a new normalizedPoint with variable coordinates set to 0.
	inline normalizedPoint() {set();}

	/// Copy constructor.
	inline normalizedPoint(const normalizedPoint &A) {set(A);}



	/// Constructs a new normalizedPoint from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline normalizedPoint(const mv &A, int filler) {set(A);}

	/// Constructs a new normalizedPoint. Coordinate values come from 'A'.
	inline normalizedPoint(const CoordinateOrder co, const float A[4]) {set(co, A);}
	
	/// Constructs a new normalizedPoint with each coordinate specified.
	inline normalizedPoint(const CoordinateOrder co,  float e1, float e2, float e3, float ni) {
		set(co, e1, e2, e3, ni);
	}

	/// Assignment operator (normalizedPoint).
	inline normalizedPoint &operator=(const normalizedPoint &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline normalizedPoint &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const normalizedPoint &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const float A[4]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  float e1, float e2, float e3, float ni);

	/// returns the absolute largest coordinate.
	float largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	float largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1 coordinate.
	inline float get_e1() const { return m_c[0];}
	/// Sets the e1 coordinate.
	inline void set_e1(float e1) { m_c[0] = e1;}
	/// Returns the e2 coordinate.
	inline float get_e2() const { return m_c[1];}
	/// Sets the e2 coordinate.
	inline void set_e2(float e2) { m_c[1] = e2;}
	/// Returns the e3 coordinate.
	inline float get_e3() const { return m_c[2];}
	/// Sets the e3 coordinate.
	inline void set_e3(float e3) { m_c[2] = e3;}
	/// Returns the ni coordinate.
	inline float get_ni() const { return m_c[3];}
	/// Sets the ni coordinate.
	inline void set_ni(float ni) { m_c[3] = ni;}
	/// Returns the no coordinate.
	inline float get_no() const { return 1.0f;}
	/// Returns the scalar coordinate (which is always 0).
	inline float get_scalar() const { return 0.0f;}
	/// Returns array of coordinates.
	inline const float *getC(CoordinateOrder) const { return m_c;}
}; // end of class normalizedPoint

/// This class can hold a specialized multivector of type no_t.
/// 
/// The coordinates are stored in type float.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - no = 1
/// 
/// 
class no_t
{
public:
public:

	/// Floating point type used by no_t 
	typedef float Float;
	/// Array indices of no_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new no_t with variable coordinates set to 0.
	inline no_t() {set();}

	/// Copy constructor.
	inline no_t(const no_t &A) {set(A);}



	/// Constructs a new no_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline no_t(const mv &A, int filler) {set(A);}


	/// Assignment operator (no_t).
	inline no_t &operator=(const no_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline no_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const no_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	float largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	float largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the no coordinate.
	inline float get_no() const { return 1.0f;}
	/// Returns the scalar coordinate (which is always 0).
	inline float get_scalar() const { return 0.0f;}
}; // end of class no_t

/// This class can hold a specialized multivector of type e1_t.
/// 
/// The coordinates are stored in type float.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - e1 = 1
/// 
/// 
class e1_t
{
public:
public:

	/// Floating point type used by e1_t 
	typedef float Float;
	/// Array indices of e1_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new e1_t with variable coordinates set to 0.
	inline e1_t() {set();}

	/// Copy constructor.
	inline e1_t(const e1_t &A) {set(A);}



	/// Constructs a new e1_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline e1_t(const mv &A, int filler) {set(A);}


	/// Assignment operator (e1_t).
	inline e1_t &operator=(const e1_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline e1_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const e1_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	float largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	float largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1 coordinate.
	inline float get_e1() const { return 1.0f;}
	/// Returns the scalar coordinate (which is always 0).
	inline float get_scalar() const { return 0.0f;}
}; // end of class e1_t

/// This class can hold a specialized multivector of type e2_t.
/// 
/// The coordinates are stored in type float.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - e2 = 1
/// 
/// 
class e2_t
{
public:
public:

	/// Floating point type used by e2_t 
	typedef float Float;
	/// Array indices of e2_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new e2_t with variable coordinates set to 0.
	inline e2_t() {set();}

	/// Copy constructor.
	inline e2_t(const e2_t &A) {set(A);}



	/// Constructs a new e2_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline e2_t(const mv &A, int filler) {set(A);}


	/// Assignment operator (e2_t).
	inline e2_t &operator=(const e2_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline e2_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const e2_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	float largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	float largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e2 coordinate.
	inline float get_e2() const { return 1.0f;}
	/// Returns the scalar coordinate (which is always 0).
	inline float get_scalar() const { return 0.0f;}
}; // end of class e2_t

/// This class can hold a specialized multivector of type e3_t.
/// 
/// The coordinates are stored in type float.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - e3 = 1
/// 
/// 
class e3_t
{
public:
public:

	/// Floating point type used by e3_t 
	typedef float Float;
	/// Array indices of e3_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new e3_t with variable coordinates set to 0.
	inline e3_t() {set();}

	/// Copy constructor.
	inline e3_t(const e3_t &A) {set(A);}



	/// Constructs a new e3_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline e3_t(const mv &A, int filler) {set(A);}


	/// Assignment operator (e3_t).
	inline e3_t &operator=(const e3_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline e3_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const e3_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	float largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	float largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e3 coordinate.
	inline float get_e3() const { return 1.0f;}
	/// Returns the scalar coordinate (which is always 0).
	inline float get_scalar() const { return 0.0f;}
}; // end of class e3_t

/// This class can hold a specialized multivector of type ni_t.
/// 
/// The coordinates are stored in type float.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - ni = 1
/// 
/// 
class ni_t
{
public:
public:

	/// Floating point type used by ni_t 
	typedef float Float;
	/// Array indices of ni_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new ni_t with variable coordinates set to 0.
	inline ni_t() {set();}

	/// Copy constructor.
	inline ni_t(const ni_t &A) {set(A);}



	/// Constructs a new ni_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline ni_t(const mv &A, int filler) {set(A);}


	/// Assignment operator (ni_t).
	inline ni_t &operator=(const ni_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline ni_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const ni_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	float largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	float largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the ni coordinate.
	inline float get_ni() const { return 1.0f;}
	/// Returns the scalar coordinate (which is always 0).
	inline float get_scalar() const { return 0.0f;}
}; // end of class ni_t
extern no_t no;
extern e1_t e1;
extern e2_t e2;
extern e3_t e3;
extern ni_t ni;


/**
This class is used to report usage of converted specialized multivectors.

The class is designed to be pretty safe with multi-threading without locking.
In the worst case, some memory leaks occur and some counts are missed. 
The amount of memory leaked is bounded (does not grow beyond a certain
point). Since the report-usage functionality is for
development/debugging only, this is not considered non-harmful.
*/
class ReportUsage {
public:
	inline ReportUsage(std::string str, unsigned int initialCount = 1) : 
		m_hash(computeHash(str)),
		m_str(str), 
		m_count(initialCount), 
		m_left(NULL),
		m_right(NULL)
	{
	}

	static void mergeReport(ReportUsage *RU);

	/// prints out all reports, sorted by m_str
	static void printReport(FILE *F = stdout, bool includeCount = true);

protected:
	/// Turns a string into a hashcode which is used to efficiently search the tree
	static inline int computeHash(const std::string &str) {
		unsigned int hash = 0x83BA056E; // just a number
		int shift = 0;
		const int SHIFT_INC = 7;
		for (int i = 0; i < (int)str.length(); i++) {
			hash ^= (unsigned int)(str[i] << shift);
			shift += SHIFT_INC;
			if (shift > (sizeof(unsigned int) - SHIFT_INC))
				shift &= SHIFT_INC;
		}
		return hash;
	}

	/// return true if m_str is equal (checks the hash first)
	inline bool equals(const ReportUsage *RU) const {
		if (m_hash != RU->m_hash) return false;
		else return (m_str == RU->m_str);
	}

	/// Returns -1 for this < RU, 0 for equals, +1 for this > RU
	/// First compares the hash, then the string.
	inline int compare(const ReportUsage *RU) const {
		if (equals(RU)) return 0;
		else if (m_hash == RU->m_hash) {
			return m_str.compare(RU->m_str);
		}
		else return (m_hash < RU->m_hash) ? -1 : 1;
	}

	/// Merges 'RU' with the reports
	inline void mergeReportInternal(ReportUsage *RU) {
		if (equals(RU)) { // just increment the count?
			if ((m_count + RU->m_count) > m_count) // prevent overflow of unsigned int
				m_count += RU->m_count;
			delete RU;
		}
		else { // either recurse or set m_left or m_right
			int comp = compare(RU);
			if (comp < 0) {
				if (m_left == NULL) m_left = RU;
				else m_left->mergeReportInternal(RU);
			}
			else {
				if (m_right == NULL) m_right = RU;
				else m_right->mergeReportInternal(RU);
			}
		}
	}

	inline void getMap(std::map<std::string, const ReportUsage*> &M) const {
		M[m_str] = this;
		if (m_left) m_left->getMap(M);
		if (m_right) m_right->getMap(M);
	}

	static ReportUsage *s_reportTree;

	/// hashcode of m_str.
	unsigned int m_hash;
	/// string describing the report.
	std::string m_str;
	/// how many times this report hash been filed.
	unsigned int m_count;

	/// left branch of tree
	ReportUsage *m_left;
	/// right branch of tree
	ReportUsage *m_right;
}; // end of class ReportUsage

/** Sets 1 float to zero */
void zero_1(float *dst);
/** Copies 1 float from 'src' to 'dst' */
void copy_1(float *dst, const float *src);
/** Sets 2 floats to zero */
void zero_2(float *dst);
/** Copies 2 floats from 'src' to 'dst' */
void copy_2(float *dst, const float *src);
/** Sets 3 floats to zero */
void zero_3(float *dst);
/** Copies 3 floats from 'src' to 'dst' */
void copy_3(float *dst, const float *src);
/** Sets 4 floats to zero */
void zero_4(float *dst);
/** Copies 4 floats from 'src' to 'dst' */
void copy_4(float *dst, const float *src);
/** Sets 5 floats to zero */
void zero_5(float *dst);
/** Copies 5 floats from 'src' to 'dst' */
void copy_5(float *dst, const float *src);
/** Sets 6 floats to zero */
void zero_6(float *dst);
/** Copies 6 floats from 'src' to 'dst' */
void copy_6(float *dst, const float *src);
/** Sets 7 floats to zero */
void zero_7(float *dst);
/** Copies 7 floats from 'src' to 'dst' */
void copy_7(float *dst, const float *src);
/** Sets 8 floats to zero */
void zero_8(float *dst);
/** Copies 8 floats from 'src' to 'dst' */
void copy_8(float *dst, const float *src);
/** Sets 9 floats to zero */
void zero_9(float *dst);
/** Copies 9 floats from 'src' to 'dst' */
void copy_9(float *dst, const float *src);
/** Sets 10 floats to zero */
void zero_10(float *dst);
/** Copies 10 floats from 'src' to 'dst' */
void copy_10(float *dst, const float *src);
/** Sets 11 floats to zero */
void zero_11(float *dst);
/** Copies 11 floats from 'src' to 'dst' */
void copy_11(float *dst, const float *src);
/** Sets 12 floats to zero */
void zero_12(float *dst);
/** Copies 12 floats from 'src' to 'dst' */
void copy_12(float *dst, const float *src);
/** Sets 13 floats to zero */
void zero_13(float *dst);
/** Copies 13 floats from 'src' to 'dst' */
void copy_13(float *dst, const float *src);
/** Sets 14 floats to zero */
void zero_14(float *dst);
/** Copies 14 floats from 'src' to 'dst' */
void copy_14(float *dst, const float *src);
/** Sets 15 floats to zero */
void zero_15(float *dst);
/** Copies 15 floats from 'src' to 'dst' */
void copy_15(float *dst, const float *src);
/** Sets 16 floats to zero */
void zero_16(float *dst);
/** Copies 16 floats from 'src' to 'dst' */
void copy_16(float *dst, const float *src);
/** Sets N floats to zero */
void zero_N(float *dst, int N);
/** Copies N floats from 'src' to 'dst' */
void copy_N(float *dst, const float *src, int N);
// decl SB:

/// Returns scalar part of  mv
float _float(const mv &x);
/// Returns scalar part of  mv
inline float _Float(const mv &x) {return _float(x); };

/// Compresses coordinates 'c' into a new multivector.
/// \param c the coordinates (may already be partially compressed, see argument 'gu').
/// \param epsilon value with a abs magnitude < epsilon are considered to be 0.
/// \param gu optionally specifies which groups/grades are present in 'c'.
mv mv_compress(const float *c, float epsilon = 0.0f, int gu = 63);
/// Compresses an array of coordinates/basis blade bitmaps into a new multivector.
mv mv_compress(int nbBlades, const unsigned int *bitmaps, const float *coords);


/// Returns scalar part of  normalizedPoint
float _float(const normalizedPoint &x);
/// Returns scalar part of  normalizedPoint
inline float _Float(const normalizedPoint &x) {return _float(x); };
/// Returns scalar part of  no_t
float _float(const no_t &x);
/// Returns scalar part of  no_t
inline float _Float(const no_t &x) {return _float(x); };
/// Returns scalar part of  e1_t
float _float(const e1_t &x);
/// Returns scalar part of  e1_t
inline float _Float(const e1_t &x) {return _float(x); };
/// Returns scalar part of  e2_t
float _float(const e2_t &x);
/// Returns scalar part of  e2_t
inline float _Float(const e2_t &x) {return _float(x); };
/// Returns scalar part of  e3_t
float _float(const e3_t &x);
/// Returns scalar part of  e3_t
inline float _Float(const e3_t &x) {return _float(x); };
/// Returns scalar part of  ni_t
float _float(const ni_t &x);
/// Returns scalar part of  ni_t
inline float _Float(const ni_t &x) {return _float(x); };
/// Returns mv + mv.
mv add(const mv &a, const mv &b);
/// Returns mv - mv.
mv subtract(const mv &a, const mv &b);
/// Returns conformal point.
normalizedPoint cgaPoint(const float a, const float b, const float c);
/// Returns grade groupBitmap of  mv.
mv extractGrade(const mv &a, const int groupBitmap);
/// Returns negation of mv.
mv negate(const mv &a);
/// Returns reverse of mv.
mv reverse(const mv &a);
/// Returns grade involution of mv.
mv gradeInvolution(const mv &a);
/// Returns Clifford conjugate of mv.
mv cliffordConjugate(const mv &a);
/// Returns geometric product of mv and mv.
mv gp(const mv &a, const mv &b);
/// Returns outer product of mv and mv.
mv op(const mv &a, const mv &b);
/// Returns scalar product of mv and mv.
float sp(const mv &a, const mv &b);
/// Returns Modified Hestenes inner product of mv and mv.
mv mhip(const mv &a, const mv &b);
/// Returns left contraction of mv and mv.
mv lc(const mv &a, const mv &b);
/// Returns norm of mv using default metric.
float norm(const mv &a);
/// internal conversion function
float norm_returns_scalar(const mv &a);
/// Returns unit of mv using default metric.
mv unit(const mv &a);
/// Returns a * b * inverse(a) using default metric.
mv applyVersor(const mv &a, const mv &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
mv applyUnitVersor(const mv &a, const mv &b);
/// Returns versor inverse of a using default metric.
mv versorInverse(const mv &a);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const mv &a, const mv &b, const float c);
/// Returns true if all coordinates of a are abs <= b
bool zero(const mv &a, const float b);
/// Returns dual of mv using default metric.
mv dual(const mv &a);
/// Returns undual of mv using default metric.
mv undual(const mv &a);

/** Computes exp of mv.
 */
mv exp(const mv &x, int order = 12);
/// Returns geometric product of mv and float.
mv gp(const mv &a, const float b);
/// Returns norm2 of mv using default metric.
float norm2(const mv &a);
/// internal conversion function
float norm2_returns_scalar(const mv &a);
/// Returns float b * mv a + float c.
mv sas(const mv &a, const float b, const float c);
/// returns add(a, b)
inline mv operator+(const mv &a, const mv &b) {
	return add(a, b);
}
/// returns (a = add(a, b))
inline mv &operator+=(mv &a, const mv &b) {
	return (a = add(a, b));
}
/// returns subtract(a, b)
inline mv operator-(const mv &a, const mv &b) {
	return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline mv &operator-=(mv &a, const mv &b) {
	return (a = subtract(a, b));
}
/// returns negate(a)
inline mv operator-(const mv &a) {
	return negate(a);
}
/// returns reverse(a)
inline mv operator~(const mv &a) {
	return reverse(a);
}
/// returns gp(a, b)
inline mv operator*(const mv &a, const mv &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline mv &operator*=(mv &a, const mv &b) {
	return (a = gp(a, b));
}
/// returns op(a, b)
inline mv operator^(const mv &a, const mv &b) {
	return op(a, b);
}
/// returns (a = op(a, b))
inline mv &operator^=(mv &a, const mv &b) {
	return (a = op(a, b));
}
/// returns sp(a, b)
inline float operator%(const mv &a, const mv &b) {
	return sp(a, b);
}
/// returns lc(a, b)
inline mv operator<<(const mv &a, const mv &b) {
	return lc(a, b);
}
/// returns (a = lc(a, b))
inline mv &operator<<=(mv &a, const mv &b) {
	return (a = lc(a, b));
}
/// returns versorInverse(a)
inline mv operator!(const mv &a) {
	return versorInverse(a);
}
/// returns dual(a)
inline mv operator*(const mv &a) {
	return dual(a);
}
/// returns gp(a, b)
inline mv operator*(const mv &a, const float &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline mv &operator*=(mv &a, const float &b) {
	return (a = gp(a, b));
}

inline void zero_1(float *dst) {
	dst[0]=0.0f;
}
inline void copy_1(float *dst, const float *src) {
	dst[0] = src[0];
}
inline void zero_2(float *dst) {
	dst[0]=dst[1]=0.0f;
}
inline void copy_2(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
}
inline void zero_3(float *dst) {
	dst[0]=dst[1]=dst[2]=0.0f;
}
inline void copy_3(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
}
inline void zero_4(float *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=0.0f;
}
inline void copy_4(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
}
inline void zero_5(float *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=0.0f;
}
inline void copy_5(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
}
inline void zero_6(float *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=0.0f;
}
inline void copy_6(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
}
inline void zero_7(float *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=0.0f;
}
inline void copy_7(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
}
inline void zero_8(float *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=0.0f;
}
inline void copy_8(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
}
inline void zero_9(float *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=0.0f;
}
inline void copy_9(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
}
inline void zero_10(float *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=0.0f;
}
inline void copy_10(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
}
inline void zero_11(float *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=0.0f;
}
inline void copy_11(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
}
inline void zero_12(float *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=0.0f;
}
inline void copy_12(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
}
inline void zero_13(float *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=0.0f;
}
inline void copy_13(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
}
inline void zero_14(float *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=dst[13]=0.0f;
}
inline void copy_14(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
	dst[13] = src[13];
}
inline void zero_15(float *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=dst[13]=dst[14]=0.0f;
}
inline void copy_15(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
	dst[13] = src[13];
	dst[14] = src[14];
}
inline void zero_16(float *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=dst[13]=dst[14]=dst[15]=0.0f;
}
inline void copy_16(float *dst, const float *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
	dst[13] = src[13];
	dst[14] = src[14];
	dst[15] = src[15];
}
/** Sets N floats to zero */
inline void zero_N(float *dst, int N) {
	int i = 0;
	while ((N-i) > 16) {
		zero_16(dst + i);
		i += 16;
	}
	for (; i < N; i++)
		dst[i] = 0.0f;
}
/** Copies N floats from 'src' to 'dst' */
inline void copy_N(float *dst, const float *src, int N) {
	int i = 0;
	while ((N-i) > 16) {
		copy_16(dst + i, src + i);
		i += 16;
	}
	for (; i < N; i++)
		dst[i] = src[i];
}
// inline def SB:
inline void mv::set() {
	setGroupUsage(0);
	m_t = C3GA_MV;
}
inline void mv::set(float val) {
	setGroupUsage(1);
	m_c[0] = val;
	m_t = C3GA_FLOAT;
}
inline void mv::set(int gu, const float *arr) {
	setGroupUsage(gu);
	c3ga::copy_N(m_c, arr, c3ga_mvSize[gu]);

	m_t = C3GA_MV;
}
inline void mv::set(const mv &src) {
	setGroupUsage(src.gu());
	const float*srcC = src.getC();
	c3ga::copy_N(m_c, srcC, c3ga_mvSize[src.gu()]);

	m_t = src.m_t;
}
inline void normalizedPoint::set(const mv &src) {
	const float *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		m_c[0] = ptr[1];
		m_c[1] = ptr[2];
		m_c[2] = ptr[3];
		m_c[3] = ptr[4];
	}
	else {
		m_c[0] = 0.0f;
		m_c[1] = 0.0f;
		m_c[2] = 0.0f;
		m_c[3] = 0.0f;
	}
}
inline void no_t::set(const mv &src) {
	const float *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void e1_t::set(const mv &src) {
	const float *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void e2_t::set(const mv &src) {
	const float *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void e3_t::set(const mv &src) {
	const float *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void ni_t::set(const mv &src) {
	const float *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void mv::set(const normalizedPoint &src) {
	setGroupUsage(2);
	float *ptr = m_c;
	ptr[0] = 1.0f;
	ptr[1] = src.m_c[0];
	ptr[2] = src.m_c[1];
	ptr[3] = src.m_c[2];
	ptr[4] = src.m_c[3];
	m_t = C3GA_NORMALIZEDPOINT;
}
inline void mv::set(const no_t &src) {
	setGroupUsage(2);
	float *ptr = m_c;
	ptr[0] = 1.0f;
	ptr[1] = ptr[2] = ptr[3] = ptr[4] = 0.0f;
	m_t = C3GA_NO_T;
}
inline void mv::set(const e1_t &src) {
	setGroupUsage(2);
	float *ptr = m_c;
	ptr[0] = ptr[2] = ptr[3] = ptr[4] = 0.0f;
	ptr[1] = 1.0f;
	m_t = C3GA_E1_T;
}
inline void mv::set(const e2_t &src) {
	setGroupUsage(2);
	float *ptr = m_c;
	ptr[0] = ptr[1] = ptr[3] = ptr[4] = 0.0f;
	ptr[2] = 1.0f;
	m_t = C3GA_E2_T;
}
inline void mv::set(const e3_t &src) {
	setGroupUsage(2);
	float *ptr = m_c;
	ptr[0] = ptr[1] = ptr[2] = ptr[4] = 0.0f;
	ptr[3] = 1.0f;
	m_t = C3GA_E3_T;
}
inline void mv::set(const ni_t &src) {
	setGroupUsage(2);
	float *ptr = m_c;
	ptr[0] = ptr[1] = ptr[2] = ptr[3] = 0.0f;
	ptr[4] = 1.0f;
	m_t = C3GA_NI_T;
}

inline float _float(const mv &x) {
	return ((x.gu() & 1) != 0) ? x.getC()[0] : 0.0f;
}

inline void normalizedPoint::set()
{
	m_c[0] = m_c[1] = m_c[2] = m_c[3] = 0.0f;

}


inline void normalizedPoint::set(const CoordinateOrder co, const float _e1, const float _e2, const float _e3, const float _ni)
{
	m_c[0] = _e1;
	m_c[1] = _e2;
	m_c[2] = _e3;
	m_c[3] = _ni;

}

inline void normalizedPoint::set(const CoordinateOrder co, const float *A)
{
	m_c[0] = A[0];
	m_c[1] = A[1];
	m_c[2] = A[2];
	m_c[3] = A[3];

}

inline void normalizedPoint::set(const normalizedPoint &a)
{
	m_c[0] = a.m_c[0];
	m_c[1] = a.m_c[1];
	m_c[2] = a.m_c[2];
	m_c[3] = a.m_c[3];

}
inline void no_t::set(const no_t &a)
{

}
inline void e1_t::set(const e1_t &a)
{

}
inline void e2_t::set(const e2_t &a)
{

}
inline void e3_t::set(const e3_t &a)
{

}
inline void ni_t::set(const ni_t &a)
{

}


inline float normalizedPoint::largestCoordinate() const {
	float maxValue = 1.0f;
	if (::fabsf(m_c[0]) > maxValue) { maxValue = ::fabsf(m_c[0]); }
	if (::fabsf(m_c[1]) > maxValue) { maxValue = ::fabsf(m_c[1]); }
	if (::fabsf(m_c[2]) > maxValue) { maxValue = ::fabsf(m_c[2]); }
	if (::fabsf(m_c[3]) > maxValue) { maxValue = ::fabsf(m_c[3]); }
	return maxValue;
}
inline float normalizedPoint::largestBasisBlade(unsigned int &bm) const {
	float maxValue = 1.0f;
	bm = 1;
	if (::fabsf(m_c[0]) > maxValue) { maxValue = ::fabsf(m_c[0]); bm = 2; }
	if (::fabsf(m_c[1]) > maxValue) { maxValue = ::fabsf(m_c[1]); bm = 4; }
	if (::fabsf(m_c[2]) > maxValue) { maxValue = ::fabsf(m_c[2]); bm = 8; }
	if (::fabsf(m_c[3]) > maxValue) { maxValue = ::fabsf(m_c[3]); bm = 16; }
	return maxValue;
}
inline float no_t::largestCoordinate() const {
	float maxValue = 1.0f;
	return maxValue;
}
inline float no_t::largestBasisBlade(unsigned int &bm) const {
	float maxValue = 1.0f;
	bm = 1;
	return maxValue;
}
inline float e1_t::largestCoordinate() const {
	float maxValue = 1.0f;
	return maxValue;
}
inline float e1_t::largestBasisBlade(unsigned int &bm) const {
	float maxValue = 1.0f;
	bm = 2;
	return maxValue;
}
inline float e2_t::largestCoordinate() const {
	float maxValue = 1.0f;
	return maxValue;
}
inline float e2_t::largestBasisBlade(unsigned int &bm) const {
	float maxValue = 1.0f;
	bm = 4;
	return maxValue;
}
inline float e3_t::largestCoordinate() const {
	float maxValue = 1.0f;
	return maxValue;
}
inline float e3_t::largestBasisBlade(unsigned int &bm) const {
	float maxValue = 1.0f;
	bm = 8;
	return maxValue;
}
inline float ni_t::largestCoordinate() const {
	float maxValue = 1.0f;
	return maxValue;
}
inline float ni_t::largestBasisBlade(unsigned int &bm) const {
	float maxValue = 1.0f;
	bm = 16;
	return maxValue;
}

inline float _float(const normalizedPoint &x) {
	return 0.0f;
}
inline float _float(const no_t &x) {
	return 0.0f;
}
inline float _float(const e1_t &x) {
	return 0.0f;
}
inline float _float(const e2_t &x) {
	return 0.0f;
}
inline float _float(const e3_t &x) {
	return 0.0f;
}
inline float _float(const ni_t &x) {
	return 0.0f;
}
inline normalizedPoint cgaPoint(const float a, const float b, const float c)
{
	return normalizedPoint(normalizedPoint::coord_e1_e2_e3_ni,
			a, // e1
			b, // e2
			c, // e3
			(0.5f*a*a+0.5f*b*b+0.5f*c*c) // ni
		);
}
inline float norm_returns_scalar(const mv &a) {
	return norm(a);
}
inline float norm2_returns_scalar(const mv &a) {
	return norm2(a);
}


/** structure used by custom parser */
struct c3gaParseMultivectorData {
	/** the parsed value */
	mv value;
	/** this string will contain an error message when error is true */
	char message[256];
};

/** 
Parses 'str' (output of toString_mv()) and stores result in 'val' 
Throws std::string on error.
*/
mv parse(const std::string &str);

/** 
Parses 'str' (output of toString_mv()) and stores result in 'data'. 
'strSourceName' is the name of the source of 'str' (for example, a filename).
It is used for error messages.

	Returns true when 'str' parsed correctly.
Otherwise a lexer or parser error occured and you can check 
the errors in 'data->message'.
*/
bool parseEx(struct c3gaParseMultivectorData &data, const std::string &str, const std::string &strSourceName);
} // end of namespace c3ga
#endif /* _C3GA_H_ */

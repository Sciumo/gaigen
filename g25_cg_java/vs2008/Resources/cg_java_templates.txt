// S = specification
// FT = floatType
${CODEBLOCK GMVmemberVariables}
    /** group/grade usage (a bitmap which specifies which groups/grades are stored in 'c', below). */
	protected int m_gu = 0; 
<%if (S.m_GMV.MemoryAllocationMethod == G25.GMV.MEM_ALLOC_METHOD.DYNAMIC) {%>
    /** the coordinates */
	protected <%FT.type%>[] m_c = null; 
<%} else if (S.m_GMV.MemoryAllocationMethod == G25.GMV.MEM_ALLOC_METHOD.PARITY_PURE) {%>
    /** the coordinates (note: parity pure) */
	protected <%FT.type%>[] m_c = new <%FT.type%>[<%S.m_GMV.NbCoordinates / 2%>]; 
<%} else if (S.m_GMV.MemoryAllocationMethod == G25.GMV.MEM_ALLOC_METHOD.FULL) {%>
    /** the coordinates */
	protected <%FT.type%>[] m_c = new <%FT.type%>[<%S.m_GMV.NbCoordinates%>]; 
<%}%>
<%if (S.m_reportUsage) {%>
    /** Specialized multivector type. Used to report about non-optimized function usage. */
	protected SmvType m_t = <%G25.CG.CSJ.GMV.SMV_TYPE%>.<%G25.CG.Shared.ReportUsage.GetSpecializedConstantName(S, "none")%>; 
<%}%>
${ENDCODEBLOCK}


${CODEBLOCK SmvTypeEnum}
	private final int id;
    private final String label;

    SmvType(final int id, final String label) {
        this.id = id;
        this.label = label;
    }
    
    public int getId() {
        return id;
    }
 
    public String toString() {
        return label;
    }
}
${ENDCODEBLOCK}

 // S = specification
// className = mangled class name
// FT = floatType
${CODEBLOCK GMVconstructors}
<%{
bool dynMem = S.m_GMV.MemoryAllocationMethod == G25.GMV.MEM_ALLOC_METHOD.DYNAMIC;
bool repUsage = S.m_reportUsage;
%>

    /**
	* Constructs a new <%className%> with value 0.
     */
	public <%className%>() {set();}

    /**
	 * Copy constructor.
     */
	public <%className%>(<%className%> A) {set(A);}

<%foreach (G25.FloatType otherFT in S.m_floatTypes) {
	 if (FT == otherFT) continue;%>
    /** 
	 * Copies from <%otherFT.type%> to <%FT.type%>.
     */
	public <%className%>(<%otherFT.GetMangledName(S, S.m_GMV.Name)%> A) {set(A);}	 
<%}%>

    /**
	 * Constructs a new <%className%> with scalar value 'scalar'.
     */
	public <%className%>(<%FT.type%> scalar) {set(scalar);}

    /** 
     * Constructs a new <%className%> from compressed 'coordinates'.
 	 * @param gu bitwise OR of the GRADEs or GROUPs that are non-zero.
	 * @param coordinates compressed coordinates.
     */
	public <%className%>(int gu, <%FT.type%>[] coordinates) {set(gu, coordinates);}

<%foreach(G25.SMV smv in S.m_SMV) {
string smvClassName = FT.GetMangledName(S, smv.Name);%>
    /** Converts a <%smvClassName%> to a <%className%>. */
	public <%className%>(<%smvClassName%> A) {set(A);}
<%}%>

<%}%>
${ENDCODEBLOCK}

// S = specification
// gmv = gmv type
// FT = floatType
${CODEBLOCK GMVsetGroupUsage}
    /** Sets m_gu, allocates m_c to the size required by gu. */
	private void setGroupUsage(int gu) {
		if (m_gu == gu) return;
		m_gu = gu;
<%if (gmv.MemoryAllocationMethod == G25.GMV.MEM_ALLOC_METHOD.DYNAMIC) {%>
		int nbCoords = <%S.m_namespace%>.MvSize[m_gu];
		if (nbCoords > 0) {
			<%FT.type%>[] oldC = m_c;
			m_c = new <%FT.type%>[nbCoords];
			
			// copy old coordinates (this behavior is expected by e.g., reserve group)
            for (int i = 0; i < Math.min(oldC.length, m_c.length); i++)
                m_c[i] = oldC[i];
		}
<%}%>
	}
${ENDCODEBLOCK}

// S = specification
// gmv = gmv type
// FT = floatType
${CODEBLOCK GMVreserveGroups}
<%for (int groupIdx = 0; groupIdx < gmv.NbGroups; groupIdx++) { %>
	/**
	Reserves memory for coordinate GROUP_<%groupIdx%>.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	private void reserveGroup_<%groupIdx%>() {
		if ((m_gu & <%G25.CG.CSJ.GroupBitmap.GetGroupBitmapCode(groupIdx)%>) == 0) {
			int groupUsageBelow = m_gu & <%G25.CG.CSJ.GroupBitmap.GetBelowGroupBitmapCode(groupIdx)%>;
			int newGroupUsage = m_gu | <%G25.CG.CSJ.GroupBitmap.GetGroupBitmapCode(groupIdx)%>;
<%if (groupIdx < (gmv.NbGroups-1)) { %>
			int groupUsageAbove = m_gu ^ groupUsageBelow;
			int newGroupUsageBelowNextGroup = newGroupUsage & <%G25.CG.CSJ.GroupBitmap.GetBelowGroupBitmapCode(groupIdx+1)%>;
<%}%>

			setGroupUsage(newGroupUsage);

			int dstIdx;
<%if (groupIdx < (gmv.NbGroups-1)) { %>
			// move coordinate beyond new group
			dstIdx = <%S.m_namespace%>.MvSize[newGroupUsageBelowNextGroup];
			int srcIdx = <%S.m_namespace%>.MvSize[groupUsageBelow];
			for (int i = <%S.m_namespace%>.MvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				m_c[dstIdx + i] = m_c[srcIdx + i];
<%}%>

			// set coordinates of new group to 0
			dstIdx = <%S.m_namespace%>.MvSize[groupUsageBelow];
			<%for (int i = 0; i < gmv.Group(groupIdx).Length; i++) {%>m_c[dstIdx + <%i%>] = <%}%><%FT.DoubleToString(S, 0.0)%>;
		}
	}
<%}%>
${ENDCODEBLOCK}

// S = specification
// FT = floatType
${CODEBLOCK GMVgetGroupUsageCoords}
	/** returns group usage bitmap. */
	public int gu() { return m_gu; }
	/** returns compressed array of coordinates. */
	public <%FT.type%>[] c() { return m_c; }
	
${ENDCODEBLOCK}

// FT = floatType
// COORD_TYPE_STRING = string of type which describes coordinates
${CODEBLOCK SMVgetCoords}
	/** returns coordinates; 
	 * @param coordOrder pass the value <%COORD_TYPE_STRING%>.
	 */
	public <%FT.type%>[] c(<%G25.CG.Shared.SmvUtil.COORDINATE_ORDER_ENUM%> coordOrder) { return m_c; }
	
${ENDCODEBLOCK}


// S = Specification of algebra.
// MAX_N = maximum number of coordinates to set to zero explicitly
// FT = float type
${CODEBLOCK float_zero_copy_def}
<%for (int n = 1; n <= MAX_N; n++) {%>
	/** Sets <%n%> <%FT.type%>s to zero. */
	protected static void zero_<%n%>(<%FT.type%>[] dst) {
		<%for (int i = 0; i < n; i++) {%>dst[<%i%>]=<%}%><%FT.DoubleToString(S, 0.0)%>;
	}
	/** Copies <%n%> <%FT.type%>s from 'src' to 'dst.' */
	protected static void copy_<%n%>(<%FT.type%>[] dst, <%FT.type%>[] src) {
	<%for (int i = 0; i < n; i++) {%>
		dst[<%i%>] = src[<%i%>];
	<%}%>
}
<%}%>
	/** Sets N <%FT.type%>s to zero. */
	protected static void zero_N(<%FT.type%>[] dst, int N) {
		for (int i = 0; i < N; i++)
			dst[i] = <%FT.DoubleToString(S, 0.0)%>;
	}
	/** Copies N <%FT.type%>s from 'src' to 'dst'. */
	protected  static void copy_N(<%FT.type%>[] dst, <%FT.type%>[] src, int N) {
		for (int i = 0; i < N; i++)
			dst[i] = src[i];
	}
${ENDCODEBLOCK}

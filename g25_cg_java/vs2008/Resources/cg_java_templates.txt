// S = specification
// FT = floatType
${CODEBLOCK GMVmemberVariables}
    /** the coordinates */
	protected <%FT.type%>[][] m_c = new <%FT.type%>[<%S.m_GMV.NbGroups%>][]; 
	
<%if (S.m_reportUsage) {%>
    /** Specialized multivector type. Used to report about non-optimized function usage. */
	protected SmvType m_t = <%G25.CG.CSJ.GMV.SMV_TYPE%>.<%G25.CG.Shared.ReportUsage.GetSpecializedConstantName(S, "none")%>; 
<%}%>
${ENDCODEBLOCK}


${CODEBLOCK SmvTypeEnum}
	private final int id;
    private final String label;

    SmvType(final int id, final String label) {
        this.id = id;
        this.label = label;
    }
    
    public final int getId() {
        return id;
    }
 
    public final String toString() {
        return label;
    }
}
${ENDCODEBLOCK}

 // S = specification
// className = mangled class name
// FT = floatType
${CODEBLOCK GMVconstructors}
<%{
bool dynMem = S.m_GMV.MemoryAllocationMethod == G25.GMV.MEM_ALLOC_METHOD.DYNAMIC;
bool repUsage = S.m_reportUsage;
%>

    /**
	* Constructs a new <%className%> with value 0.
     */
	public <%className%>() {set();}

    /**
	 * Copy constructor.
     */
	public <%className%>(final <%className%> A) {set(A);}

<%foreach (G25.FloatType otherFT in S.m_floatTypes) {
	 if (FT == otherFT) continue;%>
    /** 
	 * Copies from <%otherFT.type%> to <%FT.type%>.
     */
	public <%className%>(<%otherFT.GetMangledName(S, S.m_GMV.Name)%> A) {set(A);}	 
<%}%>

    /**
	 * Constructs a new <%className%> with scalar value 'scalar'.
     */
	public <%className%>(final <%FT.type%> scalar) {set(scalar);}

    /** 
     * Constructs a new <%className%> from compressed 'coordinates'.
 	 * @param gu bitwise OR of the GRADEs or GROUPs that are non-zero.
	 * @param coordinates compressed coordinates.
     */
	public <%className%>(final int gu, final <%FT.type%>[] coordinates) {set(gu, coordinates);}

    /** 
     * Constructs a new <%className%> from array of array of 'coordinates'.
	 * @param coordinates The coordinates, one array for each group/grade. Make sure the
	 * array length match the size of the groups. Entries may be null.
     */
	public <%className%>(final <%FT.type%>[][] coordinates) {set(coordinates);}
	
<%foreach(G25.SMV smv in S.m_SMV) {
string smvClassName = FT.GetMangledName(S, smv.Name);%>
    /** Converts a <%smvClassName%> to a <%className%>. */
	public <%className%>(final <%smvClassName%> A) {set(A);}
<%}%>

<%}%>
${ENDCODEBLOCK}

// S = specification
// gmv = gmv type
// FT = floatType
${CODEBLOCK GMVsetGroupUsage}
	/** 
	 * Reserves memory for the groups specified by 'gu'.
	 * Keeps old memory (and values) when possible. 
	 */
	private final void allocateGroups(final int gu) {
		for (int i = 0; (1 << i) <= gu; i++) {
			if (((1 << i) & gu) != 0) {
				if (m_c[i] == null)
					m_c[i] = new <%FT.type%>[<%S.m_namespace%>.MvSize[1 << i]];
			}
			else m_c[i] = null;
		}		
	}
${ENDCODEBLOCK}

// S = specification
// gmv = gmv type
// FT = floatType
${CODEBLOCK GMVreserveGroups}
<%for (int groupIdx = 0; groupIdx < gmv.NbGroups; groupIdx++) { %>
	/**
	 *  Reserves memory for coordinate GROUP_<%groupIdx%>.
	 *  If the group is already present, nothing changes.
	 *  If the group is not present, memory is allocated for the new group,
	 *  and the coordinates for the group are set to zero.
	 */
	private final void reserveGroup_<%groupIdx%>() {
		if (m_c[<%groupIdx%>] == null) {
			m_c[<%groupIdx%>] = new <%FT.type%>[<%gmv.Group(groupIdx).Length%>];
		}
	}
<%}%>
${ENDCODEBLOCK}

// S = specification
// FT = floatType
${CODEBLOCK GMVgetGroupUsageCoords}
	/** returns group usage bitmap. */
	public final int gu() {
		return 
<%for (int g = 0; g < S.m_GMV.NbGroups; g++) {%>
			((m_c[<%g%>] == null) ? 0 : <%G25.CG.CSJ.GroupBitmap.GetGroupBitmapCode(g)%>) |
<%}%>
			0;
	}
	
    /**
	 * Returns array of array of coordinates.
	 * Each entry contain the coordinates for one group/grade.
     */
	public final <%FT.type%>[][] c() { return m_c; }
	
${ENDCODEBLOCK}


// S = Specification of algebra.
// MAX_N = maximum number of coordinates to set to zero explicitly
// FT = float type
${CODEBLOCK float_zero_copy_def}
<%for (int n = 1; n <= MAX_N; n++) {%>
	/** Sets <%n%> <%FT.type%>s to zero. */
	protected final static void zero_<%n%>(final <%FT.type%>[] dst) {
		<%for (int i = 0; i < n; i++) {%>dst[<%i%>]=<%}%><%FT.DoubleToString(S, 0.0)%>;
	}
	/** Copies <%n%> <%FT.type%>s from 'src' to 'dst.' */
	protected final static void copy_<%n%>(final <%FT.type%>[] dst, final <%FT.type%>[] src) {
	<%for (int i = 0; i < n; i++) {%>
		dst[<%i%>] = src[<%i%>];
	<%}%>
}
<%}%>
	/** Sets N <%FT.type%>s to zero. */
	protected final static void zero_N(final <%FT.type%>[] dst, final int N) {
		for (int i = 0; i < N; i++)
			dst[i] = <%FT.DoubleToString(S, 0.0)%>;
	}
	/** Copies N <%FT.type%>s from 'src' to 'dst'. */
	protected final static void copy_N(final <%FT.type%>[] dst, final <%FT.type%>[] src, final int N) {
		for (int i = 0; i < N; i++)
			dst[i] = src[i];
	}
${ENDCODEBLOCK}

// S = specification
// FT = float type
// gmv = gmv type
// gmvName = name of first GMV type
${CODEBLOCK sourceToString}

	private final static String DEFAULT_FP = "%2.2f";
	private final static String DEFAULT_START = "";
	private final static String DEFAULT_END = "";
	private final static String DEFAULT_MUL = "*";
	private final static String DEFAULT_WEDGE = "^";
	private final static String DEFAULT_PLUS = " + ";
	private final static String DEFAULT_MINUS = " - ";

	/*
	 * These strings determine how the output of string() is formatted.
	 * You can alter them at runtime using setStringFormat(). 
	 */
	protected static String string_fp = DEFAULT_FP;
	protected static String string_start = DEFAULT_START;
	protected static String string_end = DEFAULT_END;
	protected static String string_mul = DEFAULT_MUL;
	protected static String string_wedge = DEFAULT_WEDGE;
	protected static String string_plus = DEFAULT_PLUS;
	protected static String string_minus = DEFAULT_MINUS;
	
	public final static String STRING_FP = "fp";
	public final static String STRING_START = "start";
	public final static String STRING_END = "end";
	public final static String STRING_MUL = "mul";
	public final static String STRING_WEDGE = "wedge";
	public final static String STRING_PLUS = "plus";
	public final static String STRING_MINUS= "minus";

	/**
	 * Sets the formatting of toString().
	 * 
	 * @param what What formatter to set. Valid values: STRING_FP, STRING_START, STRING_END, STRING_MUL, STRING_WEDGE, STRING_PLUS, STRING_MINUS.
	 * @param format The value for 'what'. Use 'null' to set the default value.
	 */
	public final static void setStringFormat(final String what, final String format) {
		if (what.equals(STRING_FP)) 
			string_fp = (format != null) ? format : DEFAULT_FP;
		else if (what.equals(STRING_START)) 
			string_start = (format != null) ? format : DEFAULT_START;
		else if (what.equals(STRING_END)) 
			string_end = (format != null) ? format : DEFAULT_END;
		else if (what.equals(STRING_MUL)) 
			string_mul = (format != null) ? format : DEFAULT_MUL;
		else if (what.equals(STRING_WEDGE)) 
			string_wedge = (format != null) ? format : DEFAULT_WEDGE;
		else if (what.equals(STRING_PLUS)) 
			string_plus = (format != null) ? format : DEFAULT_PLUS;
		else if (what.equals(STRING_MINUS)) 
			string_minus = (format != null) ? format : DEFAULT_MINUS;
		else throw new RuntimeException("invalid argument to setStringFormat(): " + what);
	}
	
   /** Converts a multivector to a String using default float format. */
	public final static String string(final <%G25.CG.Java.MvInterface.GetMvInterfaceName(S, FT)%> value) {
		return string(value, null);
	}
	
   /** 
    * Converts a multivector to a String according to a float format like  "%2.2f"
	* @param fp floating point format. Use 'null' for the default format (see setStringFormat()).
	*/
	public final static String string(final <%G25.CG.Java.MvInterface.GetMvInterfaceName(S, FT)%> value, String fp) {
		<%gmvName%> obj = value.to_<%gmvName%>();
		StringBuffer result = new StringBuffer();
		int ia = 0; // global index into coordinates (runs from 0 to <%(gmv.NbCoordinates-1)%>)
		int cnt = 0; // how many coordinates printed so far

		// set up the floating point precision
		if (fp == null) fp = string_fp;

		// start the string
		result.append(string_start);

		// print all coordinates
		for (int g = 0; g < <%gmv.NbGroups%>; g++) {
			<%FT.type%>[] Cg = obj.m_c[g];
			if (Cg != null) {
				for (int b = 0; b < GroupSize[g]; b++) {
					double coord = (double)BasisElementSignByIndex[ia] * Cg[b];
					
					// goal: print [+|-]obj.m_c[k][* basisVector1 ^ ... ^ basisVectorN]
					
					String tmpFloatStr = String.format(fp, Math.abs(coord));

					if (Double.parseDouble(tmpFloatStr) != 0.0) {
						// print [+|-]
						result.append((coord >= 0.0) 
							? ((cnt>0) ? string_plus : "")
							: string_minus);
						// print obj.m_c[k]
						result.append(tmpFloatStr);

						if (g != 0) { // if not grade 0, print [* basisVector1 ^ ... ^ basisVectorN]
							result.append(string_mul);

							// print all basis vectors
							int bei = 0;
							while (BasisElements[ia][bei] >= 0) {
								if (bei > 0)
									result.append(string_wedge);
								result.append(BasisVectorNames[BasisElements[ia][bei]]);
								bei++;
							}
						}

						cnt++;
					}
					ia++;
				}
			}
			else ia += GroupSize[g];
		}

		// if no coordinates printed: 0
		if (cnt == 0) result.append("0");

		// end the string
		result.append(string_end);

		return result.toString();
	}
	
${ENDCODEBLOCK}

// S = specification
// FT = float type
// mvName = NON-mangled name of multivector
${CODEBLOCK MVtoString}
	/**
	 * Returns this multivector, converted to a string.
	 * The floating point formatter is controlled via <%S.m_namespace%>.setStringFormat().
	 */
	public final String toString() {
<%if (FT == S.m_floatTypes[0]) {%>
		return <%S.m_namespace%>.string(this);
<%} else {%>
		return <%S.m_namespace%>.string(new <%S.m_floatTypes[0].GetMangledName(S, mvName)%>(this));
<%}%>
	}
	
	/**
	 * Returns this multivector, converted to a string.
	 * The floating point formatter is "%f".
	 */
	public final String toString_f() {
		return toString("%f");
	}
	
	/**
	 * Returns this multivector, converted to a string.
	 * The floating point formatter is "%e".
	 */
	public final String toString_e() {
		return toString("%e");
	}
	
	/**
	 * Returns this multivector, converted to a string.
	 * The floating point formatter is "%2.20e".
	 */
	public final String toString_e20() {
		return toString("%2.20e");
	}
	
	/**
	 * Returns this multivector, converted to a string.
	 * @param fp floating point format. Use 'null' for the default format (see <%S.m_namespace%>.setStringFormat()).
	 */
	public final String toString(final String fp) {
<%if (FT == S.m_floatTypes[0]) {%>
		return <%S.m_namespace%>.string(this, fp);
<%} else {%>
		return <%S.m_namespace%>.string(new <%S.m_floatTypes[0].GetMangledName(S, mvName)%>(this), fp);
<%}%>
	}
${ENDCODEBLOCK}

// gmvName = name of gmv type
${CODEBLOCK mvInterface}
	/** converts this multivector to type '<%gmvName%>' */
	<%gmvName%> to_<%gmvName%>();
${ENDCODEBLOCK}

// gmvName = name of gmv type
${CODEBLOCK GMVmvInterfaceImpl}
	public final <%gmvName%> to_<%gmvName%>() {
		return this;
	}
${ENDCODEBLOCK}

// gmvName = name of gmv type
${CODEBLOCK SMVmvInterfaceImpl}
	public final <%gmvName%> to_<%gmvName%>() {
		return new <%gmvName%>(this);
	}
${ENDCODEBLOCK}

// S = specification
// smv = smv class
// className = mangled class name
// gmvClassName = mangled class name of GMV
// FT = floatType
${CODEBLOCK SMVconstructors}
    /** Constructs a new <%className%> with variable coordinates set to 0. */
	public <%className%>() {set();}

    /** Copy constructor. */
	public <%className%>(final <%className%> A) {set(A);}

<%foreach (G25.FloatType otherFT in S.m_floatTypes) {
	 if (FT == otherFT) continue;%>
    /** Copies from <%otherFT.type%> to <%FT.type%>. */
	public <%className%>(final <%otherFT.GetMangledName(S, smv.Name)%> A) {set(A);}
<%}%>

<%if (smv.GetElementIdx(RefGA.BasisBlade.ONE) >= 0) {%>
	/** Constructs a new <%className%> with scalar value 'scalar'. */
	public <%className%>(final <%FT.type%> scalar) {set(scalar);}
<%}%>

	/** Constructs a new <%className%> from <%gmvClassName%>.
	 *  @param A The value to copy. Coordinates that cannot be represented
	 *  are silently dropped.
	 */
	public <%className%>(final <%gmvClassName%> A /*, final int filler */) {set(A);}

<%if (smv.NbNonConstBasisBlade > 0) {%>
	/** Constructs a new <%className%>. Coordinate values come from 'A'. */
	public <%className%>(final CoordinateOrder co, final <%FT.type%>[] A) {set(co, A);}
	
	/** Constructs a new <%className%> with each coordinate specified. */
	public <%className%>(final CoordinateOrder co, <%for (int i = 0; i < smv.NbNonConstBasisBlade; i++) {%><%if (i > 0) {%>,<%}%> final <%FT.type%> <%smv.NonConstBasisBlade(i).ToLangString(S.m_basisVectorNames)%><%}%>) {
		set(co<%for (int i = 0; i < smv.NbNonConstBasisBlade; i++) {%>, <%smv.NonConstBasisBlade(i).ToLangString(S.m_basisVectorNames)%><%}%>);
	}
<%}%>
${ENDCODEBLOCK}

// same arguments as randomBladeVersor
${CODEBLOCK randomBladeVersorHeader}
/**
Generates a random <%if (generatorVersor) {%>versor<%}else{%>blade<%}%>.
The scale is uniformly distributed over the interval [0 1).
The maximum non-zero grade-part is 'grade'.
Only the basis vectors marked in 'basisVectorBitmap' will be used to generate the
versor/blade. Use 'basisVectorBitmap = -1' (the default) to use all basisvectors.

Returns <%functionName%>_ex(arg1, scale, grade, basisVectorBitmap, 0.01, scale * 4.0);
*/
<%mvType%> <%functionName%>(<%FT.type%> scale, int grade, int basisVectorBitmap = -1);

/**
This version of <%functionName%>() has extra arguments which help to avoid 
near-singular blades / versors.

Near-singular blades / versors are avoid by testing the norm and largest coordinate
of the random blade / versor. If the test does not pass, the function recursively
tries to generate another random blade / versor.

'minimumNorm' is the minimum allowed norm of the blade/versor before scaling. 
'minimumNorm' must be > 0.0 for versors.

'largestCoordinate' is the largest coordinate allowed after scaling.
*/
<%mvType%> <%functionName%>_ex(<%FT.type%> scale, int grade, int basisVectorBitmap, <%FT.type%> minimumNorm, <%FT.type%> largestCoordinate);

${ENDCODEBLOCK}

// S = Specification of algebra.
// functionName = name of generated function
// FT = floating point type
// mvType = multivector type name (with prefix/suffix)
// randomScalarFuncName = name of function which generates random scalar values
// gpopFuncName = name of geometric product or outer product function for two multivectors
// normFuncName = norm of multivector function (must return scalar)
// gpScalarFuncName = geometric product of multivector and scalar
// generatorVersor = bool (use geometric product or outer product)
${CODEBLOCK randomBladeVersor}

<%mvType%> <%functionName%>(<%FT.type%> scale, int grade, int basisVectorBitmap) {
	<%FT.type%> minimumNorm = <%FT.DoubleToString(S, 0.01)%>;
	<%FT.type%> largestCoordinate = <%FT.DoubleToString(S, 4.0)%>;
	return <%functionName%>_ex(scale, grade, basisVectorBitmap, minimumNorm, scale * largestCoordinate);
}

<%mvType%> <%functionName%>_ex(<%FT.type%> scale, int _grade, int basisVectorBitmap, 
		<%FT.type%> minimumNorm, <%FT.type%> largestCoordinate) 
{
	<%mvType%> randomVector, tmp1, tmp2;
	<%mvType%> *IR1 = &tmp1, *IR2 = &tmp2; // IR = intermediate result
	<%FT.type%> randomValues[<%S.m_dimension%>];
	<%FT.type%> n2, mul;
	int i;
	int grade = _grade;
	
	// set IR1 (intermediate result) to 1
	IR1->set(<%FT.DoubleToString(S, 1.0)%>);

	while (grade > 0) {	// loop until grade == 0
		// fill array with random values
		for (i = 0; i < <%S.m_dimension%>; i++) 
			randomValues[i] = (basisVectorBitmap & (1 << i))
				? (<%FT.DoubleToString(S, -1.0)%> + <%FT.DoubleToString(S, 2.0)%> * <%randomScalarFuncName%>())
				: <%FT.DoubleToString(S, 0.0)%>;
		
		// make it a multivector:
		randomVector.set(GRADE_1, randomValues);
		
		// multiply 
		(*IR2) = <%gpopFuncName%>(*IR1, randomVector);
		
		// swap IR pointers: 
		std::swap(IR1, IR2);
		
		// lower grade
		grade--;
	}
	
	// compute norm/multiplier, apply it, or recurse if we happened to create a near-null versor
	n2 = <%normFuncName%>(*IR1);
	if ((<%FT.type%>)fabs(n2) > minimumNorm * minimumNorm) {
		if (n2 != <%FT.DoubleToString(S, 0.0)%>) {
			mul = scale * <%randomScalarFuncName%>() / n2;
			if (IR1->largestCoordinate() * mul < largestCoordinate)
				return <%gpScalarFuncName%>(*IR1, mul);
		}
		else if (IR1->largestCoordinate() < largestCoordinate)
			return *IR1;
	}
	
	// try again:
	return <%functionName%>_ex(scale, _grade, basisVectorBitmap, minimumNorm, largestCoordinate); 
}
${ENDCODEBLOCK}

// functionName = name of generated function
// pointType = multivector type name (with prefix/suffix)
// FT = floating point type
${CODEBLOCK randomCgaPointHeader}
/** Returns a random conformal point where the coordinates lie in the interval [-scale, scale). */
<%pointType%> <%functionName%>(<%FT.type%> scale);
${ENDCODEBLOCK}

// S = Specification of algebra.
// functionName = name of generated function
// pointType = multivector type name (with prefix/suffix)
// FT = floating point type
// randomScalarFuncName = name of function which generates random scalar values
// cgaPointFunc = function for computing a point from coordinates
${CODEBLOCK randomCgaPoint}
<%if (S.m_inlineFunctions) {%>inline <%}%><%pointType%> <%functionName%>(<%FT.type%> scale) {
<%for (int i = 0; i < S.m_dimension-2; i++) {%>	<%FT.type%> ce<%(i+1).ToString()%> = scale * (<%FT.DoubleToString(S, -1.0)%> + <%FT.DoubleToString(S, 2.0)%> * <%randomScalarFuncName%>());
<%}%>
	return <%cgaPointFunc%>(<%for (int i = 0; i < S.m_dimension-2; i++) {%><%if (i > 0){%>, <%}%>ce<%(i+1).ToString()%><%}%>);
}
${ENDCODEBLOCK}

${CODEBLOCK seriesDecl}
/** Computes <%mathFuncName%> of <%inputType%>.
<%userComment%> */
<%returnType%> <%funcName%>(const <%inputType%> &x, int order = 12);
${ENDCODEBLOCK}


// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesExp}

<%returnType%> <%funcName%>(const <%inputType%> &x, int order /*  = 12 */) {
	unsigned long maxC, scale = 1;
	<%inputType%> xScaled;
	<%returnType%> tmp1, tmp2; // temp <%returnType%> used for various purposes
	<%returnType%> xPow1, xPow2;
	<%returnType%> *result1 = &tmp1, *result2 = &tmp2;
	<%FT.type%> s_x2, a;
	int i;
   
	// First try special cases: check if (x * x) is scalar
	tmp1 = <%gpFuncII%>(x, x);
	s_x2 = _<%FT.type%>(tmp1);
	if ((<%normE2funcR%>(tmp1) - s_x2 * s_x2) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
		// OK (x * x == ~scalar), so use special cases:
		if (s_x2 < <%FT.DoubleToString(S, 0.0)%>) {
			a = <%sqrtFunc%>(-s_x2);
			return <%SASfuncI%>(x, <%sinFunc%>(a) / a, <%cosFunc%>(a));
		}
		else if (s_x2 > <%FT.DoubleToString(S, 0.0)%>) {
			a = <%sqrtFunc%>(s_x2);
			return <%SASfuncI%>(x, <%sinhFunc%>(a) / a, <%coshFunc%>(a));
		}
		else {
			return <%SASfuncI%>(x, <%FT.DoubleToString(S, 1.0)%>, <%FT.DoubleToString(S, 1.0)%>);
		}
	}

	// else do general series eval . . .

	// result = 1 + ....	
	*result1 = <%FT.DoubleToString(S, 1.0)%>;
	if (order == 0) return *result1;

	// find scale (power of 2) such that its norm is < 1
	maxC = (unsigned long)x.largestCoordinate();
	scale = 1;
	if (maxC > 1) scale <<= 1;
	while (maxC)
	{
		maxC >>= 1;
		scale <<= 1;
	}

	// scale
	xScaled = <%gpFuncIdouble%>(x, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)scale); 

	// taylor series approximation
	xPow1 = <%FT.DoubleToString(S, 1.0)%>; 
	for (i = 1; i <= order; i++) {
		xPow2 = <%gpFuncRI%>(xPow1, xScaled);
		xPow1 = <%gpFuncRdouble%>(xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i);
		
		*result2 = <%addFuncRR%>(*result1, xPow1); // result2 = result1 + xPow1
		std::swap(result1, result2); // result is always in 'result1' at end of loop
    }

	// undo scaling
	while (scale > 1)
	{
		*result2 = <%gpFuncRR%>(*result1, *result1);
		std::swap(result1, result2); // result is always in 'result1' at end of loop
		scale >>= 1;
	}
    
    return *result1;
} // end of <%funcName%>()

${ENDCODEBLOCK}


// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesSinh}
<%returnType%> <%funcName%>(const <%inputType%> &x, int order /*  = 12 */) {
	<%returnType%> tmp1, tmp2; // temp <%returnType%> used for various purposes
	<%returnType%> xPow1, xPow2; // xScaled^... goes here
	<%returnType%> *result1 = &tmp1, *result2 = &tmp2;
	<%FT.type%> s_x2, a;
	int i;
   
	// First try special cases: check if (x * x) is scalar
	tmp1 = <%gpFuncII%>(x, x);
	s_x2 = _<%FT.type%>(tmp1);
	if ((<%normE2funcR%>(tmp1) - s_x2 * s_x2) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
		// OK (x * x == ~scalar), so use special cases:
		if (s_x2 < <%FT.DoubleToString(S, 0.0)%>) {
			a = <%sqrtFunc%>(-s_x2);
			return <%SASfuncI%>(x, <%sinFunc%>(a) / a, <%FT.DoubleToString(S, 0.0)%>);
		}
		else if (s_x2 > <%FT.DoubleToString(S, 0.0)%>) {
			a = <%sqrtFunc%>(s_x2);
			return <%SASfuncI%>(x, <%sinhFunc%>(a) / a, <%FT.DoubleToString(S, 0.0)%>);
		}
		else {
<%if ((returnType != inputType) && (returnType != FT.GetMangledName(S, S.m_GMV.Name))) {%>
			return <%copyInputToReturnFunc%>(x);
<%} else {%>
			return x;
<%}%>
		}
	}

	// else do general series eval . . .

	// result = A +  A^3/3! + A^5/5!
	result1->set(); // result = 0
    if (order == 0) return *result1;
    	
	// taylor series approximation
	xPow1 = <%FT.DoubleToString(S, 1.0)%>;
	for (i = 1; i <= order; i++) {
		xPow2 = <%gpFuncRI%>(xPow1, x); // xPow2 = xPow1 * x
		xPow1 = <%gpFuncRdouble%>(xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i); // xPow1 = xScaled^i / i! 
		
		if ((i % 2) == 1) {
			*result2 = <%addFuncRR%>(*result1, xPow1); 
			std::swap(result1, result2); 
		}
	}

    return *result1;
} // end of <%funcName%>()
${ENDCODEBLOCK}

// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesCosh}

<%returnType%> <%funcName%>(const <%inputType%> &x, int order) {
	<%returnType%> tmp1, tmp2; // temp <%returnType%> used for various purposes
	<%returnType%> xPow1, xPow2; // xScaled^... goes here
	<%returnType%> *result1 = &tmp1, *result2 = &tmp2;
	<%FT.type%> s_x2;
	int i;
   
	// First try special cases: check if (x * x) is scalar
	tmp1 = <%gpFuncII%>(x, x);
	s_x2 = _<%FT.type%>(tmp1);
	if ((<%normE2funcR%>(tmp1) - s_x2 * s_x2) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
		// OK (x * x == ~scalar), so use special cases:
		if (s_x2 > <%FT.DoubleToString(S, 0.0)%>) {
			return <%returnType%>(<%coshFunc%>(<%sqrtFunc%>(s_x2)));
		}
		else if (s_x2 < <%FT.DoubleToString(S, 0.0)%>) {
			return <%returnType%>(<%cosFunc%>(<%sqrtFunc%>(-s_x2)));
		}
		else {
			return <%returnType%>(<%FT.DoubleToString(S, 1.0)%>);
		}
	}

	// else do general series eval . . .


	*result1 = <%FT.DoubleToString(S, 1.0)%>;
	if (order == 0) return *result1;

	// taylor series approximation
	xPow1 = <%FT.DoubleToString(S, 1.0)%>;
	for (i = 1; i <= order; i++) {
		xPow2 = <%gpFuncRI%>(xPow1, x);
		xPow1 = <%gpFuncRdouble%>(xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i); // xPow1 = xScaled^i / i! 
		
		if ((i % 2) == 0) {
			*result2 = <%addFuncRR%>(*result1, xPow1); 
			std::swap(result1, result2); // result is always in 'result1' at end of loop		
		}
    }

    return *result1;
} // end of <%funcName%>()
${ENDCODEBLOCK}


// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesSin}

<%returnType%> <%funcName%>(const <%inputType%> &x, int order) {
	<%returnType%> tmp1, tmp2; // temp <%returnType%> used for various purposes
	<%returnType%> xPow1, xPow2; // xScaled^... goes here
	<%returnType%> *result1 = &tmp1, *result2 = &tmp2;
	<%FT.type%> s_x2, a;
	int i;
   
	// First try special cases: check if (x * x) is scalar
	tmp1 = <%gpFuncII%>(x, x);
	s_x2 = _<%FT.type%>(tmp1);
	if ((<%normE2funcR%>(tmp1) - s_x2 * s_x2) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
		// OK (x * x == ~scalar), so use special cases:
		if (s_x2 < <%FT.DoubleToString(S, 0.0)%>) {
			a = <%sqrtFunc%>(-s_x2);
			return <%SASfuncI%>(x, <%sinhFunc%>(a) / a, <%FT.DoubleToString(S, 0.0)%>);
		}
		else if (s_x2 > <%FT.DoubleToString(S, 0.0)%>) {
			a = <%sqrtFunc%>(s_x2);
			return <%SASfuncI%>(x, <%sinFunc%>(a) / a, <%FT.DoubleToString(S, 0.0)%>);
		}
		else {
<%if ((returnType != inputType) && (returnType != FT.GetMangledName(S, S.m_GMV.Name))) {%>
			return <%copyInputToReturnFunc%>(x);
<%} else {%>
			return x;
<%}%>
		}
	}

	// else do general series eval . . .

	// result = A -  ....	+ ... - ...
	result1->set(); // result1 = 0;
    if (order == 0) return *result1;
    	
	// taylor series approximation
	xPow1 = <%FT.DoubleToString(S, 1.0)%>; // xPow1 = 1.0
	for (i = 1; i <= order; i++) {
		xPow2 = <%gpFuncRI%>(xPow1, x); // xPow2 = xPow1 * x
		
		xPow1 = <%gpFuncRdouble%>(xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i); // xPow1 = xScaled^i / i! 
		
		if ((i % 4) == 3)
		{
			*result2 = <%subFuncRR%>(*result1, xPow1); // result2 = result1 - xPow1
			std::swap(result1, result2); // result is always in 'result1' at end of loop
		}
		else if ((i % 4) == 1) 
		{
			*result2 = <%addFuncRR%>(*result1, xPow1); // result2 = result1 + xPow1
			std::swap(result1, result2); // result is always in 'result1' at end of loop
		}
	}

	return *result1;
} // end of <%funcName%>()

${ENDCODEBLOCK}

// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesCos}
<%returnType%> <%funcName%>(const <%inputType%> &x, int order) {
	<%returnType%> tmp1, tmp2; // temp <%returnType%> used for various purposes
	<%returnType%> xPow1, xPow2; // xScaled^... goes here
	<%returnType%> *result1 = &tmp1, *result2 = &tmp2; // accumulated result goes here (note: 'result1' = 'R')
	<%FT.type%> s_x2;
	int i;
   
	// First try special cases: check if (x * x) is scalar
	tmp1 = <%gpFuncII%>(x, x);
	s_x2 = _<%FT.type%>(tmp1);
	if ((<%normE2funcR%>(tmp1) - s_x2 * s_x2) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
		// OK (x * x == ~scalar), so use special cases:
		if (s_x2 > <%FT.DoubleToString(S, 0.0)%>) {
			return <%returnType%>(<%cosFunc%>(<%sqrtFunc%>(s_x2)));
		}
		else if (s_x2 < <%FT.DoubleToString(S, 0.0)%>) {
			return <%returnType%>(<%coshFunc%>(<%sqrtFunc%>(-s_x2)));
		}
		else {
			return <%returnType%>(<%FT.DoubleToString(S, 1.0)%>);
		}
	}

	// else do general series eval . . .


	*result1 = <%FT.DoubleToString(S, 1.0)%>;
	if (order == 0) return *result1;

	// taylor series approximation
	xPow1 = <%FT.DoubleToString(S, 1.0)%>; // xPow1 = 1.0
	for (i = 1; i <= order; i++) {
		xPow2 = <%gpFuncRI%>(xPow1, x); // xPow2 = xPow1 * x
		xPow1 = <%gpFuncRdouble%>(xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i); // xPow1 = xScaled^i / i! 
		
		if ((i % 4) == 2)
		{
			*result2 = <%subFuncRR%>(*result1, xPow1); // result2 = result1 - xPow1
			std::swap(result1, result2); // result is always in 'result1' at end of loop
		}
		else if ((i % 4) == 0) 
		{
			*result2 = <%addFuncRR%>(*result1, xPow1); // result2 = result1 + xPow1
			std::swap(result1, result2); // result is always in 'result1' at end of loop
		}		
    }

	return *result1;
} // end of <%funcName%>()
${ENDCODEBLOCK}

// S = Specification of algebra.
// FT = float type
// arg1name = argument 1 name
// arg2name = argument 2 name
// gmvName = mangled name of GMV
// gpFuncName = gpFuncName
// reverseFuncName = reverseFuncName
// norm2FuncName = norm2FuncName
// divFuncName = divFuncName
${CODEBLOCK igp_GMV_GMV_body}
<%FT.type%> _N2_ = <%norm2FuncName%>(<%arg2name%>);
return <%divFuncName%>(
	<%gpFuncName%>(<%arg1name%>, <%reverseFuncName%>(<%arg2name%>)),
	_N2_);
${ENDCODEBLOCK}

// S = Specification of algebra.
// FT = float type
// arg1name = argument 1 name
// arg2name = argument 2 name
// gmvName = mangled name of GMV
// divFuncName = divFuncName
${CODEBLOCK igp_GMV_float_body}
return <%divFuncName%>(<%arg1name%>, <%arg2name%>);
${ENDCODEBLOCK}

// S = Specification of algebra.
// FT = float type
// arg1name = argument 1 name
// arg2name = argument 2 name
// dstName = argument 2 name
// gmvName = mangled name of GMV
// mulFuncName = gpFuncName
// reverseFuncName = reverseFuncName
// norm2FuncName = norm2FuncName
// mulFuncName = divFuncName
${CODEBLOCK igp_float_GMV_body}
<%FT.type%> _N2_ = <%norm2FuncName%>(<%arg2name%>);
return <%mulFuncName%>(<%reverseFuncName%>(<%arg2name%>), <%arg1name%> / _N2_);
${ENDCODEBLOCK}

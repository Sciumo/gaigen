// arguments: 
// Namespace = name of algebra.
// Gaigen = name and version of Gaigen
// License = full text of license.
${CODEBLOCK doxyMainPage}
/*! \mainpage <%Namespace%> documentation
 *
 * <%Namespace%> implementation generated by <%Gaigen%>. 
 * 
 * 
 * License: 
<%License%>  
 * 
 * \section intro_sec Introduction
 *
 * Todo
 * 
 */
${ENDCODEBLOCK}


// S = Specification of algebra.
${CODEBLOCK basicInfo}

/// The dimension of the space:
extern const int <%S.m_namespace%>_spaceDim;

/// Number of groups/grades of coordinates in multivector:
extern const int <%S.m_namespace%>_nbGroups;

/// The constants for the groups in an array:
extern const int <%S.m_namespace%>_groups[];

/// The constants for the grades in an array:
extern const int <%S.m_namespace%>_grades[];

/// Is the metric of the space Euclidean? (0 or 1)
extern const bool <%S.m_namespace%>_metricEuclidean;

/// This array can be used to lookup the number of coordinates for a group part of a general multivector
extern const int <%S.m_namespace%>_groupSize[<%S.m_GMV.NbGroups%>];

/// This array can be used to lookup the number of coordinates based on a group usage bitmap
extern const int <%S.m_namespace%>_mvSize[<%1<<S.m_GMV.NbGroups%>];

/// This array of ASCIIZ strings contains the names of the basis vectors
extern const char *<%S.m_namespace%>_basisVectorNames[<%S.m_dimension%>];

/// This array of integers contains the order of basis elements in the general multivector
/// Use it to answer: 'what basis vectors are in the basis element at position [x]?
extern const int <%S.m_namespace%>_basisElements[<%1<<S.m_dimension%>][<%S.m_dimension+1%>];

/// This array of integers contains the 'sign' (even/odd permutation of canonical order) of basis elements in the general multivector
/// Use it to answer 'what is the permutation of the coordinate at index [x]'?
extern const double <%S.m_namespace%>_basisElementSignByIndex[<%1<<S.m_dimension%>];

/// This array of integers contains the 'sign' (even/odd permutation of canonical order) of basis elements in the general multivector
/// Use it to answer 'what is the permutation of the coordinate of bitmap [x]'?
extern const double <%S.m_namespace%>_basisElementSignByBitmap[<%1<<S.m_dimension%>];

/// This array of integers contains the order of basis elements in the general multivector
/// Use it to answer: 'at what index do I find basis element [x] (x = basis vector bitmap)?'
extern const int <%S.m_namespace%>_basisElementIndexByBitmap[<%1<<S.m_dimension%>];

/// This array of integers contains the indices of basis elements in the general multivector
/// Use it to answer: 'what basis element do I find at index [x]'?
extern const int <%S.m_namespace%>_basisElementBitmapByIndex[<%1<<S.m_dimension%>];

/// This array of grade of each basis elements in the general multivector
/// Use it to answer: 'what is the grade of basis element bitmap [x]'?
extern const int <%S.m_namespace%>_basisElementGradeByBitmap[<%1<<S.m_dimension%>];

/// This array of group of each basis elements in the general multivector
/// Use it to answer: 'what is the group of basis element bitmap [x]'?
extern const int <%S.m_namespace%>_basisElementGroupByBitmap[<%1<<S.m_dimension%>];
${ENDCODEBLOCK}

// S = Specification of algebra.
// STRING_PARAMETERS = list of parameters that determine output of toString and their default values.
${CODEBLOCK toStringHeader}
/**
This function alters the formatting of 'string()'.
'format' = NULL will give you back the default.
*/
void setStringFormat(const char *what, const char *format);

<%for (int i = 0; i < STRING_PARAMETERS.Length; i++) {
%>extern const char *string_<%STRING_PARAMETERS[i][0]%>; /* = \"<%STRING_PARAMETERS[i][1]%>\" */
<%}%>

<%foreach (G25.FloatType FT in S.m_floatTypes) {
string gmvName = FT.GetMangledName(S, S.m_GMV.Name);
%>
const char *c_str(const <%gmvName%> &obj, char *str, int maxLength, const char *fp = NULL);
std::string toString(const <%gmvName%> &obj, const char *fp = NULL);

inline const char *c_str_f(const <%gmvName%> &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%f");}
inline const char *c_str_e(const <%gmvName%> &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%e");}
inline const char *c_str_e20(const <%gmvName%> &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%2.20e");}

inline std::string toString_f(const <%gmvName%> &obj) {return toString(obj, "%f");}
inline std::string toString_e(const <%gmvName%> &obj) {return toString(obj, "%e");}
inline std::string toString_e20(const <%gmvName%> &obj) {return toString(obj, "%2.20e");}

<%}%>


${ENDCODEBLOCK}

// NAMESPACE = namespace like this "::c3ga::"   or ""
${CODEBLOCK MVtoStringHeader}
	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return <%NAMESPACE%>c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return <%NAMESPACE%>toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}
${ENDCODEBLOCK}

// S = Specification of algebra.
// STRING_PARAMETERS = list of parameters that determine output of toString and their default values.
${CODEBLOCK toStringSource}
/* 
These strings determine how the output of string() is formatted.
You can alter them at runtime using <%S.m_namespace%>_setStringFormat().
*/
<%for (int i = 0; i < STRING_PARAMETERS.Length; i++) {%> 
const char *<%S.m_namespace%>_string_<%STRING_PARAMETERS[i][0]%> = "<%STRING_PARAMETERS[i][1]%>";<%}%> 

void <%S.m_namespace%>_setStringFormat(const char *what, const char *format) {
<%for (int i = 0; i < STRING_PARAMETERS.Length; i++) {%> 
	<%if (i > 0) {%>else <%}%>if (!strcmp(what, "<%STRING_PARAMETERS[i][0]%>")) 
		<%S.m_namespace%>_string_<%STRING_PARAMETERS[i][0]%> = (format) ? format : "<%STRING_PARAMETERS[i][1]%>";<%}%>

}

<%foreach (G25.FloatType FT in S.m_floatTypes) {%>


<%if (FT != S.m_floatTypes[0]) {%>
const char *c_str(const <%FT.GetMangledName(S, S.m_GMV.Name)%> &V, char *str, int maxLength, const char *fp)
{
	<%S.m_floatTypes[0].GetMangledName(S, S.m_GMV.Name)%> tmp(V);
	return c_str(tmp, str, maxLength, fp);
}
std::string toString(const <%FT.GetMangledName(S, S.m_GMV.Name)%> &V)
{
	<%S.m_floatTypes[0].GetMangledName(S, S.m_GMV.Name)%> tmp(V);
	return toString(tmp);
}
<%}%>
<%}%>
#ifdef WIN32
#define snprintf _snprintf
#pragma warning(disable:4996) /* quit your whining already */
#endif /* WIN32 */
<%{const int TMP_BUF_LENGTH = 256; %>
const char *c_str(const <%S.m_floatTypes[0].GetMangledName(S, S.m_GMV.Name)%> &V, char *str, int maxLength, const char *fp) 
{
	int stdIdx = 0, l;
	char tmpBuf[<%TMP_BUF_LENGTH%>], tmpFloatBuf[<%TMP_BUF_LENGTH%>]; 
	int k = 0, bei, ia = 0, s = <%S.m_namespace%>_mvSize[V.gu()], p = 0, cnt = 0;
	const <%S.m_floatTypes[0].type%> *c = V.getC();

	// set up the floating point precision
	if (fp == NULL) fp = <%S.m_namespace%>_string_fp;

	// start the string
	l = snprintf(tmpBuf, <%TMP_BUF_LENGTH%>, "%s", <%S.m_namespace%>_string_start);
	if (stdIdx + l <= maxLength) {
		strcpy(str + stdIdx, tmpBuf);
		stdIdx += l;
	}
	else {
		snprintf(str, maxLength, "toString_<%S.m_floatTypes[0].GetMangledName(S, S.m_GMV.Name)%>: buffer too small");
		return str;
	}

	// print all coordinates
	for (int i = 0; i <= <%S.m_GMV.NbGroups%>; i++) {
		if (V.gu() & (1 << i)) {
			for (int j = 0; j < <%S.m_namespace%>_groupSize[i]; j++) {
				<%S.m_floatTypes[0].type%> coord = (<%S.m_floatTypes[0].type%>)<%S.m_namespace%>_basisElementSignByIndex[ia] *c[k];
				/* goal: print [+|-]V.m_c[k][* basisVector1 ^ ... ^ basisVectorN] */			
				snprintf(tmpFloatBuf, <%TMP_BUF_LENGTH%>, fp, (double)fabs(coord)); // cast to double to force custom float types to Plain Old Data
				if (atof(tmpFloatBuf) != 0.0) {
					l = 0;

					// print [+|-]
					l += snprintf(tmpBuf + l, <%TMP_BUF_LENGTH%>-l, "%s", (coord >= 0.0) 
						? (cnt ? <%S.m_namespace%>_string_plus : "")
						: <%S.m_namespace%>_string_minus);
						
					// print obj.m_c[k]
					int dummyArg = 0; // prevents compiler warning on some platforms
					l += snprintf(tmpBuf + l, <%TMP_BUF_LENGTH%>-l, tmpFloatBuf, dummyArg);

					if (i) { // if not grade 0, print [* basisVector1 ^ ... ^ basisVectorN]
						l += snprintf(tmpBuf + l, <%TMP_BUF_LENGTH%>-l, "%s", <%S.m_namespace%>_string_mul);

						// print all basis vectors
						bei = 0;
						while (<%S.m_namespace%>_basisElements[ia][bei] >= 0) {
							l += snprintf(tmpBuf + l, <%TMP_BUF_LENGTH%>-l, "%s%s", (bei) ? <%S.m_namespace%>_string_wedge : "", 
							 <%S.m_namespace%>_basisVectorNames[<%S.m_namespace%>_basisElements[ia][bei]]);
							 bei++;
						}
					}

					// copy all to 'str'
					if (stdIdx + l <= maxLength) {
						strcpy(str + stdIdx, tmpBuf);
						stdIdx += l;
					}
					else {
						snprintf(str, maxLength, "toString_<%S.m_floatTypes[0].GetMangledName(S, S.m_GMV.Name)%>: buffer too small");
						return str;
					}
					cnt++;
				}
				k++; ia++;
			}
		}
		else ia += <%S.m_namespace%>_groupSize[i];
	}

    // if no coordinates printed: 0
	l = 0;
	if (cnt == 0) {
		l += snprintf(tmpBuf + l, <%TMP_BUF_LENGTH%>-l, "0");
	}

    // end the string
	l += snprintf(tmpBuf + l, <%TMP_BUF_LENGTH%>-l, "%s", <%S.m_namespace%>_string_end);
	if (stdIdx + l <= maxLength) {
		strcpy(str + stdIdx, tmpBuf);
		stdIdx += l;
		return str;
	}
	else {
		snprintf(str, maxLength, "toString(): buffer too small\n");
		return str;
	}
}
<%}%>

std::string toString(const <%S.m_floatTypes[0].GetMangledName(S, S.m_GMV.Name)%> & obj, const char *fp /* = NULL */) {
	std::string str;
	int strSize = 2048;
	while (strSize <= 1024 * 1024) {
		str.resize(strSize);
		c_str(obj, &(str[0]), strSize-1, fp);
		if (str.find("buffer too small") != std::string::npos) {
			strSize *= 2; // need larger buffer
			continue;
		}
		else break; // done
	}
	str.resize(strlen(&(str[0])));
	return str;
}

${ENDCODEBLOCK}

// S = specification
// FT = floatType
${CODEBLOCK GMVmemberVariables}
public:
	/// group/grade usage (a bitmap which specifies which groups/grades are stored in 'c', below).
	int m_gu; 
<%if (S.m_GMV.MemoryAllocationMethod == G25.GMV.MEM_ALLOC_METHOD.DYNAMIC) {%>
	/// the coordinates (array is allocated using realloc())
	<%FT.type%> *m_c; 
<%} else if (S.m_GMV.MemoryAllocationMethod == G25.GMV.MEM_ALLOC_METHOD.PARITY_PURE) {%>
	/// the coordinates (note: parity pure)
	<%FT.type%> m_c[<%S.m_GMV.NbCoordinates / 2%>]; 
<%} else if (S.m_GMV.MemoryAllocationMethod == G25.GMV.MEM_ALLOC_METHOD.FULL) {%>
	/// the coordinates
	<%FT.type%> m_c[<%S.m_GMV.NbCoordinates%>]; 
<%}%>
<%if (S.m_reportUsage) {%>
	/// Specialized multivector type. Used to report about non-optimized function usage.
	SMV_TYPE m_t; 
<%}%>
${ENDCODEBLOCK}


// className = mangled class name
// FT = floatType
${CODEBLOCK classFloatType}
	/// Floating point type used by <%className%> 
	typedef <%FT.type%> Float;
${ENDCODEBLOCK}


// S = specification
// className = mangled class name
// FT = floatType
${CODEBLOCK GMVconstructors}
<%{
string initStr = "";
bool dynMem = S.m_GMV.MemoryAllocationMethod == G25.GMV.MEM_ALLOC_METHOD.DYNAMIC;
bool repUsage = S.m_reportUsage;
if (dynMem || repUsage)
if (dynMem) initStr = " : " + "m_c(NULL), m_gu(0)";
%>
	/// Constructs a new <%className%> with value 0.
	inline <%className%>() <%initStr%> {set();}

	/// Copy constructor.
	inline <%className%>(const <%className%>&A) <%initStr%> {set(A);}

<%foreach (G25.FloatType otherFT in S.m_floatTypes) {
	 if (FT == otherFT) continue;%>
	/// Copies from <%otherFT.type%> to <%FT.type%>.
	inline <%className%>(const <%otherFT.GetMangledName(S, S.m_GMV.Name)%> &A) <%initStr%> {set(A);}	 
<%}%>

	/// Constructs a new <%className%> with scalar value 'scalar'.
	inline <%className%>(<%FT.type%> scalar) <%initStr%> {set(scalar);}

	/// Constructs a new <%className%> from compressed 'coordinates'.
	/// \param gu bitwise OR of the GRADEs or GROUPs that are non-zero.
	/// \param coordinates compressed coordinates.
	inline <%className%>(int gu, const <%FT.type%> *coordinates) <%initStr%> {set(gu, coordinates);}

<%foreach(G25.SMV smv in S.m_SMV) {
string smvClassName = FT.GetMangledName(S, smv.Name);%>
	/// Converts a <%smvClassName%> to a <%className%>.
	inline <%className%>(const <%smvClassName%>&A) <%initStr%> {set(A);}
<%}%>

<%if (S.m_GMV.MemoryAllocationMethod == G25.GMV.MEM_ALLOC_METHOD.DYNAMIC) {%>
	/// Destructor (frees dynamically allocated memory).
	~<%className%>() {if (m_c != NULL) free(m_c);}
<%}%>
<%}%>
${ENDCODEBLOCK}


// S = specification
// className = mangled class name
// FT = floatType
${CODEBLOCK GMVassignmentOps}
	/// Assignment operator (<%className%>).
	inline <%className%> &operator=(const <%className%> &A) {if (this != &A) {set(A);} return *this;}
	/// Assignment operator (<%FT.type%>).
	inline <%className%> &operator=(const <%FT.type%> &scalar) {set(scalar); return *this;}
	
<%foreach (G25.FloatType otherFT in S.m_floatTypes) {
	 if (FT == otherFT) continue;%>
	/// Copies from <%otherFT.type%> to <%FT.type%>.
	inline <%className%> &operator=(const <%otherFT.GetMangledName(S, S.m_GMV.Name)%> &A) {set(A); return *this;}	 
<%}%>
	
<%foreach(G25.SMV smv in S.m_SMV) {
string smvClassName = FT.GetMangledName(S, smv.Name);%>
	/// Assignment operator (<%className%>).
	inline <%className%> &operator=(const <%smvClassName%> &A) {set(A); return *this;}
<%}%>
${ENDCODEBLOCK}


// S = specification
// className = mangled class name
// FT = floatType
${CODEBLOCK GMVsetDecl}
	/// Sets this <%className%> to 0.
	void set();

	/// Copies the value of 'A' to this.
	void set(const <%className%> &A);

<%foreach (G25.FloatType otherFT in S.m_floatTypes) {
	 if (FT == otherFT) continue;%>
	/// Copies from <%otherFT.type%> to <%FT.type%>.
	void set(const <%otherFT.GetMangledName(S, S.m_GMV.Name)%> &A);
<%}%>
	
	/// Sets this <%className%> to scalar value 'scalar'.
	void set(<%FT.type%> scalar);

	/// Sets this <%className%> from compressed 'coordinates'.
	/// \param gu bitwise OR of the GRADEs or GROUPs that are non-zero.
	/// \param coordinates compressed coordinates.
	void set(int gu, const <%FT.type%> *coordinates);
	
<%foreach(G25.SMV smv in S.m_SMV) {
string smvClassName = FT.GetMangledName(S, smv.Name);%>
	/// Sets this <%className%> to the value of <%smvClassName%> A
	void set(const <%smvClassName%> &A);
<%}%>
${ENDCODEBLOCK}


// S = specification
// className = mangled class name
// gmv = gmv type
// FT = floatType
${CODEBLOCK GMVcompressDecl}
	/// Compresses this <%className%> by removing groups/grades with coordinates are smaller than epsilon.
	void compress(<%FT.type%> epsilon = <%FT.DoubleToString(S, 0.0)%>);
	/// Sets each entry in 'ptrs' to a pointer to the coordinates for the respective grade / group.
	/// \param ptrs Array of pointers to grades/groups. The pointers are set by this function.
	/// \param nulls When true, pointers are set to NULL for empty grades/groups; otherwise a pointer to an array filled with zeros is used.
	void expand(const <%FT.type%> *ptrs[<%gmv.NbGroups%>], bool nulls = true) const;
${ENDCODEBLOCK}


// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// gmv = general multivector (G25.GMV)
// className = mangled class name
${CODEBLOCK compressDecl}
/// Compresses coordinates 'c' into a new multivector.
/// \param c the coordinates (may already be partially compressed, see argument 'gu').
/// \param epsilon value with a abs magnitude < epsilon are considered to be 0.
/// \param gu optionally specifies which groups/grades are present in 'c'.
<%className%> <%className%>_compress(const <%FT.type%> *c, <%FT.type%> epsilon = <%FT.DoubleToString(S, 0.0)%>, int gu = <%((1 << gmv.NbGroups)-1)%>);
/// Compresses an array of coordinates/basis blade bitmaps into a new multivector.
<%className%> <%className%>_compress(int nbBlades, const unsigned int *bitmaps, const <%FT.type%> *coords);
${ENDCODEBLOCK}

// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// gmv = general multivector (G25.GMV)
// className = mangled class name
// fabsFunc = name of fabs function
${CODEBLOCK compressDef}

void <%className%>::compress(<%FT.type%> epsilon /*= <%FT.DoubleToString(S, 0.0)%>*/) {
	set(<%className%>_compress(m_c, epsilon, m_gu));
}

<%className%> <%className%>_compress(const <%FT.type%> *c, <%FT.type%> epsilon /*= <%FT.DoubleToString(S, 0.0)%>*/, int gu /*= <%((1 << gmv.NbGroups)-1)%>*/) {
	int i, j, ia = 0, ib = 0, f, s;
	int cgu = 0;
	<%FT.type%> cc[<%(1 << S.m_dimension)%>];

	// for all grade parts...
	for (i = 0; i < <%gmv.NbGroups%>; i++) {
		// check if grade part has memory use:
		if (!(gu & (1 << i))) continue;

		// check if abs coordinates of grade part are all < epsilon
		s = <%S.m_namespace%>_groupSize[i];
		j = ia + s;
		f = 0;
		for (; ia < j; ia++)
			if (<%fabsFunc%>(c[ia]) > epsilon) {f = 1; break;}
		ia = j;
		if (f) {
<%if (gmv.MemoryAllocationMethod == G25.GMV.MEM_ALLOC_METHOD.PARITY_PURE) {%>
			if ((ib+s) > <%1<<(S.m_dimension-1)%>) break; // when this 'break' happens, the input is not parity pure
<%}%>
			<%G25.CG.Shared.Util.GetCopyCode(S, FT, "c + ia - s", "cc + ib", "s")%>
			ib += s;
			cgu |= (1 << i);
		}
	}
	
	return <%className%>(cgu, cc);
}

<%className%> <%className%>_compress(int nbBlades, const unsigned int *bitmaps, const <%FT.type%> *coords) {
	// convert basis blade compression to regular coordinate array:
	<%FT.type%> A[<%(1 << S.m_dimension)%>];
	for (int i = 0; i < <%(1 << S.m_dimension)%>; i++) A[i] = <%FT.DoubleToString(S, 0.0)%>;

	for (int i = 0; i < nbBlades; i++) {
		A[<%S.m_namespace%>_basisElementIndexByBitmap[bitmaps[i]]] = coords[i] * (<%FT.type%>)<%S.m_namespace%>_basisElementSignByBitmap[bitmaps[i]];		
	}

	return <%className%>_compress(A);
}


void <%className%>::expand(const <%FT.type%> *ptrs[<%S.m_GMV.NbGroups%>], bool nulls /* = true */) const {
	const <%FT.type%> *c = m_c; // this pointer gets incremented below
	
<%for (int i = 0; i < gmv.NbGroups; i++) {%>
	if (m_gu & <%1 << i%>) {
		ptrs[<%i%>] =  c;
<%if (i != (gmv.NbGroups-1)) {%>
		c += <%gmv.Group(i).Length%>;
<%}%>
	}
	else ptrs[<%i%>] = (nulls) ? NULL : nullFloats();
<%}%>
}

${ENDCODEBLOCK}



// FT = floatType
${CODEBLOCK GMVlargestCoordinateDecl}
	/// returns the absolute largest coordinate.
	<%FT.type%> largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap (in 'bm').
	<%FT.type%> largestBasisBlade(unsigned int &bm) const;
${ENDCODEBLOCK}

// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// gmvName = name of GMV struct
// fabsFunc = name of floating point absolute function
${CODEBLOCK GMVlargestCoordinateDef}
<%FT.type%> <%gmvName%>::largestCoordinate() const {
	<%FT.type%> maxValue = <%FT.DoubleToString(S, 0.0)%>;
	int nbC = <%S.m_namespace%>_mvSize[m_gu], i;
	for (i = 0; i < nbC; i++)
		if (<%fabsFunc%>(m_c[i]) > maxValue) maxValue = <%fabsFunc%>(m_c[i]);
	return maxValue;
}

<%FT.type%> <%gmvName%>::largestBasisBlade(unsigned int &bm) const {
	int nc = <%S.m_namespace%>_mvSize[gu()];
	<%FT.type%> maxC = <%FT.DoubleToString(S, -1.0)%>, C;

	int idx = 0;
	int group = 0;
	int i = 0;
	
	bm = 0;

	while (i < nc) {
		if (gu() & (1 << group)) {
			for (int j = 0; j < <%S.m_namespace%>_groupSize[group]; j++) {
				C = <%fabsFunc%>(m_c[i]);
				if (C > maxC) {
					maxC = C;
					bm = <%S.m_namespace%>_basisElementBitmapByIndex[idx];
				}
				idx++;
				i++;
			}
		}
		else idx += <%S.m_namespace%>_groupSize[group];
		group++;
	}

	return maxC;
} // end of <%gmvName%>::largestBasisBlade()


${ENDCODEBLOCK}


// S = specification
// gmv = gmv type
// FT = floatType
${CODEBLOCK GMVsetGroupUsage}
public:
	/// Set m_gu, reallocates m_c to the size required by gu
	inline void setGroupUsage(int gu) {
		if (m_gu == gu) return;
		m_gu = gu;
<%if (gmv.MemoryAllocationMethod == G25.GMV.MEM_ALLOC_METHOD.DYNAMIC) {%>
		int nbCoords = <%S.m_namespace%>_mvSize[m_gu];
		if (nbCoords > 0)
			m_c = (<%FT.type%>*)realloc(m_c, nbCoords * sizeof(<%FT.type%>));
<%}%>
	}
${ENDCODEBLOCK}

// S = specification
// gmv = gmv type
// FT = floatType
${CODEBLOCK GMVallocateGroups}
<%for (int groupIdx = 0; groupIdx < gmv.NbGroups; groupIdx++) { %>
	/**
	Allocates memory for coordinate GROUP_<%groupIdx%>.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_<%groupIdx%>() {
		if ((m_gu & <%(1 << groupIdx)%>) == 0) {
			const int groupUsageBelow = m_gu & <%((1 << groupIdx) - 1)%>;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | <%(1 << groupIdx)%>;
			const int newGroupUsageBelowNextGroup = newGroupUsage & <%((1 << (groupIdx + 1)) - 1)%>;

			setGroupUsage(newGroupUsage);

<%if (groupIdx < (gmv.NbGroups-1)) { %>
			// move coordinate beyond new group
			<%FT.type%> *dst = m_c + <%S.m_namespace%>_mvSize[newGroupUsageBelowNextGroup];
			<%FT.type%> *src = m_c + <%S.m_namespace%>_mvSize[groupUsageBelow];
			for (int i = <%S.m_namespace%>_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];
<%}%>

			// set coordinates of new group to 0
			<%FT.type%> *ptr = m_c + <%S.m_namespace%>_mvSize[groupUsageBelow];
			<%for (int i = 0; i < gmv.Group(groupIdx).Length; i++) {%>ptr[<%i%>] = <%}%><%FT.DoubleToString(S, 0.0)%>;
		}
	}
<%}%>
${ENDCODEBLOCK}


// S = specification
// smv = smv class
// className = mangled class name
// gmvClassName = mangled class name of GMV
// FT = floatType
${CODEBLOCK SMVconstructors}
	/// Constructs a new <%className%> with variable coordinates set to 0.
	inline <%className%>() {set();}

	/// Copy constructor.
	inline <%className%>(const <%className%> &A) {set(A);}

<%foreach (G25.FloatType otherFT in S.m_floatTypes) {
	 if (FT == otherFT) continue;%>
	/// Copies from <%otherFT.type%> to <%FT.type%>.
	inline <%className%>(const <%otherFT.GetMangledName(S, smv.Name)%> &A) {set(A);} 
<%}%>

<%if (smv.GetElementIdx(RefGA.BasisBlade.ONE) >= 0) {%>
	/// Constructs a new <%className%> with scalar value 'scalar'.
	inline <%className%>(<%FT.type%> scalar) {set(scalar);}
<%}%>

	/// Constructs a new <%className%> from <%gmvClassName%>.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline <%className%>(<%gmvClassName%> &A, int filler) {set(A);}

<%if (smv.NbNonConstBasisBlade > 0) {%>
	/// Constructs a new <%className%>. Coordinate values come from 'A'.
	inline <%className%>(const CoordinateOrder co, const <%FT.type%> A[<%smv.NbNonConstBasisBlade%>]) {set(co, A);}
	
	/// Constructs a new <%className%> with each coordinate specified.
	inline <%className%>(const CoordinateOrder co, <%for (int i = 0; i < smv.NbNonConstBasisBlade; i++) {%><%if (i > 0) {%>,<%}%> <%FT.type%> <%smv.NonConstBasisBlade(i).ToLangString(S.m_basisVectorNames)%><%}%>) {
		set(co<%for (int i = 0; i < smv.NbNonConstBasisBlade; i++) {%>, <%smv.NonConstBasisBlade(i).ToLangString(S.m_basisVectorNames)%><%}%>);
	}
<%}%>
${ENDCODEBLOCK}

// S = specification
// smv = smv type
// className = mangled class name
// gmvClassName = mangled class name of GMV
// FT = floatType
${CODEBLOCK SMVassignmentOps}
	/// Assignment operator (<%className%>).
	inline <%className%> &operator=(const <%className%> &A) {if (this != &A) {set(A);} return *this;}
	
<%foreach (G25.FloatType otherFT in S.m_floatTypes) {
	 if (FT == otherFT) continue;%>
	/// Copies from <%otherFT.type%> to <%FT.type%>.
	inline <%className%> &operator=(const <%otherFT.GetMangledName(S, smv.Name)%> &A) {set(A); return *this;}	 
<%}%>
		
<%if (smv.GetElementIdx(RefGA.BasisBlade.ONE) >= 0) {%>
	/// Assignment operator (<%FT.type%>).
	inline <%className%> &operator=(const <%FT.type%> &scalar) {set(scalar); return *this;}
<%}%>

	/// Assignment operator (<%gmvClassName%>).
	inline <%className%> &operator=(const <%gmvClassName%> &A) {set(A); return *this;}
${ENDCODEBLOCK}

// S = specification
// smv = smv class
// className = mangled class name
// gmvClassName = mangled class name of GMV
// FT = floatType
${CODEBLOCK SMVsetDecl}

	/// Sets variable coordinates of 'this' to 0.
	<%if (smv.NbNonConstBasisBlade == 0) {%>inline <%}%>void set()<%if (smv.NbNonConstBasisBlade == 0) {%> {}<%} else {%>;<%}%>

	/// Sets this to 'A'.
	void set(const <%className%> &A);

<%if (smv.GetElementIdx(RefGA.BasisBlade.ONE) >= 0) {%>
	/// Sets this to scalar value 'scalar'.
	void set(<%FT.type%> scalar);
<%}%>

	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const <%gmvClassName%> &A);

<%foreach (G25.FloatType otherFT in S.m_floatTypes) {
	 if (FT == otherFT) continue;%>
	/// Copies from <%otherFT.type%> to <%FT.type%>.
	void set(const <%otherFT.GetMangledName(S, smv.Name)%> &A);
<%}%>

<%if (smv.NbNonConstBasisBlade > 0) {%>
	/// Sets this to 'A'.
	void set(const CoordinateOrder, const <%FT.type%> A[<%smv.NbNonConstBasisBlade%>]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder, <%for (int i = 0; i < smv.NbNonConstBasisBlade; i++) {%><%if (i > 0) {%>,<%}%> <%FT.type%> <%smv.NonConstBasisBlade(i).ToLangString(S.m_basisVectorNames)%><%}%>);
<%}%>
${ENDCODEBLOCK}

// FT = floatType
${CODEBLOCK SMVlargestCoordinate}
	/// returns the absolute largest coordinate.
	<%FT.type%> largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	<%FT.type%> largestBasisBlade(unsigned int &bm) const;
	
${ENDCODEBLOCK}

// S = specification
// className = mangled class name
// rangeVectorSMVname = name of range vector type
// FT = floatType
${CODEBLOCK GOMconstructors}
	/// Constructs a new <%className%>, set to identity
	inline <%className%>() { setIdentity(); }

	/// Copy constructor.
	inline <%className%>(const <%className%>&M) { set(M); }

	/// Constructor from matrix
	inline <%className%>(const <%FT.type%> *M) { set(M); }

	/// Constructor from images of basis vectors.
	inline <%className%>(<%for (int i = 0; i < S.m_dimension; i++) {%><%if (i > 0) {%>, <%}%>const <%rangeVectorSMVname%> &i<%S.m_basisVectorNames[i]%><%}%>)
		{ set(<%for (int i = 0; i < S.m_dimension; i++) {%><%if (i > 0) {%>, <%}%>i<%S.m_basisVectorNames[i]%><%}%>); }

<%foreach(G25.SOM som in S.m_SOM) {
string somClassName = FT.GetMangledName(S, som.Name);%>
	/// Converts a <%somClassName%> to a <%className%>.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	inline <%className%>(const <%somClassName%> &M) { set(M); }
	
<%}%>
${ENDCODEBLOCK}

// S = specification
// className = mangled class name
// FT = floatType
${CODEBLOCK GOMassignmentOps}
	/// Sets this to 'M'
	inline <%className%> &operator=(const <%className%> &M) { if (this != &M) { set(M); } return *this; }

<%foreach(G25.SOM som in S.m_SOM) {
string somClassName = FT.GetMangledName(S, som.Name);%>
	/// Sets this <%className%> to <%somClassName%>.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	inline <%className%> &operator=(const <%somClassName%> &M) { set(M); return *this; }
	
<%}%>
${ENDCODEBLOCK}

// S = specification
// className = mangled class name
// rangeVectorSMVname = name of range vector type
// FT = floatType
${CODEBLOCK GOMsetDecl}
	/// Sets this <%className%> to identity.
	void setIdentity();

	/// Sets this to 'M'.
	void set(const <%className%> &M);

	/// Sets this to matrix.
	void set(const <%FT.type%> *M);

	/// Sets this to transformation specified by the images of the basis vectors.
	void set(<%for (int i = 0; i < S.m_dimension; i++) {%><%if (i > 0) {%>, <%}%>const <%rangeVectorSMVname%> &i<%S.m_basisVectorNames[i]%><%}%>);

<%foreach(G25.SOM som in S.m_SOM) {
string somClassName = FT.GetMangledName(S, som.Name);%>
	/// Sets this <%className%> to a <%somClassName%>.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	void set(const <%somClassName%> &M);
	
<%}%>
${ENDCODEBLOCK}











// S = specification
// som = G25.SOM
// className = mangled class name
// gomClassName = mangled name of GOM class (can be "")
// rangeVectorSMVname = name of range vector type
// FT = floatType
${CODEBLOCK SOMconstructors}
	/// Constructs a new <%className%>, set to identity
	inline <%className%>() { setIdentity(); }

	/// Copy constructor.
	inline <%className%>(const <%className%>&M) { set(M); }

	/// Constructor from matrix
	inline <%className%>(const <%FT.type%> *M) { set(M); }

	/// Constructor from matrix
	inline <%className%>(const <%FT.type%> *M, bool transposed) { if (transposed) { setTranspose(M); } else { set(M); } }
	
	/// Constructor from images of basis vectors.
	inline <%className%>(<%for (int i = 0; i < som.DomainVectors.Length; i++) {%><%if (i > 0) {%>, <%}%>const <%rangeVectorSMVname%> &i<%som.DomainVectors[i].ToLangString(S.m_basisVectorNames)%><%}%>)
		{ set(<%for (int i = 0; i < som.DomainVectors.Length; i++) {%><%if (i > 0) {%>, <%}%>i<%som.DomainVectors[i].ToLangString(S.m_basisVectorNames)%><%}%>); }

<%if (gomClassName.Length > 0) {%>
	/// Converts a <%gomClassName%> to a <%className%>.
	/// Warning: coordinates which cannot be represented are silenty lost
	inline <%className%>(const <%gomClassName%> &M) { set(M); }
<%}%>
${ENDCODEBLOCK}

// S = specification
// className = mangled class name
// gomClassName = mangled name of GOM class (can be "")
// FT = floatType
${CODEBLOCK SOMassignmentOps}
	/// Sets this to 'M'
	inline <%className%> &operator=(const <%className%> &M) { if (this != &M) { set(M); } return *this; }

<%if (gomClassName.Length > 0) {%>
	/// Sets this <%gomClassName%> to a <%className%>.
	/// Warning: coordinates which cannot be represented are silenty lost
	inline <%className%> &operator=(const <%gomClassName%> &M) { set(M); return *this; }
	
<%}%>
${ENDCODEBLOCK}

// S = specification
// className = mangled class name
// gomClassName = mangled name of GOM class (can be "")
// rangeVectorSMVname = name of range vector type
// FT = floatType
${CODEBLOCK SOMsetDecl}
	/// Sets this <%className%> to identity.
	void setIdentity();

	/// Sets this to 'M'.
	void set(const <%className%> &M);

	/// Sets this to matrix.
	void set(const <%FT.type%> *M);

	/// Sets this to transposed matrix.
	void setTranspose(const <%FT.type%> *M);
	
	/// Sets this to transformation specified by the images of the basis vectors.
	void set(<%for (int i = 0; i < som.DomainVectors.Length; i++) {%><%if (i > 0) {%>, <%}%>const <%rangeVectorSMVname%> &i<%som.DomainVectors[i].ToLangString(S.m_basisVectorNames)%><%}%>);

<%if (gomClassName.Length > 0) {%>
	/// Sets this <%className%> to a <%gomClassName%>.
	/// Warning: coordinates which cannot be represented are silenty lost
	void set(const <%gomClassName%> &M);
	
<%}%>
${ENDCODEBLOCK}













// functionName = name of generated function
// pointType = multivector type name (with prefix/suffix)
// FT = floating point type
${CODEBLOCK randomCgaPointHeader}
/** Returns a random conformal point where the coordinates lie in the interval [-scale, scale). */
<%pointType%> <%functionName%>(<%FT.type%> scale);
${ENDCODEBLOCK}

// S = Specification of algebra.
// functionName = name of generated function
// pointType = multivector type name (with prefix/suffix)
// FT = floating point type
// randomScalarFuncName = name of function which generates random scalar values
// cgaPointFunc = function for computing a point from coordinates
${CODEBLOCK randomCgaPoint}
<%if (S.m_inlineFunctions) {%>inline <%}%><%pointType%> <%functionName%>(<%FT.type%> scale) {
<%for (int i = 0; i < S.m_dimension-2; i++) {%>	<%FT.type%> ce<%(i+1).ToString()%> = scale * (<%FT.DoubleToString(S, -1.0)%> + <%FT.DoubleToString(S, 2.0)%> * <%randomScalarFuncName%>());
<%}%>
	return <%cgaPointFunc%>(<%for (int i = 0; i < S.m_dimension-2; i++) {%><%if (i > 0){%>, <%}%>ce<%(i+1).ToString()%><%}%>);
}
${ENDCODEBLOCK}

// S = Specification of algebra.
// FT = floatType
${CODEBLOCK CustomParserHeader}

/** structure used by custom parser */
struct <%S.m_namespace%><%FT.GetMangledName(S, "ParseMultivectorData")%> {
	/** the parsed value */
	<%FT.GetMangledName(S, S.m_GMV.Name)%> value;
	/** this string will contain an error message when error is true */
	char message[256];
};

/** 
Parses 'str' (output of toString_<%FT.GetMangledName(S, S.m_GMV.Name)%>()) and stores result in 'val' 
Throws std::string on error.
*/
<%FT.GetMangledName(S, S.m_GMV.Name)%> parse(const std::string &str);

/** 
Parses 'str' (output of toString_<%FT.GetMangledName(S, S.m_GMV.Name)%>()) and stores result in 'data'. 
'strSourceName' is the name of the source of 'str' (for example, a filename).
It is used for error messages.

	Returns true when 'str' parsed correctly.
Otherwise a lexer or parser error occured and you can check 
the errors in 'data->message'.
*/
bool parseEx(struct <%S.m_namespace%><%FT.GetMangledName(S, "ParseMultivectorData")%> &data, const std::string &str, const std::string &strSourceName);
${ENDCODEBLOCK}


// S = Specification of algebra.
// FT = floatType
${CODEBLOCK ANTLRparserHeader_outsideNamespace}
/** structure used by ANTLR parser */
struct <%S.m_namespace%><%FT.GetMangledName(S, "ParseBasisBladeData")%> {
	/** internal: intermediate scale info (used while parsing basis element) */
	<%FT.type%> scale;
	/** internal: intermediate bitmap info (used while parsing basis element) */
	unsigned int bitmap;
};

/** structure used by ANTLR parser */
struct <%S.m_namespace%><%FT.GetMangledName(S, "ParseMultivectorData")%> {
	/** the parsed value */
	<%S.m_namespace%>::<%FT.GetMangledName(S, S.m_GMV.Name)%> value;
	/** this string will contain an error message when error is true */
	char message[256];
};

/** wedges 'bv' to the basis blade in 'BB' */
void <%S.m_namespace%><%FT.GetMangledName(S, "ParseWedgeBasisVector")%>(const char *bv, struct <%S.m_namespace%><%FT.GetMangledName(S, "ParseBasisBladeData")%> *BB); 

/** adds 'scale*BB' to PD */
void <%S.m_namespace%><%FT.GetMangledName(S, "ParseSum")%>(<%FT.type%> coord[<%1<<S.m_dimension%>], <%FT.type%> scale, const struct <%S.m_namespace%><%FT.GetMangledName(S, "ParseBasisBladeData")%> *BB); 

/** initializes a struct <%S.m_namespace%><%FT.GetMangledName(S, "ParseMultivectorData")%>, making it ready for use */
void <%S.m_namespace%><%FT.GetMangledName(S, "ParseDataInit")%>(struct <%S.m_namespace%><%FT.GetMangledName(S, "ParseMultivectorData")%> *PD); 
${ENDCODEBLOCK}

// S = Specification of algebra.
// FT = floatType
${CODEBLOCK ANTLRparserHeader}

/** 
Parses 'str' (output of toString_<%FT.GetMangledName(S, S.m_GMV.Name)%>()) and stores result in 'val' 
Throws std::string on error.
*/
<%FT.GetMangledName(S, S.m_GMV.Name)%> parse(const std::string &str);

/** 
Parses 'str' (output of toString_<%FT.GetMangledName(S, S.m_GMV.Name)%>()) and stores result in 'data'. 
'strSourceName' is the name of the source of 'str' (for example, a filename).
It is used for error messages.

Returns true when 'str' parsed correctly.
Otherwise a lexer or parser error occured and you can check 
the errors in 'data->message'.
*/
bool parseEx(struct <%S.m_namespace%><%FT.GetMangledName(S, "ParseMultivectorData")%> &data, const std::string &str, const std::string &strSourceName);
${ENDCODEBLOCK}



// S = Specification of algebra.
${CODEBLOCK mersenneTwisterHeader}
#ifndef _MT_<%S.m_namespace.ToUpper()%>_H_
#define _MT_<%S.m_namespace.ToUpper()%>_H_

/** initializes mt[N] with a seed */
void init_genrand(unsigned long s);
/** generates a random number on [0,0xffffffff]-interval */
unsigned long genrand_int32(void);
/** generates a random number on [0,0x7fffffff]-interval */
long genrand_int31(void);
/** generates a random number on [0,1]-real-interval */
double genrand_real1(void);
/** generates a random number on [0,1)-real-interval */
double genrand_real2(void);
/** generates a random number on (0,1)-real-interval */
double genrand_real3(void);
/** generates a random number on [0,1) with 53-bit resolution*/
double genrand_res53(void);

#endif /* _MT_<%S.m_namespace.ToUpper()%>_H_ */
${ENDCODEBLOCK}


// S = Specification of algebra.
${CODEBLOCK mersenneTwisterSource}
/* 
   A C-program for MT19937, with initialization improved 2002/1/26.
   Coded by Takuji Nishimura and Makoto Matsumoto.

   Before using, initialize the state by using init_genrand(seed)  
   or init_by_array(init_key, key_length).

   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
   All rights reserved.                          

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

     3. The names of its contributors may not be used to endorse or promote 
        products derived from this software without specific prior written 
        permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


   Any feedback is very welcome.
   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)
*/

#include <stdio.h>



/* Period parameters */  
#define N 624
#define M 397
#define MATRIX_A 0x9908b0dfUL   /* constant vector a */
#define UPPER_MASK 0x80000000UL /* most significant w-r bits */
#define LOWER_MASK 0x7fffffffUL /* least significant r bits */

static unsigned long mt[N]; /* the array for the state vector  */
static int mti=N+1; /* mti==N+1 means mt[N] is not initialized */

/* initializes mt[N] with a seed */
void init_genrand(unsigned long s)
{
    mt[0]= s & 0xffffffffUL;
    for (mti=1; mti<N; mti++) {
        mt[mti] = 
	    (1812433253UL * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti); 
        /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
        /* In the previous versions, MSBs of the seed affect   */
        /* only MSBs of the array mt[].                        */
        /* 2002/01/09 modified by Makoto Matsumoto             */
        mt[mti] &= 0xffffffffUL;
        /* for >32 bit machines */
    }
}

/* initialize by an array with array-length */
/* init_key is the array for initializing keys */
/* key_length is its length */
/* slight change for C++, 2004/2/26 */
void init_by_array(unsigned long init_key[], int key_length)
{
    int i, j, k;
    init_genrand(19650218UL);
    i=1; j=0;
    k = (N>key_length ? N : key_length);
    for (; k; k--) {
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525UL))
          + init_key[j] + j; /* non linear */
        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
        i++; j++;
        if (i>=N) { mt[0] = mt[N-1]; i=1; }
        if (j>=key_length) j=0;
    }
    for (k=N-1; k; k--) {
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941UL))
          - i; /* non linear */
        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
        i++;
        if (i>=N) { mt[0] = mt[N-1]; i=1; }
    }

    mt[0] = 0x80000000UL; /* MSB is 1; assuring non-zero initial array */ 
}

/* generates a random number on [0,0xffffffff]-interval */
unsigned long genrand_int32(void)
{
    unsigned long y;
    static unsigned long mag01[2]={0x0UL, MATRIX_A};
    /* mag01[x] = x * MATRIX_A  for x=0,1 */

    if (mti >= N) { /* generate N words at one time */
        int kk;

        if (mti == N+1)   /* if init_genrand() has not been called, */
            init_genrand(5489UL); /* a default initial seed is used */

        for (kk=0;kk<N-M;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        for (;kk<N-1;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);
        mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1UL];

        mti = 0;
    }
  
    y = mt[mti++];

    /* Tempering */
    y ^= (y >> 11);
    y ^= (y << 7) & 0x9d2c5680UL;
    y ^= (y << 15) & 0xefc60000UL;
    y ^= (y >> 18);

    return y;
}

/* generates a random number on [0,0x7fffffff]-interval */
long genrand_int31(void)
{
    return (long)(genrand_int32()>>1);
}

/* generates a random number on [0,1]-real-interval */
double genrand_real1(void)
{
    return genrand_int32()*(1.0/4294967295.0); 
    /* divided by 2^32-1 */ 
}

/* generates a random number on [0,1)-real-interval */
double genrand_real2(void)
{
    return genrand_int32()*(1.0/4294967296.0); 
    /* divided by 2^32 */
}

/* generates a random number on (0,1)-real-interval */
double genrand_real3(void)
{
    return (((double)genrand_int32()) + 0.5)*(1.0/4294967296.0); 
    /* divided by 2^32 */
}

/* generates a random number on [0,1) with 53-bit resolution*/
double genrand_res53(void) 
{ 
    unsigned long a=genrand_int32()>>5, b=genrand_int32()>>6; 
    return(a*67108864.0+b)*(1.0/9007199254740992.0); 
} 
/* These real versions are due to Isaku Wada, 2002/01/09 added */

${ENDCODEBLOCK}

${CODEBLOCK seriesDecl}
/** Computes <%mathFuncName%> of <%inputType%>.
<%userComment%> */
<%returnType%> <%funcName%>(const <%inputType%> &x, int order = 12);
${ENDCODEBLOCK}

// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesExp}

<%returnType%> <%funcName%>(const <%inputType%> &x, int order /*  = 12 */) {
	unsigned long maxC;
	int scale = 1;
	<%inputType%> xScaled;
	<%returnType%> tmp1, tmp2; // temp <%returnType%> used for various purposes
	<%returnType%> xPow1, xPow2;
	<%returnType%> *result1 = &tmp1, *result2 = &tmp2;
	<%FT.type%> s_x2, a;
	int i;
   
	// First try special cases: check if (x * x) is scalar
	tmp1 = <%gpFuncII%>(x, x);
	s_x2 = _<%FT.type%>(tmp1);
	if ((<%normE2funcR%>(tmp1) - s_x2 * s_x2) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
		// OK (x * x == ~scalar), so use special cases:
		if (s_x2 < <%FT.DoubleToString(S, 0.0)%>) {
			a = <%sqrtFunc%>(-s_x2);
			return <%SASfuncI%>(x, <%sinFunc%>(a) / a, <%cosFunc%>(a));
		}
		else if (s_x2 > <%FT.DoubleToString(S, 0.0)%>) {
			a = <%sqrtFunc%>(s_x2);
			return <%SASfuncI%>(x, <%sinhFunc%>(a) / a, <%coshFunc%>(a));
		}
		else {
			return <%SASfuncI%>(x, <%FT.DoubleToString(S, 1.0)%>, <%FT.DoubleToString(S, 1.0)%>);
		}
	}

	// else do general series eval . . .

	// result = 1 + ....	
	*result1 = <%FT.DoubleToString(S, 1.0)%>;
	if (order == 0) return *result1;

	// find scale (power of 2) such that its norm is < 1
	maxC = (unsigned long)x.largestCoordinate(); // unsigned type is fine, because largest coordinate is absolute
	scale = 1;
	if (maxC > 1) scale <<= 1;
	while (maxC)
	{
		maxC >>= 1;
		scale <<= 1;
	}

	// scale
	xScaled = <%gpFuncIdouble%>(x, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)scale); 

	// taylor series approximation
	xPow1 = <%FT.DoubleToString(S, 1.0)%>; 
	for (i = 1; i <= order; i++) {
		xPow2 = <%gpFuncRI%>(xPow1, xScaled);
		xPow1 = <%gpFuncRdouble%>(xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i);
		
		*result2 = <%addFuncRR%>(*result1, xPow1); // result2 = result1 + xPow1
		std::swap(result1, result2); // result is always in 'result1' at end of loop
    }

	// undo scaling
	while (scale > 1)
	{
		*result2 = <%gpFuncRR%>(*result1, *result1);
		std::swap(result1, result2); // result is always in 'result1' at end of loop
		scale >>= 1;
	}
    
    return *result1;
} // end of <%funcName%>()

${ENDCODEBLOCK}


// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesSinh}
<%returnType%> <%funcName%>(const <%inputType%> &x, int order /*  = 12 */) {
	<%returnType%> tmp1, tmp2; // temp <%returnType%> used for various purposes
	<%returnType%> xPow1, xPow2; // xScaled^... goes here
	<%returnType%> *result1 = &tmp1, *result2 = &tmp2;
	<%FT.type%> s_x2, a;
	int i;
   
	// First try special cases: check if (x * x) is scalar
	tmp1 = <%gpFuncII%>(x, x);
	s_x2 = _<%FT.type%>(tmp1);
	if ((<%normE2funcR%>(tmp1) - s_x2 * s_x2) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
		// OK (x * x == ~scalar), so use special cases:
		if (s_x2 < <%FT.DoubleToString(S, 0.0)%>) {
			a = <%sqrtFunc%>(-s_x2);
			return <%SASfuncI%>(x, <%sinFunc%>(a) / a, <%FT.DoubleToString(S, 0.0)%>);
		}
		else if (s_x2 > <%FT.DoubleToString(S, 0.0)%>) {
			a = <%sqrtFunc%>(s_x2);
			return <%SASfuncI%>(x, <%sinhFunc%>(a) / a, <%FT.DoubleToString(S, 0.0)%>);
		}
		else {
<%if ((returnType != inputType) && (returnType != FT.GetMangledName(S, S.m_GMV.Name))) {%>
			return <%copyInputToReturnFunc%>(x);
<%} else {%>
			return x;
<%}%>
		}
	}

	// else do general series eval . . .

	// result = A +  A^3/3! + A^5/5!
	result1->set(); // result = 0
    if (order == 0) return *result1;
    	
	// taylor series approximation
	xPow1 = <%FT.DoubleToString(S, 1.0)%>;
	for (i = 1; i <= order; i++) {
		xPow2 = <%gpFuncRI%>(xPow1, x); // xPow2 = xPow1 * x
		xPow1 = <%gpFuncRdouble%>(xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i); // xPow1 = xScaled^i / i! 
		
		if ((i % 2) == 1) {
			*result2 = <%addFuncRR%>(*result1, xPow1); 
			std::swap(result1, result2); 
		}
	}

    return *result1;
} // end of <%funcName%>()
${ENDCODEBLOCK}

// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesCosh}

<%returnType%> <%funcName%>(const <%inputType%> &x, int order) {
	<%returnType%> tmp1, tmp2; // temp <%returnType%> used for various purposes
	<%returnType%> xPow1, xPow2; // xScaled^... goes here
	<%returnType%> *result1 = &tmp1, *result2 = &tmp2;
	<%FT.type%> s_x2;
	int i;
   
	// First try special cases: check if (x * x) is scalar
	tmp1 = <%gpFuncII%>(x, x);
	s_x2 = _<%FT.type%>(tmp1);
	if ((<%normE2funcR%>(tmp1) - s_x2 * s_x2) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
		// OK (x * x == ~scalar), so use special cases:
		if (s_x2 > <%FT.DoubleToString(S, 0.0)%>) {
			return <%returnType%>(<%coshFunc%>(<%sqrtFunc%>(s_x2)));
		}
		else if (s_x2 < <%FT.DoubleToString(S, 0.0)%>) {
			return <%returnType%>(<%cosFunc%>(<%sqrtFunc%>(-s_x2)));
		}
		else {
			return <%returnType%>(<%FT.DoubleToString(S, 1.0)%>);
		}
	}

	// else do general series eval . . .


	*result1 = <%FT.DoubleToString(S, 1.0)%>;
	if (order == 0) return *result1;

	// taylor series approximation
	xPow1 = <%FT.DoubleToString(S, 1.0)%>;
	for (i = 1; i <= order; i++) {
		xPow2 = <%gpFuncRI%>(xPow1, x);
		xPow1 = <%gpFuncRdouble%>(xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i); // xPow1 = xScaled^i / i! 
		
		if ((i % 2) == 0) {
			*result2 = <%addFuncRR%>(*result1, xPow1); 
			std::swap(result1, result2); // result is always in 'result1' at end of loop		
		}
    }

    return *result1;
} // end of <%funcName%>()
${ENDCODEBLOCK}


// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesSin}

<%returnType%> <%funcName%>(const <%inputType%> &x, int order) {
	<%returnType%> tmp1, tmp2; // temp <%returnType%> used for various purposes
	<%returnType%> xPow1, xPow2; // xScaled^... goes here
	<%returnType%> *result1 = &tmp1, *result2 = &tmp2;
	<%FT.type%> s_x2, a;
	int i;
   
	// First try special cases: check if (x * x) is scalar
	tmp1 = <%gpFuncII%>(x, x);
	s_x2 = _<%FT.type%>(tmp1);
	if ((<%normE2funcR%>(tmp1) - s_x2 * s_x2) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
		// OK (x * x == ~scalar), so use special cases:
		if (s_x2 < <%FT.DoubleToString(S, 0.0)%>) {
			a = <%sqrtFunc%>(-s_x2);
			return <%SASfuncI%>(x, <%sinhFunc%>(a) / a, <%FT.DoubleToString(S, 0.0)%>);
		}
		else if (s_x2 > <%FT.DoubleToString(S, 0.0)%>) {
			a = <%sqrtFunc%>(s_x2);
			return <%SASfuncI%>(x, <%sinFunc%>(a) / a, <%FT.DoubleToString(S, 0.0)%>);
		}
		else {
<%if ((returnType != inputType) && (returnType != FT.GetMangledName(S, S.m_GMV.Name))) {%>
			return <%copyInputToReturnFunc%>(x);
<%} else {%>
			return x;
<%}%>
		}
	}

	// else do general series eval . . .

	// result = A -  ....	+ ... - ...
	result1->set(); // result1 = 0;
    if (order == 0) return *result1;
    	
	// taylor series approximation
	xPow1 = <%FT.DoubleToString(S, 1.0)%>; // xPow1 = 1.0
	for (i = 1; i <= order; i++) {
		xPow2 = <%gpFuncRI%>(xPow1, x); // xPow2 = xPow1 * x
		
		xPow1 = <%gpFuncRdouble%>(xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i); // xPow1 = xScaled^i / i! 
		
		if ((i % 4) == 3)
		{
			*result2 = <%subFuncRR%>(*result1, xPow1); // result2 = result1 - xPow1
			std::swap(result1, result2); // result is always in 'result1' at end of loop
		}
		else if ((i % 4) == 1) 
		{
			*result2 = <%addFuncRR%>(*result1, xPow1); // result2 = result1 + xPow1
			std::swap(result1, result2); // result is always in 'result1' at end of loop
		}
	}

	return *result1;
} // end of <%funcName%>()

${ENDCODEBLOCK}

// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesCos}
<%returnType%> <%funcName%>(const <%inputType%> &x, int order) {
	<%returnType%> tmp1, tmp2; // temp <%returnType%> used for various purposes
	<%returnType%> xPow1, xPow2; // xScaled^... goes here
	<%returnType%> *result1 = &tmp1, *result2 = &tmp2; // accumulated result goes here (note: 'result1' = 'R')
	<%FT.type%> s_x2;
	int i;
   
	// First try special cases: check if (x * x) is scalar
	tmp1 = <%gpFuncII%>(x, x);
	s_x2 = _<%FT.type%>(tmp1);
	if ((<%normE2funcR%>(tmp1) - s_x2 * s_x2) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
		// OK (x * x == ~scalar), so use special cases:
		if (s_x2 > <%FT.DoubleToString(S, 0.0)%>) {
			return <%returnType%>(<%cosFunc%>(<%sqrtFunc%>(s_x2)));
		}
		else if (s_x2 < <%FT.DoubleToString(S, 0.0)%>) {
			return <%returnType%>(<%coshFunc%>(<%sqrtFunc%>(-s_x2)));
		}
		else {
			return <%returnType%>(<%FT.DoubleToString(S, 1.0)%>);
		}
	}

	// else do general series eval . . .


	*result1 = <%FT.DoubleToString(S, 1.0)%>;
	if (order == 0) return *result1;

	// taylor series approximation
	xPow1 = <%FT.DoubleToString(S, 1.0)%>; // xPow1 = 1.0
	for (i = 1; i <= order; i++) {
		xPow2 = <%gpFuncRI%>(xPow1, x); // xPow2 = xPow1 * x
		xPow1 = <%gpFuncRdouble%>(xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i); // xPow1 = xScaled^i / i! 
		
		if ((i % 4) == 2)
		{
			*result2 = <%subFuncRR%>(*result1, xPow1); // result2 = result1 - xPow1
			std::swap(result1, result2); // result is always in 'result1' at end of loop
		}
		else if ((i % 4) == 0) 
		{
			*result2 = <%addFuncRR%>(*result1, xPow1); // result2 = result1 + xPow1
			std::swap(result1, result2); // result is always in 'result1' at end of loop
		}		
    }

	return *result1;
} // end of <%funcName%>()
${ENDCODEBLOCK}

// same arguments as randomBladeVersor
${CODEBLOCK randomBladeVersorHeader}
/**
Generates a random <%if (generatorVersor) {%>versor<%}else{%>blade<%}%>.
The scale is uniformly distributed over the interval [0 1).
The maximum non-zero grade-part is 'grade'.
Only the basis vectors marked in 'basisVectorBitmap' will be used to generate the
versor/blade. Use 'basisVectorBitmap = -1' (the default) to use all basisvectors.

Returns <%functionName%>_ex(arg1, scale, grade, basisVectorBitmap, 0.01, scale * 4.0);
*/
<%mvType%> <%functionName%>(<%FT.type%> scale, int grade, int basisVectorBitmap = -1);

/**
This version of <%functionName%>() has extra arguments which help to avoid 
near-singular blades / versors.

Near-singular blades / versors are avoid by testing the norm and largest coordinate
of the random blade / versor. If the test does not pass, the function recursively
tries to generate another random blade / versor.

'minimumNorm' is the minimum allowed norm of the blade/versor before scaling. 
'minimumNorm' must be > 0.0 for versors.

'largestCoordinate' is the largest coordinate allowed after scaling.
*/
<%mvType%> <%functionName%>_ex(<%FT.type%> scale, int grade, int basisVectorBitmap, <%FT.type%> minimumNorm, <%FT.type%> largestCoordinate);

${ENDCODEBLOCK}

// S = Specification of algebra.
// functionName = name of generated function
// FT = floating point type
// mvType = multivector type name (with prefix/suffix)
// randomScalarFuncName = name of function which generates random scalar values
// gpopFuncName = name of geometric product or outer product function for two multivectors
// normFuncName = norm of multivector function (must return scalar)
// gpScalarFuncName = geometric product of multivector and scalar
// generatorVersor = bool (use geometric product or outer product)
${CODEBLOCK randomBladeVersor}

<%mvType%> <%functionName%>(<%FT.type%> scale, int grade, int basisVectorBitmap) {
	<%FT.type%> minimumNorm = <%FT.DoubleToString(S, 0.01)%>;
	<%FT.type%> largestCoordinate = <%FT.DoubleToString(S, 4.0)%>;
	return <%functionName%>_ex(scale, grade, basisVectorBitmap, minimumNorm, scale * largestCoordinate);
}

<%mvType%> <%functionName%>_ex(<%FT.type%> scale, int _grade, int basisVectorBitmap, 
		<%FT.type%> minimumNorm, <%FT.type%> largestCoordinate) 
{
	<%mvType%> randomVector, tmp1, tmp2;
	<%mvType%> *IR1 = &tmp1, *IR2 = &tmp2; // IR = intermediate result
	<%FT.type%> randomValues[<%S.m_dimension%>];
	<%FT.type%> n2, mul;
	int i;
	int grade = _grade;
	
	// set IR1 (intermediate result) to 1
	IR1->set(<%FT.DoubleToString(S, 1.0)%>);

	while (grade > 0) {	// loop until grade == 0
		// fill array with random values
		for (i = 0; i < <%S.m_dimension%>; i++) 
			randomValues[i] = (basisVectorBitmap & (1 << i))
				? (<%FT.DoubleToString(S, -1.0)%> + <%FT.DoubleToString(S, 2.0)%> * <%randomScalarFuncName%>())
				: <%FT.DoubleToString(S, 0.0)%>;
		
		// make it a multivector:
		randomVector.set(GRADE_1, randomValues);
		
		// multiply 
		(*IR2) = <%gpopFuncName%>(*IR1, randomVector);
		
		// swap IR pointers: 
		std::swap(IR1, IR2);
		
		// lower grade
		grade--;
	}
	
	// compute norm/multiplier, apply it, or recurse if we happened to create a near-null versor
	n2 = <%normFuncName%>(*IR1);
	if ((<%FT.type%>)fabs(n2) > minimumNorm * minimumNorm) {
		if (n2 != <%FT.DoubleToString(S, 0.0)%>) {
			mul = scale * <%randomScalarFuncName%>() / n2;
			if (IR1->largestCoordinate() * mul < largestCoordinate)
				return <%gpScalarFuncName%>(*IR1, mul);
		}
		else if (IR1->largestCoordinate() < largestCoordinate)
			return *IR1;
	}
	
	// try again:
	return <%functionName%>_ex(scale, _grade, basisVectorBitmap, minimumNorm, largestCoordinate); 
}
${ENDCODEBLOCK}



// S = Specification of algebra.
// FT = float type
// arg1name = argument 1 name
// arg2name = argument 2 name
// gmvName = mangled name of GMV
// gpFuncName = gpFuncName
// reverseFuncName = reverseFuncName
// norm2FuncName = norm2FuncName
// divFuncName = divFuncName
${CODEBLOCK igp_GMV_GMV_body}
<%FT.type%> _N2_ = <%norm2FuncName%>(<%arg2name%>);
return <%divFuncName%>(
	<%gpFuncName%>(<%arg1name%>, <%reverseFuncName%>(<%arg2name%>)),
	_N2_);
${ENDCODEBLOCK}

// S = Specification of algebra.
// FT = float type
// arg1name = argument 1 name
// arg2name = argument 2 name
// gmvName = mangled name of GMV
// divFuncName = divFuncName
${CODEBLOCK igp_GMV_float_body}
return <%divFuncName%>(<%arg1name%>, <%arg2name%>);
${ENDCODEBLOCK}

// S = Specification of algebra.
// FT = float type
// arg1name = argument 1 name
// arg2name = argument 2 name
// dstName = argument 2 name
// gmvName = mangled name of GMV
// mulFuncName = gpFuncName
// reverseFuncName = reverseFuncName
// norm2FuncName = norm2FuncName
// mulFuncName = divFuncName
${CODEBLOCK igp_float_GMV_body}
<%FT.type%> _N2_ = <%norm2FuncName%>(<%arg2name%>);
return <%mulFuncName%>(<%reverseFuncName%>(<%arg2name%>), <%arg1name%> / _N2_);
${ENDCODEBLOCK}

// S = Specification of algebra.
// MAX_N = maximum number of coordinates to set to zero explicitly
// FT = float type
${CODEBLOCK float_zero_copy_decl}
<%for (int n = 1; n <= MAX_N; n++) {%>
/** Sets <%n%> <%FT.type%><%((n>1) ? "s" : "")%> to zero */
void zero_<%n%>(<%FT.type%> *dst);
/** Copies <%n%> <%FT.type%><%((n>1) ? "s" : "")%> from 'src' to 'dst' */
void copy_<%n%>(<%FT.type%> *dst, const <%FT.type%> *src);
<%}%>
/** Sets N <%FT.type%>s to zero */
void zero_N(<%FT.type%> *dst, int N);
/** Copies N <%FT.type%>s from 'src' to 'dst' */
void copy_N(<%FT.type%> *dst, const <%FT.type%> *src, int N);
${ENDCODEBLOCK}

// S = Specification of algebra.
// MAX_N = maximum number of coordinates to set to zero explicitly
// FT = float type
${CODEBLOCK float_zero_copy_def}
<%for (int n = 1; n <= MAX_N; n++) {%>
inline void zero_<%n%>(<%FT.type%> *dst) {
	<%for (int i = 0; i < n; i++) {%>dst[<%i%>]=<%}%><%FT.DoubleToString(S, 0.0)%>;
}
inline void copy_<%n%>(<%FT.type%> *dst, const <%FT.type%> *src) {
<%for (int i = 0; i < n; i++) {%>
	dst[<%i%>] = src[<%i%>];
<%}%>
}
<%}%>
/** Sets N <%FT.type%>s to zero */
inline void zero_N(<%FT.type%> *dst, int N) {
	int i = 0;
	while ((N-i) > <%MAX_N%>) {
		zero_<%MAX_N%>(dst + i);
		i += <%MAX_N%>;
	}
	for (; i < N; i++)
		dst[i] = <%FT.DoubleToString(S, 0.0)%>;
}
/** Copies N <%FT.type%>s from 'src' to 'dst' */
inline void copy_N(<%FT.type%> *dst, const <%FT.type%> *src, int N) {
	int i = 0;
	while ((N-i) > <%MAX_N%>) {
		copy_<%MAX_N%>(dst + i, src + i);
		i += <%MAX_N%>;
	}
	for (; i < N; i++)
		dst[i] = src[i];
}
${ENDCODEBLOCK}



${CODEBLOCK ReportUsageHeader}
/**
This class is used to report usage of converted specialized multivectors.

The class is designed to be pretty safe with multi-threading without locking.
In the wordt case, some memory leaks occur and some counts are missed. 
The amount of memory leaked is bounded (goes not grow beyond a certain
point). Since the report-usage functionality is for
development/debugging only, this is not considered non-harmful.
*/
class ReportUsage {
public:
	inline ReportUsage(std::string str, unsigned int initialCount = 1) : 
		m_hash(computeHash(str)),
		m_str(str), 
		m_count(initialCount), 
		m_left(NULL),
		m_right(NULL)
	{
	}

	static void mergeReport(ReportUsage *RU);

	/// prints out all reports, sorted by m_str
	static void printReport(FILE *F = stdout, bool includeCount = true);

protected:
	/// Turns a string into a hashcode which is used to efficiently search the tree
	static inline int computeHash(const std::string &str) {
		unsigned int hash = 0x83BA056E; // just a number
		int shift = 0;
		const int SHIFT_INC = 7;
		for (int i = 0; i < (int)str.length(); i++) {
			hash ^= (unsigned int)(str[i] << shift);
			shift += SHIFT_INC;
			if (shift > (sizeof(unsigned int) - SHIFT_INC))
				shift &= SHIFT_INC;
		}
		return hash;
	}

	/// return true if m_str is equal (checks the hash first)
	inline bool equals(const ReportUsage *RU) const {
		if (m_hash != RU->m_hash) return false;
		else return (m_str == RU->m_str);
	}

	/// Returns -1 for this < RU, 0 for equals, +1 for this > RU
	/// First compares the hash, then the string.
	inline int compare(const ReportUsage *RU) const {
		if (equals(RU)) return 0;
		else if (m_hash == RU->m_hash) {
			return m_str.compare(RU->m_str);
		}
		else return (m_hash < RU->m_hash) ? -1 : 1;
	}

	/// Merges 'RU' with the reports
	inline void mergeReportInternal(ReportUsage *RU) {
		if (equals(RU)) { // just increment the count?
			if ((m_count + RU->m_count) > m_count) // prevent overflow of unsigned int
				m_count += RU->m_count;
			delete RU;
		}
		else { // either recurse or set m_left or m_right
			int comp = compare(RU);
			if (comp < 0) {
				if (m_left == NULL) m_left = RU;
				else m_left->mergeReportInternal(RU);
			}
			else {
				if (m_right == NULL) m_right = RU;
				else m_right->mergeReportInternal(RU);
			}
		}
	}

	inline void getMap(std::map<std::string, const ReportUsage*> &M) const {
		M[m_str] = this;
		if (m_left) m_left->getMap(M);
		if (m_right) m_right->getMap(M);
	}

	static ReportUsage *s_reportTree;

	/// hashcode of m_str.
	unsigned int m_hash;
	/// string describing the report.
	std::string m_str;
	/// how many times this report hash been filed.
	unsigned int m_count;

	/// left branch of tree
	ReportUsage *m_left;
	/// right branch of tree
	ReportUsage *m_right;
}; // end of class ReportUsage
${ENDCODEBLOCK}
${CODEBLOCK ReportUsageSource}
ReportUsage *ReportUsage::s_reportTree = NULL;

void ReportUsage::mergeReport(ReportUsage *RU) {
	if (ReportUsage::s_reportTree == NULL) ReportUsage::s_reportTree = RU;
	else ReportUsage::s_reportTree->mergeReportInternal(RU);
}

/// prints out all reports, sorted by m_str
void ReportUsage::printReport(FILE *F /*= stdout*/, bool includeCount /* = true */) {
	if (ReportUsage::s_reportTree == NULL) return;
	// collect all into std::map
	std::map<std::string, const ReportUsage*> M;
	ReportUsage::s_reportTree->getMap(M);

	for (std::map<std::string, const ReportUsage*>::const_iterator I = M.begin();
		I != M.end(); I++) 
	{
		int dummyArg = 0; // prevents compiler warning on some platforms
		fprintf(F, I->second->m_str.c_str(), dummyArg);
		int cnt = I->second->m_count;
		if (includeCount) fprintf(F, "  <!-- used %d time%s -->\n", cnt , (cnt == 1) ? "" : "s");
		else fprintf(F, "\n");
	}
}
${ENDCODEBLOCK}

${CODEBLOCK NoReportUsageHeader}
/**
This class is used to report usage of converted specialized multivectors.

The class is designed to be pretty safe with multi-threading without locking.
In the wordt case, some memory leaks occur and some counts are missed. 
The amount of memory leaked is bounded (goes not grow beyond a certain
point). Since the report-usage functionality is for
development/debugging only, this is not considered non-harmful.
*/
class ReportUsage {
	/// prints out error message that ReportUsage is disabled
	static void printReport(FILE *F = stdout, bool includeCount = true);
}; // end of class ReportUsage
${ENDCODEBLOCK}
${CODEBLOCK NoReportUsageSource}
void ReportUsage::printReport(FILE *F /*= stdout*/, bool includeCount /* = true */) {
	fprintf(F, "Report usage is disabled");
}
${ENDCODEBLOCK}




// same arguments as logEuclidean
${CODEBLOCK logEuclideanHeader}
/**
Returns logarithm of 3-D Euclidean rotor.
*/
<%mvType%> <%functionName%>(const <%mvType%> &R);
${ENDCODEBLOCK}

// S = Specification of algebra.
// functionName = name of generated function
// FT = floating point type
// mvType = multivector type name (with prefix/suffix)
// setPlaneFuncName = Name of function to set coordinate of some Euclidean bivector coordinate.
// randomScalarFuncName = name of function which generates random scalar values
// scalarGpFuncName = geometric product of multivector and scalar
// norm2FuncName = Euclidean norm, squared of multivector
// grade2FuncName = extract grade 2 part of multivector
${CODEBLOCK logEuclidean}

<%mvType%> <%functionName%>(const <%mvType%> &R) {
	double _g2norm2_ = <%norm2FuncName%>(R);

	double _scalarPart_ = R.get_scalar();

	if (_g2norm2_ <= 0.0) {
		if (_scalarPart_ < 0.0) {
			<%mvType%> tmp;
			tmp.<%setPlaneFuncName%>(<%FT.DoubleToString(S, Math.PI)%>);
			return tmp;
		}
		else {
			return <%mvType%>();
		}
	}

	double _g2norm_ = ::sqrt(_g2norm2_);

	double _mul_ = (::atan2(_scalarPart_, _g2norm_))/(_g2norm_);

	mv grade2part = <%grade2FuncName%>(R);

	return <%scalarGpFuncName%>(grade2part, _mul_);
}

${ENDCODEBLOCK}

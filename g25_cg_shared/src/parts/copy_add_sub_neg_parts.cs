// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

// Copyright 2008-2010, Daniel Fontijne, University of Amsterdam -- fontijne@science.uva.nl

using System;
using System.Collections.Generic;
using System.Text;

namespace G25.CG.Shared
{

    /// <summary>
    /// Contains functions for that generate code for general multivector addition, subtractions, copying, scaling, dividing, negation,
    /// hadamard product, equality and isZero, on a group by group basis. For each of these operations, one function is generated for each group of the 
    /// general multivector.
    /// 
    /// These part can be combined into larger functions, for example 
    /// <c>GetAddSubtractHpCode()</c>
    /// <c>GetUnaryToggleSignCode()</c>,
    /// <c>GetGradeCode()</c>,
    /// <c>GetUnitOrVersorInverseCode()</c> and
    /// <c>GetSAScode()</c> generate the code for various operations on full general multivectors.
    /// 
    /// The class is output language aware (currently supported languages: C)
    /// </summary>
    public class CANSparts
    {
        public const String EXTRACT_GRADE = "extractGrade";

        /// <summary>
        /// Used to determine what type of 'toggle sign type' function
        /// should be generated by <c>CANSparts.GetUnaryToggleSignCode()</c>.
        /// 
        /// Possible values are 
        /// <c>NEGATE</c>,
        /// <c>REVERSE</c>,
        /// <c>CLIFFORD_CONJUGATE</c> and 
        /// <c>GRADE_INVOLUTION</c>. 
        /// </summary>
        public enum UnaryToggleSignType : int
        {
            NEGATE = 1,
            REVERSE = 2,
            CLIFFORD_CONJUGATE = 3,
            GRADE_INVOLUTION = 4
        }

        public enum ADD_SUB_HP_TYPE : int
        {
            ADD = 1,
            SUB = 2,
            HP = 3,
            IHP = 4
        }

        public enum EQUALS_ZERO_GRADEBITMAP_TYPE : int
        {
            EQUALS = 1,
            ZERO = 2,
            GRADE_BITMAP = 3
        }

         

        /// <summary>
        ///  Temporary. Should be put in a shared class for norm code.
        /// </summary>
        public static string RETURNS_SCALAR = "_returns_scalar";


        /// <summary>
        /// Returns the name of a partial copy function.
        /// </summary>
        /// <param name="FT">Float type (used for mangled name).</param>
        /// <param name="g">Grade/group of arguments.</param>
        /// <returns>name of a partial copy function.</returns>
        public static string GetCopyPartFunctionName(Specification S, G25.FloatType FT, int g)
        {
            return FT.GetMangledName(S, "copyGroup") + "_" + g;
        }

        /// <summary>
        /// Returns the name of a partial copy-and-multiply (scale) function.
        /// </summary>
        /// <param name="FT">Float type (used for mangled name).</param>
        /// <param name="g">Grade/group of arguments.</param>
        /// <returns>name of a partial copy-and-multiply function.</returns>
        public static string GetCopyMulPartFunctionName(Specification S, G25.FloatType FT, int g)
        {
            return FT.GetMangledName(S, "copyMul") + "_" + g;
        }

        /// <summary>
        /// Returns the name of a partial copy-and-divide (inverse scale) function.
        /// </summary>
        /// <param name="FT">Float type (used for mangled name).</param>
        /// <param name="g">Grade/group of arguments.</param>
        /// <returns>name of a partial copy-and-divide function.</returns>
        public static string GetCopyDivPartFunctionName(Specification S, G25.FloatType FT, int g)
        {
            return FT.GetMangledName(S, "copyDiv") + "_" + g;
        }

        /// <summary>
        /// Returns the name of a partial addition function.
        /// </summary>
        /// <param name="FT">Float type (used for mangled name).</param>
        /// <param name="g">Grade/group of arguments.</param>
        /// <returns>name of a partial addition function.</returns>
        public static string GetAddPartFunctionName(Specification S, G25.FloatType FT, int g)
        {
            return FT.GetMangledName(S, "add") + "_" + g;
        }

        /// <summary>
        /// Returns the name of a partial subtraction function.
        /// </summary>
        /// <param name="FT">Float type (used for mangled name).</param>
        /// <param name="g">Grade/group of arguments.</param>
        /// <returns>name of a partial subtraction function.</returns>
        public static string GetSubPartFunctionName(Specification S, G25.FloatType FT, int g)
        {
            return FT.GetMangledName(S, "sub") + "_" + g;
        }

        /// <summary>
        /// Returns the name of a partial negation function.
        /// </summary>
        /// <param name="FT">Float type (used for mangled name).</param>
        /// <param name="g">Grade/group of arguments.</param>
        /// <returns>name of a partial negation function.</returns>
        public static string GetNegPartFunctionName(Specification S, G25.FloatType FT, int g)
        {
            return FT.GetMangledName(S, "neg") + "_" + g;
        }



        /// <summary>
        /// Returns the name of a partial addition function 
        /// (which actually adds two operands and stores results in a third operand).
        /// </summary>
        /// <param name="FT">Float type (used for mangled name).</param>
        /// <param name="g">Grade/group of arguments.</param>
        /// <returns>name of a partial addition function.</returns>
        public static string GetAdd2PartFunctionName(Specification S, G25.FloatType FT, int g)
        {
            return FT.GetMangledName(S, "add2") + "_" + g + "_" + g;
        }

        /// <summary>
        /// Returns the name of a partial subtraction function 
        /// (which actually subtracts two operands and stores results in a third operand).
        /// </summary>
        /// <param name="FT">Float type (used for mangled name).</param>
        /// <param name="g">Grade/group of arguments.</param>
        /// <returns>name of a partial subtraction function.</returns>
        public static string GetSub2PartFunctionName(Specification S, G25.FloatType FT, int g)
        {
            return FT.GetMangledName(S, "sub2") + "_" + g + "_" + g;
        }


        /// <summary>
        /// Returns the name of a partial Hadamard product function 
        /// </summary>
        /// <param name="FT">Float type (used for mangled name).</param>
        /// <param name="g">Grade/group of arguments.</param>
        /// <returns>name of a partial Hadamard product function.</returns>
        public static string GetHadamardProductPartFunctionName(Specification S, G25.FloatType FT, int g)
        {
            return FT.GetMangledName(S, "hp") + "_" + g + "_" + g;
        }

        /// <summary>
        /// Returns the name of a partial Hadamard product function 
        /// </summary>
        /// <param name="FT">Float type (used for mangled name).</param>
        /// <param name="g">Grade/group of arguments.</param>
        /// <returns>name of a partial Hadamard product function.</returns>
        public static string GetInverseHadamardProductPartFunctionName(Specification S, G25.FloatType FT, int g)
        {
            return FT.GetMangledName(S, "ihp") + "_" + g + "_" + g;
        }

        /// <summary>
        /// Returns the name of a partial equality function 
        /// </summary>
        /// <param name="FT">Float type (used for mangled name).</param>
        /// <param name="g">Grade/group of arguments.</param>
        /// <returns>name of a partial Hadamard product function.</returns>
        public static string GetEqualsPartFunctionName(Specification S, G25.FloatType FT, int g)
        {
            return FT.GetMangledName(S, "equals") + "_" + g + "_" + g;
        }

        /// <summary>
        /// Returns the name of a partial is-zero function 
        /// </summary>
        /// <param name="FT">Float type (used for mangled name).</param>
        /// <param name="g">Grade/group of arguments.</param>
        /// <returns>name of a partial Hadamard product function.</returns>
        public static String GetZeroPartFunctionName(Specification S, G25.FloatType FT, int g)
        {
            return FT.GetMangledName(S, "zeroGroup") + "_" + g;
        }

        /// <summary>
        /// Returns code for run-time copying of GMV parts.
        /// </summary>
        /// <param name="S">Specification (used for floating points types, output language, GMV).</param>
        /// <param name="cgd">Output goes here.</param>
        /// <param name="groupIdx">The group to generate code for.</param>
        /// <param name="src">Name of source array.</param>
        /// <param name="dst">Name of destination array.</param>
        protected static string GetRuntimeGmvCopyCode(Specification S, CGdata cgd, int groupIdx, string src, string dst)
        {
            StringBuilder SB = new StringBuilder();
            SB.Append("\tint i;\n");
            SB.Append("\tfor (i = 0; i < " + (S.m_GMV.Group(groupIdx).Length).ToString() + "; i++)\n");
            SB.Append("\t\t" + dst + "[i] = " + src + "[i];\n");

            return SB.ToString();
        }

        /// <summary>
        /// Returns code for run-time copying-and-scalar-multiplying/dividing of GMV parts.
        /// </summary>
        /// <param name="S">Specification (used for floating points types, output language, GMV).</param>
        /// <param name="cgd">Output goes here.</param>
        /// <param name="groupIdx">The group to generate code for.</param>
        /// <param name="src">Name of source array.</param>
        /// <param name="dst">Name of destination array.</param>
        /// <param name="scale">Name of scalar variable.</param>
        /// <param name="symbol">Symbol to use ("*" or "/").</param>
        protected static string GetRuntimeGmvCopyMulDivCode(Specification S, CGdata cgd, 
            int groupIdx, string src, string dst, string scale, string symbol)
        {
            StringBuilder SB = new StringBuilder();

            SB.Append("\tint i;\n");
            SB.Append("\tfor (i = 0; i < " + (S.m_GMV.Group(groupIdx).Length).ToString() + "; i++)\n");
            SB.Append("\t\t" + dst + "[i] = " + src + "[i] " + symbol + " " + scale + ";\n");

            return SB.ToString();
        }

        /// <summary>
        /// Returns code for run-time addition/subtraction of GMV parts.
        /// </summary>
        /// <param name="S">Specification (used for floating points types, output language, GMV).</param>
        /// <param name="cgd">Output goes here.</param>
        /// <param name="groupIdx">The group to generate code for.</param>
        /// <param name="src">Name of source array.</param>
        /// <param name="dst">Name of destination array.</param>
        /// <param name="symbol">Symbol to use ("+= " or "-= " or "= -").</param>
        protected static string GetRuntimeGmvAddSubNegCode(Specification S, CGdata cgd, 
            int groupIdx, string src, string dst, string symbol)
        {
            StringBuilder SB = new StringBuilder();

            SB.Append("\tint i;\n");
            SB.Append("\tfor (i = 0; i < " + (S.m_GMV.Group(groupIdx).Length).ToString() + "; i++)\n");
            SB.Append("\t\t" + dst + "[i] " + symbol + src + "[i];\n");

            return SB.ToString();
        }

        /// <summary>
        /// Returns code for run-time addition/subtraction/Hadamard product of two GMV parts.
        /// </summary>
        /// <param name="S">Specification (used for floating points types, output language, GMV).</param>
        /// <param name="cgd">Output goes here.</param>
        /// <param name="groupIdx">The group to generate code for.</param>
        /// <param name="src1">Name of source array 1.</param>
        /// <param name="src2">Name of source array 2.</param>
        /// <param name="dst">Name of destination array.</param>
        /// <param name="symbol">Symbol to use ("+", "-", "*" or "/").</param>
        protected static string GetRuntimeGmvAdd2Sub2HpCode(Specification S, CGdata cgd,
            int groupIdx, string src1, string src2, string dst, string symbol)
        {
            StringBuilder SB = new StringBuilder();

            SB.Append("\tint i;\n");
            SB.Append("\tfor (i = 0; i < " + (S.m_GMV.Group(groupIdx).Length).ToString() + "; i++)\n");
            SB.Append("\t\t" + dst + "[i] = " + src1 + "[i] " + symbol + " " + src2 + "[i];\n");

            return SB.ToString();
        }

        /// <summary>
        /// Returns code for run-time equality check of two GMV parts.
        /// </summary>
        /// <param name="S">Specification (used for floating points types, output language, GMV).</param>
        /// <param name="cgd">Output goes here.</param>
        /// <param name="groupIdx">The group to generate code for.</param>
        /// <param name="src1">Name of source array 1.</param>
        /// <param name="src2">Name of source array 2.</param>
        /// <param name="epsilon">Name of epsilon variable.</param>
        protected static string GetRuntimeGmvEqualsCode(Specification S, CGdata cgd,
            int groupIdx, string src1, string src2, string epsilon)
        {
            StringBuilder SB = new StringBuilder();

            string TRUE = (S.OutputC()) ? "1" : "true";
            string FALSE = (S.OutputC()) ? "0" : "false";


            SB.Append("\tint i;\n");
            SB.Append("\tfor (i = 0; i < " + (S.m_GMV.Group(groupIdx).Length).ToString() + "; i++)\n");
            SB.Append("\t\tif (((" + src1 + "[i] - " + src2 + "[i]) < -" + epsilon + ") || ((" + src1 + "[i] - " + src2 + "[i]) > " + epsilon + ")) return " + FALSE + ";\n");
            SB.Append("\treturn " + TRUE + ";\n");

            return SB.ToString();
        }


        /// <summary>
        /// Returns code for expand-code equality check of two GMV parts.
        /// </summary>
        /// <param name="S">Specification (used for floating points types, output language, GMV).</param>
        /// <param name="cgd">Output goes here.</param>
        /// <param name="groupIdx">The group to generate code for.</param>
        /// <param name="src1">Name of source array 1.</param>
        /// <param name="src2">Name of source array 2.</param>
        /// <param name="epsilon">Name of epsilon variable.</param>
        protected static string GetExpandGmvEqualsCode(Specification S, CGdata cgd,
            int groupIdx, string src1, string src2, string epsilon)
        {
            StringBuilder SB = new StringBuilder();

            string TRUE = CodeUtil.GetTrueValue(S);
            string FALSE = CodeUtil.GetFalseValue(S);

            for (int i = 0; i < S.m_GMV.Group(groupIdx).Length; i++)
                SB.Append("\t\tif (((" + src1 + "[" + i + "] - " + src2 + "[" + i + "]) < -" + epsilon + ") || ((" + src1 + "[" + i + "] - " + src2 + "[" + i + "]) > " + epsilon + ")) return " + FALSE + ";\n");
            SB.Append("\treturn " + TRUE + ";\n");

            return SB.ToString();
        }

        /// <summary>
        /// Returns runtime code for check for zero.
        /// </summary>
        /// <param name="S">Specification (used for floating points types, output language, GMV).</param>
        /// <param name="cgd">Output goes here.</param>
        /// <param name="groupIdx">The group to generate code for.</param>
        /// <param name="src">Name of source array .</param>
        /// <param name="epsilon">Name of epsilon variable.</param>
        protected static string GetRuntimeGmvZeroCode(Specification S, CGdata cgd,
            int groupIdx, string src, string epsilon)
        {
            StringBuilder SB = new StringBuilder();

            string TRUE = (S.OutputC()) ? "1" : "true";
            string FALSE = (S.OutputC()) ? "0" : "false";

            SB.Append("\tint i;\n");
            SB.Append("\tfor (i = 0; i < " + (S.m_GMV.Group(groupIdx).Length).ToString() + "; i++)\n");
            SB.Append("\t\tif ((" + src + "[i] < -" + epsilon + ") || (" + src + "[i] > " + epsilon + ")) return " + FALSE + ";\n");
            SB.Append("\treturn " + TRUE + ";\n");

            return SB.ToString();
        }

        /// <summary>
        /// Returns expand-code for check for zero.
        /// </summary>
        /// <param name="S">Specification (used for floating points types, output language, GMV).</param>
        /// <param name="cgd">Output goes here.</param>
        /// <param name="groupIdx">The group to generate code for.</param>
        /// <param name="src">Name of source array .</param>
        /// <param name="epsilon">Name of epsilon variable.</param>
        protected static string GetExpandGmvZeroCode(Specification S, CGdata cgd,
            int groupIdx, string src, string epsilon)
        {
            StringBuilder SB = new StringBuilder();

            string TRUE = (S.OutputC()) ? "1" : "true";
            string FALSE = (S.OutputC()) ? "0" : "false";

            for (int i = 0; i < S.m_GMV.Group(groupIdx).Length; i++)
                SB.Append("\t\tif ((" + src + "[" + i + "] < -" + epsilon + ") || (" + src + "[" + i + "] > " + epsilon + ")) return " + FALSE + ";\n");
            SB.Append("\t\treturn " + TRUE + ";\n");

            return SB.ToString();
        }

        /// <summary>
        /// Writes functions for the copying, adding, subtracting, negating, scaling
        /// inverse scaling and Hadamard product of general multivectors, on a group by group basis.
        /// 
        /// Internally the function loops over all float types, and over all operations (8 in total)
        /// to generate all code.
        /// 
        /// This function should be called early on in the code generation process, at least
        /// before any of the <c>Get....Code()</c> functions is called.
        /// </summary>
        /// <param name="S">Specification (used for floating points types, output language, GMV).</param>
        /// <param name="cgd">Output goes here.</param>
        public static void WriteCANSparts(Specification S, CGdata cgd)
        {
            G25.GMV gmv = S.m_GMV;

            string srcName1 = "A";
            string srcName2 = "B";
            string dstName = "C";
            string epsilonName = "eps";
            string scaleName = "s";
            bool ptr = true;
            int allGroups = -1;
            bool mustCast = false;
            int nbBaseTabs = (S.OutputCSharpOrJava()) ? 1 : 0;
            int nbCodeTabs = nbBaseTabs + 1;
            bool writeZeros = false;

            // get two symbolic multivectors (with different symbolic names):
            RefGA.Multivector[] M1 = null, M2 = null;
            if (S.m_gmvCodeGeneration == GMV_CODE.EXPAND)
            { // M1 and M2 and only required for full code expansion
                M1 = G25.CG.Shared.Symbolic.GMVtoSymbolicMultivector(S, gmv, srcName1, ptr, allGroups);
                M2 = G25.CG.Shared.Symbolic.GMVtoSymbolicMultivector(S, gmv, srcName2, ptr, allGroups);
            }
            RefGA.Multivector scaleM = new RefGA.Multivector(scaleName);

            foreach (G25.FloatType FT in S.m_floatTypes)
            {
                // map from code fragment to name of function
                Dictionary<string, string> generatedCode = new Dictionary<string, string>();

                for (int g1 = 0; g1 < gmv.NbGroups; g1++)
                {
                    int g2 = g1;

                    const int COPY = 0;
                    const int COPY_MUL = 1;
                    const int COPY_DIV = 2;
                    const int ADD = 3;
                    const int SUB = 4;
                    const int NEG = 5;
                    const int ADD2 = 6;
                    const int SUB2 = 7;
                    const int HP = 8;
                    const int IHP = 9;
                    const int EQUALS = 10;
                    const int ZERO = 11;
                    const int NB_OPS = 12;

                    for (int op = 0; op < NB_OPS; op++) 
                    {
                        // get value of operation, name of function:
                        RefGA.Multivector value = null;
                        String funcName = null;
                        String comment = null;
                        String code = null; // code depends on code generation mode (expand or run-time)
                        switch (op)
                        {
                            case COPY:
                                if (S.m_gmvCodeGeneration == GMV_CODE.EXPAND) 
                                    value = M1[g1];
                                else if (S.m_gmvCodeGeneration == GMV_CODE.RUNTIME) 
                                    code = GetRuntimeGmvCopyCode(S, cgd, g1, srcName1, dstName);
                                funcName = GetCopyPartFunctionName(S, FT, g1);
                                comment = "copies coordinates of group " + g1;
                                break;
                            case COPY_MUL:
                                if (S.m_gmvCodeGeneration == GMV_CODE.EXPAND)
                                    value = RefGA.Multivector.gp(scaleM, M1[g1]);
                                else if (S.m_gmvCodeGeneration == GMV_CODE.RUNTIME)
                                    code = GetRuntimeGmvCopyMulDivCode(S, cgd, g1, srcName1, dstName, scaleName, "*");
                                funcName = GetCopyMulPartFunctionName(S, FT, g1);
                                comment = "copies and multiplies (by " + scaleName + ") coordinates of group " + g1;
                                break;
                            case COPY_DIV:
                                if (S.m_gmvCodeGeneration == GMV_CODE.EXPAND)
                                    value = RefGA.Multivector.gp(M1[g1], scaleM);
                                else if (S.m_gmvCodeGeneration == GMV_CODE.RUNTIME)
                                    code = GetRuntimeGmvCopyMulDivCode(S, cgd, g1, srcName1, dstName, scaleName, "/");
                                funcName = GetCopyDivPartFunctionName(S, FT, g1);
                                comment = "copies and divides (by " + scaleName + ") coordinates of group " + g1;
                                break;
                            case ADD:
                                if (S.m_gmvCodeGeneration == GMV_CODE.EXPAND)
                                    value = M1[g1];
                                else if (S.m_gmvCodeGeneration == GMV_CODE.RUNTIME)
                                    code = GetRuntimeGmvAddSubNegCode(S, cgd, g1, srcName1, dstName, "+= ");
                                funcName = GetAddPartFunctionName(S, FT, g1);
                                comment = "adds coordinates of group " + g1 + " from variable " + srcName1 + " to " + dstName;
                                break;
                            case SUB:
                                if (S.m_gmvCodeGeneration == GMV_CODE.EXPAND)
                                    value = M1[g1];
                                else if (S.m_gmvCodeGeneration == GMV_CODE.RUNTIME)
                                    code = GetRuntimeGmvAddSubNegCode(S, cgd, g1, srcName1, dstName, "-= ");
                                funcName = GetSubPartFunctionName(S, FT, g1);
                                comment = "subtracts coordinates of group " + g1 + " in variable " + srcName1 + " from " + dstName;
                                break;
                            case NEG:
                                if (S.m_gmvCodeGeneration == GMV_CODE.EXPAND)
                                    value = RefGA.Multivector.Negate(M1[g1]);
                                else if (S.m_gmvCodeGeneration == GMV_CODE.RUNTIME)
                                    code = GetRuntimeGmvAddSubNegCode(S, cgd, g1, srcName1, dstName, "= -");
                                funcName = GetNegPartFunctionName(S, FT, g1);
                                comment = "negate coordinates of group " + g1 + " of variable " + srcName1;
                                break;
                            case ADD2:
                                if (S.m_gmvCodeGeneration == GMV_CODE.EXPAND)
                                    value = RefGA.Multivector.Add(M1[g1], M2[g2]);
                                else if (S.m_gmvCodeGeneration == GMV_CODE.RUNTIME)
                                    code = GetRuntimeGmvAdd2Sub2HpCode(S, cgd, g1, srcName1, srcName2, dstName, "+");
                                funcName = GetAdd2PartFunctionName(S, FT, g1);
                                comment = "adds coordinates of group " + g1 + " of variables " + srcName1 + " and " + srcName2;
                                break;
                            case SUB2:
                                if (S.m_gmvCodeGeneration == GMV_CODE.EXPAND)
                                    value = RefGA.Multivector.Subtract(M1[g1], M2[g2]);
                                else if (S.m_gmvCodeGeneration == GMV_CODE.RUNTIME)
                                    code = GetRuntimeGmvAdd2Sub2HpCode(S, cgd, g1, srcName1, srcName2, dstName, "-");
                                funcName = GetSub2PartFunctionName(S, FT, g1);
                                comment = "subtracts coordinates of group " + g1 + " of variables " + srcName1 + " from " + srcName2;
                                break;
                            case HP:
                                if (S.m_gmvCodeGeneration == GMV_CODE.EXPAND)
                                {
                                    value = RefGA.Multivector.HadamardProduct(M1[g1], M2[g2]);
                                    RefGA.Multivector correctedValue = RefGA.Multivector.InverseHadamardProduct(value, S.m_GMV.ToMultivectorValue());
                                    value = correctedValue;
                                }
                                else if (S.m_gmvCodeGeneration == GMV_CODE.RUNTIME)
                                    code = GetRuntimeGmvAdd2Sub2HpCode(S, cgd, g1, srcName1, srcName2, dstName, "*");
                                funcName = GetHadamardProductPartFunctionName(S, FT, g1);
                                comment = "performs coordinate-wise multiplication of coordinates of group " + g1 + " of variables " + srcName1 + " and " + srcName2;
                                break;
                            case IHP:
                                if (S.m_gmvCodeGeneration == GMV_CODE.EXPAND)
                                {
                                    value = RefGA.Multivector.InverseHadamardProduct(M1[g1], M2[g2]);
                                    RefGA.Multivector correctedValue = RefGA.Multivector.InverseHadamardProduct(value, S.m_GMV.ToMultivectorValue());
                                    value = correctedValue;
                                }
                                else if (S.m_gmvCodeGeneration == GMV_CODE.RUNTIME)
                                    code = GetRuntimeGmvAdd2Sub2HpCode(S, cgd, g1, srcName1, srcName2, dstName, "/");
                                funcName = GetInverseHadamardProductPartFunctionName(S, FT, g1);
                                comment = "performs coordinate-wise division of coordinates of group " + g1 + " of variables " + srcName1 + " and " + srcName2 + "\n(no checks for divide by zero are made)";
                                break;
                            case EQUALS:
                                if (S.m_gmvCodeGeneration == GMV_CODE.EXPAND)
                                    code = GetExpandGmvEqualsCode(S, cgd, g1, srcName1, srcName2, epsilonName);
                                else if (S.m_gmvCodeGeneration == GMV_CODE.RUNTIME)
                                    code = GetRuntimeGmvEqualsCode(S, cgd, g1, srcName1, srcName2, epsilonName);
                                funcName = GetEqualsPartFunctionName(S, FT, g1);
                                comment = "check for equality up to " + epsilonName + " of coordinates of group " + g1 + " of variables " + srcName1 + " and " + srcName2;
                                break;
                            case ZERO:
                                if (S.m_gmvCodeGeneration == GMV_CODE.EXPAND)
                                    code = GetExpandGmvZeroCode(S, cgd, g1, srcName1, epsilonName);
                                else if (S.m_gmvCodeGeneration == GMV_CODE.RUNTIME)
                                    code = GetRuntimeGmvZeroCode(S, cgd, g1, srcName1, epsilonName);
                                funcName = GetZeroPartFunctionName(S, FT, g1);
                                comment = "checks if coordinates of group " + g1 + " of variable " + srcName1 + " are zero up to "  + epsilonName;
                                break;

                        }

                        // code generation for full code expansion
                        if (S.m_gmvCodeGeneration == GMV_CODE.EXPAND)
                        {
                            if (!((op == EQUALS) || (op == ZERO))) { // EQUALS and ZERO are different: they generate their own code
                                // get assignment code
                                int dstBaseIdx = 0;
                                code = G25.CG.Shared.CodeUtil.GenerateGMVassignmentCode(S, FT, mustCast, gmv, dstName, g1, dstBaseIdx, value, nbCodeTabs, writeZeros);

                                // replace assignment symbols if required
                                if (op == ADD) code = code.Replace("=", "+=");
                                else if (op == SUB) code = code.Replace("=", "-=");
                                else if (op == COPY_DIV) code = code.Replace("*" + scaleName, "/" + scaleName);
                            }
                        }


                        // check if code was already generated, and, if so, reuse it
                        if (generatedCode.ContainsKey(code))
                        {
                            // already generated: call that function
                            if ((op == ADD2) || (op == SUB2) || (op == HP) || (op == IHP))
                                code = new string('\t', nbCodeTabs) + generatedCode[code] + "(" + srcName1 + ", " + srcName2 + ", " + dstName + ");\n";
                            else if ((op == COPY_MUL) || (op == COPY_DIV))
                                code = new string('\t', nbCodeTabs) + generatedCode[code] + "(" + srcName1 + ", " + dstName + ", " + scaleName + ");\n";
                            else if (op == ZERO)
                                code = new string('\t', nbCodeTabs) + "return " + generatedCode[code] + "(" + srcName1 + ", " + epsilonName + ");\n";
                            else if (op == EQUALS)
                                code = new string('\t', nbCodeTabs) + "return " + generatedCode[code] + "(" + srcName1 + ", " + srcName2 + ", " + epsilonName + ");\n";
                            else code = new string('\t', nbCodeTabs) + generatedCode[code] + "(" + srcName1 + ", " + dstName + ");\n";
                        }
                        else
                        {
                            // not generated yet: remember code -> function
                            generatedCode[code] = funcName;
                        }

                        string ACCESS = "";
                        if (S.OutputJava()) ACCESS = "protected final static ";
                        else if (S.OutputCSharp()) ACCESS  = "protected internal static ";

                        string BOOL = CodeUtil.GetBoolType(S);
                        string ARR = (S.OutputCSharpOrJava()) ? "[] " : " *";
                        string CONST = (S.OutputCSharpOrJava()) ? "" : "const ";
                        string funcDecl;

                        // one or two input args, scale or not?
                        if ((op == ADD2) || (op == SUB2) || (op == HP) || (op == IHP))
                            funcDecl = ACCESS + "void " + funcName + "(" + CONST + FT.type + ARR + srcName1 + ", " + CONST + FT.type + ARR + srcName2 + ", " + FT.type + ARR + dstName + ")";
                        else if ((op == COPY_MUL) || (op == COPY_DIV))
                            funcDecl = ACCESS + "void " + funcName + "(" + CONST + FT.type + ARR + srcName1 + ", " + FT.type + ARR + dstName + ", " + FT.type + " " + scaleName + ")";
                        else if (op == ZERO)
                            funcDecl = ACCESS + BOOL + " " + funcName + "(" + CONST + FT.type + ARR + srcName1 + ", " + FT.type + " " + epsilonName + ")";
                        else if (op == EQUALS)
                            funcDecl = ACCESS + BOOL + " " + funcName + "(" + CONST + FT.type + ARR + srcName1 + ", " + CONST + FT.type + ARR + srcName2 + ", " + FT.type + " " + epsilonName + ")";
                        else funcDecl = ACCESS + "void " + funcName + "(" + CONST + FT.type + ARR + srcName1 + ", " + FT.type + ARR + dstName + ")";

                        if (S.OutputCppOrC())
                        {
                            Util.WriteFunctionComment(cgd.m_declSB, S, nbBaseTabs, comment, null, null);
                            cgd.m_declSB.Append(funcDecl); cgd.m_declSB.AppendLine(";");
                        }
                        else
                        {
                            Util.WriteFunctionComment(cgd.m_defSB, S, nbBaseTabs, comment, null, null);
                        }
                        
                        // append func body:
                        cgd.m_defSB.Append('\t', nbBaseTabs);
                        cgd.m_defSB.Append(funcDecl);
                        cgd.m_defSB.AppendLine(" {");
                        cgd.m_defSB.Append(code);
                        cgd.m_defSB.Append('\t', nbBaseTabs);
                        cgd.m_defSB.AppendLine("}");
                    }
                } // end of loop over the grade of 'A'
            } // end of loop over all float types
        } // end of function WriteCANSparts()


        /// <summary>
        /// Returns the code addition/subtraction/hadamard product of two general multivectors. 
        /// The code is composed of calls to functions generated by <c>WriteCASNparts()</c>.
        /// 
        /// The returned code is only the body. The function declaration is not included.
        /// </summary>
        /// <param name="S">Specification of algebra (used for general multivector type, output language).</param>
        /// <param name="cgd">Currently not used.</param>
        /// <param name="FT">Floating point type.</param>
        /// <param name="funcType">Whether to generate addition, subtraction or Hadamard product code.</param>
        /// <param name="FAI">Info about function arguments.</param>
        /// <param name="resultName">Name of variable where the result goes (in the generated code).</param>
        /// <returns>code for the requested product type.</returns>
        public static string GetAddSubtractHpCode(Specification S, G25.CG.Shared.CGdata cgd, G25.FloatType FT, 
            ADD_SUB_HP_TYPE funcType,
            G25.CG.Shared.FuncArgInfo[] FAI, string resultName)
        {
            if (S.OutputCppOrC())
                return GetAddSubtractHpCode_C_CPP(S, cgd, FT, funcType, FAI, resultName);
            else return GetAddSubtractHpCode_CSharp_Java(S, cgd, FT, funcType, FAI, resultName);
        }

        private static string GetAddSubtractHpCode_C_CPP(Specification S, G25.CG.Shared.CGdata cgd, G25.FloatType FT, 
            ADD_SUB_HP_TYPE funcType,
            G25.CG.Shared.FuncArgInfo[] FAI, string resultName) {
            G25.GMV gmv = S.m_GMV;

            bool NOT_HP = (!((funcType == ADD_SUB_HP_TYPE.HP) || (funcType == ADD_SUB_HP_TYPE.IHP)));

            StringBuilder SB= new StringBuilder();

            SB.AppendLine("int aidx = 0, bidx = 0, cidx = 0;");

            string agu = (S.OutputC()) ? FAI[0].Name + "->gu" : FAI[0].Name + ".gu()";
            string ac = (S.OutputC()) ? FAI[0].Name + "->c" : FAI[0].Name + ".getC()";
            string bgu = (S.OutputC()) ? FAI[1].Name + "->gu" : FAI[1].Name + ".gu()";
            string bc = (S.OutputC()) ? FAI[1].Name + "->c" : FAI[1].Name + ".getC()";
            string resultCoordPtr = (S.OutputC()) ? resultName + "->c" : "c";

            string guSymbol = (NOT_HP) ? "|" : "&";
            if (S.OutputC())
            {
                SB.AppendLine(resultName + "->gu = " + agu + " " + guSymbol + " " + bgu + ";");
            }
            else
            {
                SB.AppendLine("int gu = " + agu + " " + guSymbol + " " + bgu + ";");
                SB.AppendLine(FT.type + " c[" + (1 << S.m_dimension) + "];");
            }

            // get number of groups, and possible assurances that a group is always present:
            int nbGroups = gmv.NbGroups;

            // for each group
            // test if present in both-> then add both, etc
            for (int g = 0; g < nbGroups; g++)
            {
                SB.AppendLine("");

                string funcName1_1 = GetCopyPartFunctionName(S, FT, g);
                string funcName2 = null;
                string funcName1_2 = null;
                switch (funcType) 
                {
                    case ADD_SUB_HP_TYPE.ADD:
                        funcName2 = GetAdd2PartFunctionName(S, FT, g);
                        funcName1_2 = GetCopyPartFunctionName(S, FT, g);
                        break;
                    case ADD_SUB_HP_TYPE.SUB:
                        funcName2 = GetSub2PartFunctionName(S, FT, g);
                        funcName1_2 = GetNegPartFunctionName(S, FT, g);
                        break;
                    case ADD_SUB_HP_TYPE.HP:
                        funcName2 = GetHadamardProductPartFunctionName(S, FT, g);
                        funcName1_2 = null;
                        break;
                    case ADD_SUB_HP_TYPE.IHP:
                        funcName2 = GetInverseHadamardProductPartFunctionName(S, FT, g);
                        funcName1_2 = null;
                        break;
                }

                SB.AppendLine("if (" + agu + " & " + (1 << g) + ") {");
                SB.AppendLine("\tif (" + bgu + " & " + (1 << g) + ") {");

                SB.AppendLine("\t\t" + funcName2 + "(" + ac + " + aidx, " + bc + " + bidx, " + resultCoordPtr + " + cidx);");
                if (g < (nbGroups - 1))
                {
                    SB.AppendLine("\t\tbidx += " + gmv.Group(g).Length + ";");
                    if (!NOT_HP) SB.AppendLine("\t\tcidx += " + gmv.Group(g).Length + ";");
                }
                SB.AppendLine("\t}");

                if (NOT_HP)
                    SB.AppendLine("\telse " + funcName1_1 + "(" + ac + " + aidx, " + resultCoordPtr + " + cidx);");

                if (g < (nbGroups - 1)) SB.AppendLine("\taidx += " + gmv.Group(g).Length + ";");

                if (NOT_HP)
                    SB.AppendLine("\tcidx += " + gmv.Group(g).Length + ";");

                SB.AppendLine("}");
                SB.AppendLine("else if (" + bgu + " & " + (1 << g) + ") {");

                if (NOT_HP)
                    SB.AppendLine("\t" + funcName1_2 + "(" + bc + " + bidx, " + resultCoordPtr + " + cidx);");

                if (g < (nbGroups - 1)) SB.AppendLine("\tbidx += " + gmv.Group(g).Length + ";");

                if (NOT_HP)
                    SB.AppendLine("\tcidx += " + gmv.Group(g).Length + ";");

                SB.AppendLine("}");

            }

            // return result
            if (S.m_outputLanguage != OUTPUT_LANGUAGE.C)
            {
                SB.AppendLine("return " + FT.GetMangledName(S, gmv.Name) + "(gu, c);");
            }

            return SB.ToString();
        } // end of GetAddSubtractHpCode_C_CPP()
                        
        private static string GetAddSubtractHpCode_CSharp_Java(Specification S, G25.CG.Shared.CGdata cgd, G25.FloatType FT, 
            ADD_SUB_HP_TYPE funcType,
            G25.CG.Shared.FuncArgInfo[] FAI, string resultName) {
            G25.GMV gmv = S.m_GMV;

            bool NOT_HP = (!((funcType == ADD_SUB_HP_TYPE.HP) || (funcType == ADD_SUB_HP_TYPE.IHP)));

            StringBuilder SB= new StringBuilder();

            // get number of groups, and possible assurances that a group is always present:
            int nbGroups = gmv.NbGroups;

            bool resultIsScalar = false, initResultToZero = false;
            SB.Append(GPparts.GetExpandCode(S, cgd, FT, FAI, resultIsScalar, initResultToZero));

            // for each group
            // test if present in both-> then add both, etc
            for (int g = 0; g < nbGroups; g++)
            {
                SB.AppendLine("");

                string funcName1_1 = GetCopyPartFunctionName(S, FT, g);
                string funcName2 = null;
                string funcName1_2 = null;
                switch (funcType) 
                {
                    case ADD_SUB_HP_TYPE.ADD:
                        funcName2 = GetAdd2PartFunctionName(S, FT, g);
                        funcName1_2 = GetCopyPartFunctionName(S, FT, g);
                        break;
                    case ADD_SUB_HP_TYPE.SUB:
                        funcName2 = GetSub2PartFunctionName(S, FT, g);
                        funcName1_2 = GetNegPartFunctionName(S, FT, g);
                        break;
                    case ADD_SUB_HP_TYPE.HP:
                        funcName2 = GetHadamardProductPartFunctionName(S, FT, g);
                        funcName1_2 = null;
                        break;
                    case ADD_SUB_HP_TYPE.IHP:
                        funcName2 = GetInverseHadamardProductPartFunctionName(S, FT, g);
                        funcName1_2 = null;
                        break;
                }

                string allocCcode = "cc[" + g + "] = new " + FT.type + "[" + gmv.Group(g).Length + "];";

                SB.AppendLine("if (ac[" + g + "] != null) {");
                if (NOT_HP)
                    SB.AppendLine("\t" + allocCcode);

                SB.AppendLine("\tif (bc[" + g + "] != null) {");

                if (!NOT_HP)
                    SB.AppendLine("\t\t" + allocCcode);

                SB.AppendLine("\t\t" + funcName2 + "(ac[" + g + "], bc[" + g + "], cc[" + g + "]);");
                SB.AppendLine("\t}");

                if (NOT_HP)
                    SB.AppendLine("\telse " + funcName1_1 + "(ac[" + g + "], cc[" + g + "]);");

                SB.AppendLine("}");
                if (NOT_HP)
                {
                    SB.AppendLine("else if (bc[" + g + "] != null) {");

                    SB.AppendLine("\t" + allocCcode);
                    SB.AppendLine("\t" + funcName1_2 + "(bc[" + g + "], cc[" + g + "]);");

                    SB.AppendLine("}");
                }

            }

            // return result
            SB.AppendLine("return new " + FT.GetMangledName(S, gmv.Name) + "(cc);");

            return SB.ToString();
        } // end of GetAddSubtractHpCode_CSharp_Java()

        /// <returns>Whether to negate group 'groupIdx' for sign toggle operation 'T'.</returns>
        private static bool NeedToNegate(G25.GMV gmv, int groupIdx, UnaryToggleSignType T)
        {
            switch (T)
            {
                case UnaryToggleSignType.NEGATE:
                    return true;
                case UnaryToggleSignType.REVERSE:
                    return (gmv.Group(groupIdx)[0].Reverse().scale / gmv.Group(groupIdx)[0].scale) < 0;
                case UnaryToggleSignType.GRADE_INVOLUTION:
                    return (gmv.Group(groupIdx)[0].GradeInvolution().scale / gmv.Group(groupIdx)[0].scale) < 0;
                case UnaryToggleSignType.CLIFFORD_CONJUGATE:
                    return (gmv.Group(groupIdx)[0].CliffordConjugate().scale / gmv.Group(groupIdx)[0].scale) < 0;
                default:
                    return false;
            }
        }


        /// <summary>
        /// Returns the code for any negation, reversion, conjugation or grade involution function of general multivectors.
        /// The code is composed of calls to functions generated by <c>WriteCASNparts()</c>.
        /// 
        /// The returned code is only the body. The function declaration is not included.
        /// </summary>
        /// <param name="S">Specification of algebra (used for output language).</param>
        /// <param name="cgd">Currently not used.</param>
        /// <param name="FT">Floating point type.</param>
        /// <param name="T">What function to generate</param>
        /// <param name="FAI">Info about function arguments</param>
        /// <param name="resultName">Name of variable where the result goes (in the generated code).</param>
        /// <returns>code for the requested product type.</returns>
        public static string GetUnaryToggleSignCode(Specification S, G25.CG.Shared.CGdata cgd, G25.FloatType FT, 
            UnaryToggleSignType T,
            G25.CG.Shared.FuncArgInfo[] FAI, string resultName)
        {
            if (S.OutputCppOrC())
                return GetUnaryToggleSignCodeCppOrC(S, cgd, FT, T, FAI, resultName);
            else return GetUnaryToggleSignCodeCSharpOrJava(S, cgd, FT, T, FAI, resultName);
        }

        private static string GetUnaryToggleSignCodeCppOrC(Specification S, G25.CG.Shared.CGdata cgd, G25.FloatType FT, 
            UnaryToggleSignType T,
            G25.CG.Shared.FuncArgInfo[] FAI, string resultName)
        {
            G25.GMV gmv = S.m_GMV;

            StringBuilder SB=  new StringBuilder();

            string agu = (S.OutputC()) ? FAI[0].Name + "->gu" : FAI[0].Name + ".gu()";
            string ac = (S.OutputC()) ? FAI[0].Name + "->c" : FAI[0].Name + ".getC()";
            string resultCoordPtr = (S.OutputC()) ? resultName + "->c" : "c";

            SB.AppendLine("int idx = 0;");

            if (S.OutputC())
            {
                SB.AppendLine(resultName + "->gu = " + agu + ";");
            }
            else
            {
                SB.AppendLine("int gu = " + agu + ";");
                SB.AppendLine(FT.type + " c[" + (1 << S.m_dimension) + "];");
            }

            // get number of groups:
            int nbGroups = gmv.NbGroups;

            // for each group
            // test if present, then code / negate, etc

            for (int g = 0; g < nbGroups; g++)
            {
                SB.AppendLine("");

                // do we need to negate this group?
                bool neg = NeedToNegate(gmv, g, T);

                string funcName = (neg) ? GetNegPartFunctionName(S, FT, g) : GetCopyPartFunctionName(S, FT, g);

                SB.AppendLine("if (" + agu + " & " + (1 << g) + ") {");
                SB.AppendLine("\t" + funcName + "(" + ac + " + idx, " + resultCoordPtr + " + idx);");

                if (g < (nbGroups - 1)) SB.AppendLine("\tidx += " + gmv.Group(g).Length + ";");

                SB.AppendLine("}");
            }

            // return result
            if (S.m_outputLanguage != OUTPUT_LANGUAGE.C)
            {
                SB.AppendLine("return " + FT.GetMangledName(S, gmv.Name) + "(gu, c);");
            }

            return SB.ToString();
        } // end of GetUnaryToggleSignCodeCppOrC()

        private static string GetUnaryToggleSignCodeCSharpOrJava(Specification S, G25.CG.Shared.CGdata cgd, G25.FloatType FT,
            UnaryToggleSignType T,
            G25.CG.Shared.FuncArgInfo[] FAI, string resultName)
        {
            G25.GMV gmv = S.m_GMV;

            StringBuilder SB = new StringBuilder();

            // get number of groups:
            int nbGroups = gmv.NbGroups;

//            SB.AppendLine(FT.type + "[][] ac = " + FAI[0].Name + ".c();");
  //          SB.AppendLine(FT.type + "[][] cc = new " + FT.type + "[" + nbGroups + "][];");
            bool resultIsScalar = false , initResultToZero = false;
            GPparts.GetExpandCode(S, cgd, FT, FAI, resultIsScalar, initResultToZero);


            // for each group
            // test if present, then code / negate, etc

            for (int g = 0; g < nbGroups; g++)
            {
                SB.AppendLine("");

                // do we need to negate this group?
                bool neg = NeedToNegate(gmv, g, T);

                string funcName = (neg) ? GetNegPartFunctionName(S, FT, g) : GetCopyPartFunctionName(S, FT, g);

                SB.AppendLine("if (ac[" + g + "] != null) {");
                SB.AppendLine("\tcc[" + g + "] = new " + FT.type + "[" + gmv.Group(g).Length + "];");
                SB.AppendLine("\t" + funcName + "(ac[" + g + "], cc[" + g + "]);");
                SB.AppendLine("}");
            }

            SB.AppendLine("return new " + FT.GetMangledName(S, gmv.Name) + "(cc);");

            return SB.ToString();
        } // end of GetUnaryToggleSignCodeCSharpOrJava()

        /// <summary>
        /// Returns the code for zero-check.
        /// The code is composed of calls to functions generated by <c>WriteCASNparts()</c>.
        /// 
        /// The returned code is only the body. The function declaration is not included.
        /// </summary>
        /// <param name="S">Specification of algebra (used for output language).</param>
        /// <param name="cgd">Currently not used.</param>
        /// <param name="FT">Floating point type.</param>
        /// <param name="FAI">Info about function arguments</param>
        /// <returns>code for the requested product type.</returns>
        public static string GetZeroCode(Specification S, G25.CG.Shared.CGdata cgd, G25.FloatType FT,
            G25.CG.Shared.FuncArgInfo[] FAI)
        {
            if (S.OutputCppOrC())
                return GetZeroCodeCppOrC(S, cgd, FT, FAI);
            else return GetZeroCodeCSharpOrJava(S, cgd, FT, FAI);


        }

        private static string GetZeroCodeCppOrC(Specification S, G25.CG.Shared.CGdata cgd, G25.FloatType FT,
            G25.CG.Shared.FuncArgInfo[] FAI) {
            G25.GMV gmv = S.m_GMV;

            StringBuilder SB = new StringBuilder();

            SB.AppendLine("int idx = 0;");

            // get number of groups:
            int nbGroups = gmv.NbGroups;
             
            // for each group
            // test if present, then code / negate, etc

            string agu = (S.OutputC()) ? FAI[0].Name + "->gu" : FAI[0].Name + ".gu()";
            string ac = (S.OutputC()) ? FAI[0].Name + "->c" : FAI[0].Name + ".getC()";

            string falseStr = CodeUtil.GetFalseValue(S);
            string trueStr = CodeUtil.GetTrueValue(S);

            for (int g = 0; g < nbGroups; g++)
            {
                SB.AppendLine("");

                string funcName = GetZeroPartFunctionName(S, FT, g);

                SB.AppendLine("if (" + agu + " & " + (1 << g) + ") {");
                SB.AppendLine("\tif (!" + funcName + "(" + ac + " + idx, " + FAI[1].Name + ")) return " + falseStr + ";");

                if (g < (nbGroups - 1)) SB.AppendLine("\tidx += " + gmv.Group(g).Length + ";");

                SB.AppendLine("}");

            }
            SB.AppendLine("return " + trueStr + ";");

            return SB.ToString();
            } // end of GetZeroCodeCppOrC()

        private static string GetZeroCodeCSharpOrJava(Specification S, G25.CG.Shared.CGdata cgd, G25.FloatType FT,
            G25.CG.Shared.FuncArgInfo[] FAI)
        {
            G25.GMV gmv = S.m_GMV;

            StringBuilder SB = new StringBuilder();

            // get number of groups:
            int nbGroups = gmv.NbGroups;

            SB.AppendLine(FT.type + "[][] ac = " + FAI[0].Name + ".c();");

            string falseStr = CodeUtil.GetFalseValue(S);
            string trueStr = CodeUtil.GetTrueValue(S);

            // for each group
            // test if present, then code / negate, etc
            for (int g = 0; g < nbGroups; g++)
            {
                SB.AppendLine("");

                string funcName = GetZeroPartFunctionName(S, FT, g);

                SB.AppendLine("if (ac[" + g + "] != null) {");
                SB.AppendLine("\tif (!" + funcName + "(ac[" + g + "], " + FAI[1].Name + ")) return " + falseStr + ";");

                SB.AppendLine("}");

            }
            SB.AppendLine("return " + trueStr + ";");

            return SB.ToString();
        } // end of GetZeroCodeCSharpOrJava()


        /// <summary>
        /// Returns the code getting a bitmap of non-zero grades of a general multivector.
        /// The code is composed of calls to functions generated by <c>WriteCASNparts()</c>.
        /// 
        /// The returned code is only the body. The function declaration is not included.
        /// </summary>
        /// <param name="S">Specification of algebra (used for output language).</param>
        /// <param name="cgd">Currently not used.</param>
        /// <param name="FT">Floating point type.</param>
        /// <param name="FAI">Info about function arguments</param>
        /// <returns>code for the requested product type.</returns>
        public static string GetGradeBitmapCode(Specification S, G25.CG.Shared.CGdata cgd, G25.FloatType FT, G25.CG.Shared.FuncArgInfo[] FAI)
        {
            if (S.OutputCppOrC())
                return GetGradeBitmapCodeCppOrC(S, cgd, FT, FAI);
            else return GetGradeBitmapCodeCSharpOrJava(S, cgd, FT, FAI);
        }

        private static string GetGradeBitmapCodeCppOrC(Specification S, G25.CG.Shared.CGdata cgd, G25.FloatType FT, G25.CG.Shared.FuncArgInfo[] FAI)
        {
            G25.GMV gmv = S.m_GMV;

            StringBuilder SB = new StringBuilder();

            string agu = (S.OutputC()) ? FAI[0].Name + "->gu" : FAI[0].Name + ".gu()";
            string ac = (S.OutputC()) ? FAI[0].Name + "->c" : FAI[0].Name + ".getC()";

            SB.AppendLine("int idx = 0;");
            SB.AppendLine("int bitmap = 0;");

            // get number of groups:
            int nbGroups = gmv.NbGroups;

            // for each group
            // test if present, then code / negate, etc

            for (int g = 0; g < nbGroups; g++)
            {
                SB.AppendLine("");

                string funcName = GetZeroPartFunctionName(S, FT, g);

                SB.AppendLine("if (" + agu + " & " + (1 << g) + ") {");
                SB.AppendLine("\tif (!" + funcName + "(" + ac + " + idx, " + FAI[1].Name + ")) bitmap |= " + (1 << gmv.Group(g)[0].Grade()) + ";");

                if (g < (nbGroups - 1)) SB.AppendLine("\tidx += " + gmv.Group(g).Length + ";");

                SB.AppendLine("}");

            }
            SB.AppendLine("return bitmap;");

            return SB.ToString();
        } // end of GetGradeBitmapCodeCppOrC()

        private static string GetGradeBitmapCodeCSharpOrJava(Specification S, G25.CG.Shared.CGdata cgd, G25.FloatType FT, G25.CG.Shared.FuncArgInfo[] FAI)
        {
            G25.GMV gmv = S.m_GMV;

            StringBuilder SB = new StringBuilder();


            SB.AppendLine("int bitmap = 0;");
            SB.AppendLine(FT.type + "[][] ac = " + FAI[0].Name + ".c();");

            // get number of groups:
            int nbGroups = gmv.NbGroups;

            // for each group
            // test if present, then code / negate, etc

            for (int g = 0; g < nbGroups; g++)
            {
                SB.AppendLine("");

                string funcName = GetZeroPartFunctionName(S, FT, g);

                SB.AppendLine("if (ac[" + g + "] != null) {");
                SB.AppendLine("\tif (!" + funcName + "(ac[" + g + "], " + FAI[1].Name + ")) bitmap |= " + (1 << gmv.Group(g)[0].Grade()) + ";");

                SB.AppendLine("}");
            }
            SB.AppendLine("return bitmap;");

            return SB.ToString();
        } // end of GetGradeBitmapCodeCSharpOrJava()

        /// <summary>
        /// Returns the code for 'equals'.
        /// The code is composed of calls to functions generated by <c>WriteCASNparts()</c>.
        /// 
        /// The returned code is only the body. The function declaration is not included.
        /// </summary>
        /// <param name="S">Specification of algebra (used for general multivector type, output language).</param>
        /// <param name="cgd">Currently not used.</param>
        /// <param name="FT">Floating point type.</param>
        /// <param name="FAI">Info about function arguments.</param>
        /// <returns>code for the requested product type.</returns>
        public static string GetEqualsCode(Specification S, G25.CG.Shared.CGdata cgd, G25.FloatType FT,
            G25.CG.Shared.FuncArgInfo[] FAI)
        {
            if (S.OutputCppOrC()) return GetEqualsCodeCppOrC(S, cgd, FT, FAI);
            else return GetEqualsCodeCSharpOrJava(S, cgd, FT, FAI);
        }

        private static string GetEqualsCodeCppOrC(Specification S, G25.CG.Shared.CGdata cgd, G25.FloatType FT,
            G25.CG.Shared.FuncArgInfo[] FAI)
        {
            G25.GMV gmv = S.m_GMV;

            StringBuilder SB = new StringBuilder();

            SB.AppendLine("int aidx = 0, bidx = 0;");

            string agu = (S.OutputC()) ? FAI[0].Name + "->gu" : FAI[0].Name + ".gu()";
            string ac = (S.OutputC()) ? FAI[0].Name + "->c" : FAI[0].Name + ".getC()";
            string bgu = (S.OutputC()) ? FAI[1].Name + "->gu" : FAI[1].Name + ".gu()";
            string bc = (S.OutputC()) ? FAI[1].Name + "->c" : FAI[1].Name + ".getC()";

            // get number of groups, and possible assurances that a group is always present:
            int nbGroups = gmv.NbGroups;

            string falseStr = CodeUtil.GetFalseValue(S);
            string trueStr = CodeUtil.GetTrueValue(S);

            // for each group
            // test if present in both-> then add both, etc
            for (int g = 0; g < nbGroups; g++)
            {
                SB.AppendLine("");

                string equalsFuncName = GetEqualsPartFunctionName(S, FT, g);
                string zeroFuncName = GetZeroPartFunctionName(S, FT, g);

                SB.AppendLine("if (" + agu + " & " + (1 << g) + ") {");
                SB.AppendLine("\tif (" + bgu + " & " + (1 << g) + ") {");

                SB.AppendLine("\t\tif (!" + equalsFuncName + "(" + ac + " + aidx, " + bc + " + bidx, " + FAI[2].Name + ")) return " + falseStr + ";");
                if (g < (nbGroups - 1)) SB.AppendLine("\t\tbidx += " + gmv.Group(g).Length + ";");
                SB.AppendLine("\t}");
                SB.AppendLine("\telse if (!" + zeroFuncName + "(" + ac + " + bidx, " + FAI[2].Name + ")) return " + falseStr + ";");

                if (g < (nbGroups - 1)) SB.AppendLine("\taidx += " + gmv.Group(g).Length + ";");

                SB.AppendLine("}");
                SB.AppendLine("else if (" + bgu + " & " + (1 << g) + ") {");

                SB.AppendLine("\tif (!" + zeroFuncName + "(" + bc + " + bidx, " + FAI[2].Name + ")) return " + falseStr + ";");
                if (g < (nbGroups - 1)) SB.AppendLine("\tbidx += " + gmv.Group(g).Length + ";");

                SB.AppendLine("}");

            }
            SB.AppendLine("return " + trueStr + ";");

            return SB.ToString();
        } // end of GetEqualsCodeCppOrC()

        private static string GetEqualsCodeCSharpOrJava(Specification S, G25.CG.Shared.CGdata cgd, G25.FloatType FT,
            G25.CG.Shared.FuncArgInfo[] FAI)
        {
            G25.GMV gmv = S.m_GMV;

            StringBuilder SB = new StringBuilder();

            // get number of groups, and possible assurances that a group is always present:
            int nbGroups = gmv.NbGroups;

            string falseStr = CodeUtil.GetFalseValue(S);
            string trueStr = CodeUtil.GetTrueValue(S);

            // TODO: share this code everywhere
            bool resultIsScalar = false, initResultToZero = false;
            SB.Append(GPparts.GetExpandCode(S, cgd, FT, FAI, resultIsScalar, initResultToZero));

            // for each group
            // test if present in both-> then add both, etc
            for (int g = 0; g < nbGroups; g++)
            {
                SB.AppendLine("");

                string equalsFuncName = GetEqualsPartFunctionName(S, FT, g);
                string zeroFuncName = GetZeroPartFunctionName(S, FT, g);

                SB.AppendLine("if (ac[" + g + "] != null) {");
                SB.AppendLine("\tif (bc[" + g + "] != null) {");

                SB.AppendLine("\t\tif (!" + equalsFuncName + "(ac[" + g + "], bc[" + g + "], " + FAI[2].Name + ")) return " + falseStr + ";");
                SB.AppendLine("\t}");
                SB.AppendLine("\telse if (!" + zeroFuncName + "(ac[" + g + "], " + FAI[2].Name + ")) return " + falseStr + ";");

                SB.AppendLine("}");
                SB.AppendLine("\telse if (bc[" + g + "] != null) {");

                SB.AppendLine("\tif (!" + zeroFuncName + "(bc[" + g + "], " + FAI[2].Name + ")) return " + falseStr + ";");

                SB.AppendLine("}");

            }
            SB.AppendLine("return " + trueStr + ";");
            
            return SB.ToString();
        } // end of GetEqualsCodeCppOrC()

        /// <summary>
        /// Returns the code for grade selection for general multivectors.
        /// The code is composed of calls to functions generated by WriteCASNparts().
        /// 
        /// The returned code is only the body. The function declaration is not included.
        /// </summary>
        /// <param name="S">Specification of algebra (used for output language).</param>
        /// <param name="cgd">Used to resolve dependecy (<c>grade()</c> function).</param>
        /// <param name="FT">Floating point type.</param>
        /// <param name="gradeIdx">Grade of function (use -1 for user-specified)</param>
        /// <param name="FAI">Info about function arguments</param>
        /// <param name="resultName">Name of variable where the result goes (in the generated code).</param>
        /// <param name="groupBitmapName">Name of the (integer) variable which holds the groupBitmap.</param>
        /// <returns>code for the requested product type.</returns>
        public static string GetGradeCode(Specification S, G25.CG.Shared.CGdata cgd, G25.FloatType FT,
            int gradeIdx,
            G25.CG.Shared.FuncArgInfo[] FAI, string resultName, string groupBitmapName)
        {
            if (S.OutputCppOrC())
                return GetGradeCodeCppOrC(S, cgd, FT, gradeIdx, FAI, resultName, groupBitmapName);
            else return GetGradeCodeCSharpOrJava(S, cgd, FT, gradeIdx, FAI, resultName, groupBitmapName);
        }

        private static string GetGradeCodeCppOrC(Specification S, G25.CG.Shared.CGdata cgd, G25.FloatType FT,
            int gradeIdx,
            G25.CG.Shared.FuncArgInfo[] FAI, string resultName, string groupBitmapName)
        {
            G25.GMV gmv = S.m_GMV;
            if (gradeIdx >= 0)
            {  // if a specific grade is requested, convert it into a group bitmap, and call the grade(A, groupBitmap) function
                // get name of grade function
                //bool returnTrueName = false;
                string gradeFuncName = G25.CG.Shared.Dependencies.GetDependency(S, cgd, EXTRACT_GRADE, new string[] { gmv.Name }, FT, null);
                
                // turn grade into group
                int groupBitmap = gmv.GradeToGroupBitmap(gradeIdx);

                if (S.OutputC())
                {
                    return gradeFuncName + "(" + resultName + ", " + FAI[0].Name + ", " + groupBitmap + ");";
                }
                else
                {
                    return "return " + gradeFuncName + "(" + FAI[0].Name + ", " + groupBitmap + ");";
                }
            }
            else 
            {
                StringBuilder SB = new StringBuilder();

                // get indices into coordinates for input and output
                SB.AppendLine("int aidx = 0, cidx = 0;");

                string agu = (S.OutputC()) ? FAI[0].Name + "->gu" : FAI[0].Name + ".gu()";
                string ac = (S.OutputC()) ? FAI[0].Name + "->c" : FAI[0].Name + ".getC()";

                if (S.OutputC())
                {
                    SB.AppendLine(resultName + "->gu = " + agu +" & " + groupBitmapName + ";");
                }
                else 
                {
                    SB.AppendLine("int gu =  " + agu + " & " + groupBitmapName + ";");
                    SB.AppendLine(FT.type + " c[" + (1 << S.m_dimension) + "];");
                }


                string resultCoordPtr = (S.OutputC()) ? resultName + "->c" : "c";

                // for each group, test if present
                int nbGroups = gmv.NbGroups;
                for (int g = 0; g < nbGroups; g++)
                {
                    SB.AppendLine("");

                    string funcName = GetCopyPartFunctionName(S, FT, g);

                    SB.AppendLine("if (" + agu + " & " + (1 << g) + ") {");
                    SB.AppendLine("\tif (" + groupBitmapName + " & " + (1 << g) + ") {");
                    SB.AppendLine("\t\t" + funcName + "(" + ac + " + aidx, " + resultCoordPtr + " + cidx);");
                    if (g < (nbGroups - 1)) SB.AppendLine("\t\tcidx += " + gmv.Group(g).Length + ";");
                    SB.AppendLine("\t}");
                    if (g < (nbGroups - 1)) SB.AppendLine("\taidx += " + gmv.Group(g).Length + ";");
                    SB.AppendLine("}");
                }

                // return result
                if (S.m_outputLanguage != OUTPUT_LANGUAGE.C)
                {
                    SB.AppendLine("return " + FT.GetMangledName(S, gmv.Name) + "(gu, c);");
                }

                return SB.ToString();
            }

        } // end of GetGradeCodeCppOrC()

        private static string GetGradeCodeCSharpOrJava(Specification S, G25.CG.Shared.CGdata cgd, G25.FloatType FT,
            int gradeIdx,
            G25.CG.Shared.FuncArgInfo[] FAI, string resultName, string groupBitmapName)
        {
            G25.GMV gmv = S.m_GMV;
            if (gradeIdx >= 0)
            {  // if a specific grade is requested, convert it into a group bitmap, and call the grade(A, groupBitmap) function
                // get name of grade function
                string gradeFuncName = G25.CG.Shared.Dependencies.GetDependency(S, cgd, EXTRACT_GRADE, new string[] { gmv.Name }, FT, null);

                // turn grade into group
                int groupBitmap = gmv.GradeToGroupBitmap(gradeIdx);
                string castToGroupBitmap = (S.OutputCSharp()) ? "(GroupBitmap)" : "";
                return "return " + gradeFuncName + "(" + FAI[0].Name + ", " + castToGroupBitmap + groupBitmap + ");";
            }
            else
            {
                StringBuilder SB = new StringBuilder();

                int nbGroups = gmv.NbGroups;

                string GroupBitmapType = (S.OutputCSharp()) ? "GroupBitmap" : "int";
                SB.AppendLine(GroupBitmapType + " gu = " + FAI[0].Name + ".gu() " + " & " + groupBitmapName + ";");
                bool resultIsScalar = false, initResultToZero = false;
                SB.Append(GPparts.GetExpandCode(S, cgd, FT, FAI, resultIsScalar, initResultToZero));

                // for each group, test if present
                for (int g = 0; g < nbGroups; g++)
                {
                    SB.AppendLine("");

                    string funcName = GetCopyPartFunctionName(S, FT, g);

                    SB.AppendLine("if ((gu & GroupBitmap.GROUP_" + g + ") != 0) {");
                    SB.AppendLine("\tcc[" + g + "] = new " + FT.type + "[" + gmv.Group(g).Length + "];");
                    SB.AppendLine("\t" + funcName + "(ac[" + g + "], cc[" + g + "]);");
                    SB.AppendLine("}");
                }

                SB.AppendLine("return new " + FT.GetMangledName(S, gmv.Name) + "(cc);");

                return SB.ToString();
            }

        } // end of GetGradeCodeCSharpOrJava()

        public enum DIVCODETYPE
        {
            UNIT = 1,
            VERSOR_INVERSE = 2,
            DIV = 3
        };

        /// <summary>
        /// Returns the code for unit or versorInverse using metric <c>M</c>.
        /// The code is composed of calls to the <c>norm2()</c> function, 
        /// and to functions generated by <c>WriteCANSparts()</c>.
        /// 
        /// The generated function first compute the norm squared using the requested metric,
        /// and then divides the input multivector by it.
        /// 
        /// The returned code is only the body. The function declaration is not included.
        /// </summary>
        /// <param name="S">Specification of algebra (used for output language).</param>
        /// <param name="cgd">Used to resolve dependecy (<c>norm2()</c> function).</param>
        /// <param name="FT">Floating point type.</param>
        /// <param name="M">The metric of the dual.</param>
        /// <param name="FAI">Info about function arguments</param>
        /// <param name="resultName">Name of variable where the result goes (in the generated code).</param>
        /// <param name="funcType">What type of function (UNIT, VERSOR_INVERSE or DIV)</param>
        /// <returns>code for the requested product type.</returns>
        public static string GetDivCode(Specification S, G25.CG.Shared.CGdata cgd, G25.FloatType FT,
            G25.Metric M, G25.CG.Shared.FuncArgInfo[] FAI, string resultName, DIVCODETYPE funcType)
        {
            if (S.OutputCppOrC()) return GetDivCodeCppOrC(S, cgd, FT, M, FAI, resultName, funcType);
            else return GetDivCodeCSharpOrJava(S, cgd, FT, M, FAI, resultName, funcType);
        }

        private static string GetDivCodeCppOrC(Specification S, G25.CG.Shared.CGdata cgd, G25.FloatType FT,
            G25.Metric M, G25.CG.Shared.FuncArgInfo[] FAI, string resultName, DIVCODETYPE funcType)
        {
            G25.GMV gmv = S.m_GMV;

            StringBuilder SB = new StringBuilder();

            string normFuncName = G25.CG.Shared.Dependencies.GetDependency(S, cgd, (funcType == DIVCODETYPE.UNIT) ? "norm" : "norm2", new String[] { gmv.Name }, FT, M.m_name);
            string normVarName = (funcType == DIVCODETYPE.UNIT) ? "n" : "n2";

            string agu = (S.OutputC()) ? FAI[0].Name + "->gu" : FAI[0].Name + ".gu()";
            string ac = (S.OutputC()) ? FAI[0].Name + "->c" : FAI[0].Name + ".getC()";
            string resultCoordPtr = (S.OutputC()) ? resultName + "->c" : "c";

            SB.AppendLine("int idx = 0;");
            if ((funcType == DIVCODETYPE.UNIT) || (funcType == DIVCODETYPE.VERSOR_INVERSE))
            {
                // compute norm
                SB.AppendLine(FT.type + " " + normVarName + " = " + normFuncName + G25.CG.Shared.CANSparts.RETURNS_SCALAR + "(" + FAI[0].Name + ");");
            }

            // copy group usage
            if (S.OutputC())
            {
                SB.AppendLine(resultName + "->gu = " + agu + ";");
            }
            else
            {
                SB.AppendLine("int gu = " + agu + ";");
                SB.AppendLine(FT.type + " c[" + (1 << S.m_dimension) + "];");
            }

            // for each group present, copy and scale (for versor inverse, modulate with reverse)
            // for each group, test if present
            int nbGroups = gmv.NbGroups;
            for (int g = 0; g < nbGroups; g++)
            {
                SB.AppendLine("");

                // get func name
                string funcName = GetCopyDivPartFunctionName(S, FT, g);

                // get multiplier, normVarName string (depends on whether this is unit or versor inverse)
                string normString;
                if ((funcType == DIVCODETYPE.UNIT) || (funcType == DIVCODETYPE.VERSOR_INVERSE))
                {
                    double m = (funcType == DIVCODETYPE.UNIT) ? 1 : gmv.Group(g)[0].Reverse().scale / gmv.Group(g)[0].scale;
                    normString = ((m < 0) ? "-" : "") + normVarName;
                }
                else normString = FAI[1].Name;

                SB.AppendLine("if (" + agu + " & " + (1 << g) + ") {");
                SB.AppendLine("\t" + funcName + "(" + ac + " + idx, " + resultCoordPtr + " + idx, " + normString + ");");
                if (g < (nbGroups - 1)) SB.AppendLine("\tidx += " + gmv.Group(g).Length + ";");
                SB.AppendLine("}");
            }

            // return result
            if (S.m_outputLanguage != OUTPUT_LANGUAGE.C)
            {
                SB.AppendLine("return " + FT.GetMangledName(S, gmv.Name) + "(gu, c);");
            }

            return SB.ToString();
        } // GetDivCodeCppOrC()

        private static string GetDivCodeCSharpOrJava(Specification S, G25.CG.Shared.CGdata cgd, G25.FloatType FT,
            G25.Metric M, G25.CG.Shared.FuncArgInfo[] FAI, string resultName, DIVCODETYPE funcType)
        {
            G25.GMV gmv = S.m_GMV;
            int nbGroups = gmv.NbGroups;

            StringBuilder SB = new StringBuilder();

            string normFuncName = G25.CG.Shared.Dependencies.GetDependency(S, cgd, (funcType == DIVCODETYPE.UNIT) ? "norm" : "norm2", new String[] { gmv.Name }, FT, M.m_name);
            string normVarName = (funcType == DIVCODETYPE.UNIT) ? "n" : "n2";

            if ((funcType == DIVCODETYPE.UNIT) || (funcType == DIVCODETYPE.VERSOR_INVERSE))
            {
                // compute norm
                SB.AppendLine(FT.type + " " + normVarName + " = " + normFuncName + G25.CG.Shared.CANSparts.RETURNS_SCALAR + "(" + FAI[0].Name + ");");
            }


            bool resultIsScalar = false, initResultToZero = false;
            SB.Append(GPparts.GetExpandCode(S, cgd, FT, FAI, resultIsScalar, initResultToZero));

            // for each group present, copy and scale (for versor inverse, modulate with reverse)
            // for each group, test if present
            for (int g = 0; g < nbGroups; g++)
            {
                SB.AppendLine("");

                // get func name
                string funcName = GetCopyDivPartFunctionName(S, FT, g);

                // get multiplier, normVarName string (depends on whether this is unit or versor inverse)
                string normString;
                if ((funcType == DIVCODETYPE.UNIT) || (funcType == DIVCODETYPE.VERSOR_INVERSE))
                {
                    double m = (funcType == DIVCODETYPE.UNIT) ? 1 : gmv.Group(g)[0].Reverse().scale / gmv.Group(g)[0].scale;
                    normString = ((m < 0) ? "-" : "") + normVarName;
                }
                else normString = FAI[1].Name;
                //string allocCcode = "cc[" + g + "] = new " + FT.type + "[" + gmv.Group(g).Length + "];";
                SB.AppendLine("if (ac[" + g + "] != null) {");
                SB.AppendLine("\t" + funcName + "(ac[" + g + "], cc[" + g + "], " + normString + ");");
                SB.AppendLine("}");
            }

            SB.AppendLine("return new " + FT.GetMangledName(S, gmv.Name) + "(cc);");

            return SB.ToString();
        } // GetDivCodeCSharpOrJava()

        /// <summary>
        /// Returns the code for <c>scalar * gmv + scalar</c> (Scale and Add Scalar = SAS).
        /// This type of code is useful for evaluaing the sin, cos and exp.
        /// 
        /// The code is composed of calls to functions generated by <c>WriteCANSparts()</c>.
        /// 
        /// The returned code is only the body. The function declaration is not included.
        /// </summary>
        /// <param name="S">Specification of algebra (used for output language).</param>
        /// <param name="cgd">Currently not used.</param>
        /// <param name="FT">Floating point type.</param>
        /// <param name="FAI">Info about function arguments</param>
        /// <param name="resultName">Name of variable where the result goes (in the generated code).</param>
        /// <returns>code for the requested function.</returns>
        public static string GetSAScode(Specification S, G25.CG.Shared.CGdata cgd, G25.FloatType FT,
            G25.CG.Shared.FuncArgInfo[] FAI, String resultName)
        {
            G25.GMV gmv = S.m_GMV;

            StringBuilder SB = new StringBuilder();

            SB.AppendLine("int idxa = 0, idxc = 0;");

            string agu = (S.OutputC()) ? FAI[0].Name + "->gu" : FAI[0].Name + ".gu()";
            string ac = (S.OutputC()) ? FAI[0].Name + "->c" : FAI[0].Name + ".getC()";
            string resultCoordPtr = (S.OutputC()) ? resultName + "->c" : "C";

            // copy group usage / allocate memory for result
            if (S.OutputC())
            {
                SB.AppendLine(resultName + "->gu = " + agu + " | ((" + FAI[2].Name + " != 0.0) ? GRADE_0 : 0); // '| GRADE_0' to make sure the scalar part is included");
            }
            else
            {
                SB.AppendLine("int gu = " + agu + " | ((" + FAI[2].Name + " != 0.0) ? GRADE_0 : 0); // '| GRADE_0' to make sure the scalar part is included");
                SB.AppendLine(FT.type + " C[" + (1 << S.m_dimension) + "];");
            }


            // for each group present, copy and scale (for versor inverse, modulate with reverse)
            // for each group, test if present
            int nbGroups = gmv.NbGroups;
            for (int g = 0; g < nbGroups; g++)
            {
                SB.AppendLine("");

                // get func name
                string funcName = GetCopyMulPartFunctionName(S, FT, g);

                SB.AppendLine("if (" + agu + " & " + (1 << g) + ") {");
                SB.AppendLine("\t" + funcName + "(" + ac + " + idxa, " + resultCoordPtr + " + idxc, " + FAI[1].Name + ");");
                if (g == 0)
                { // also add scalar
                    SB.AppendLine("\tif (" + FAI[2].Name + " != 0.0) " + resultCoordPtr + "[idxc] += " + FAI[2].Name + ";");
                }
                if (g < (nbGroups - 1))
                {
                    SB.AppendLine("\tidxa += " + gmv.Group(g).Length + ";");
                    SB.AppendLine("\tidxc += " + gmv.Group(g).Length + ";");
                }
                SB.AppendLine("}");

                if (g == 0)
                { // always add the scalar:
                    SB.AppendLine("else if (" + FAI[2].Name + " != 0.0) {");
                    SB.AppendLine("\t" + resultCoordPtr + "[idxc] = " + FAI[2].Name + ";");
                    SB.AppendLine("\tidxc += " + gmv.Group(g).Length + ";");
                    SB.AppendLine("}");
                }
            }

            // return result
            if (S.m_outputLanguage != OUTPUT_LANGUAGE.C)
            {
                SB.AppendLine("return " + FT.GetMangledName(S, gmv.Name) + "(gu, C);");
            }

            return SB.ToString();
        } // end of GetSAScode()

        /// <summary>
        /// Returns the code for <c>gmv + scalar</c>
        /// 
        /// The code is NOT composed of calls to functions generated by <c>WriteCANSparts()</c>.
        /// 
        /// The returned code is only the body. The function declaration is not included.
        /// </summary>
        /// <param name="S">Specification of algebra (used for output language).</param>
        /// <param name="cgd">Currently not used.</param>
        /// <param name="FT">Floating point type.</param>
        /// <param name="FAI">Info about function arguments</param>
        /// <param name="resultName">Name of variable where the result goes (in the generated code).</param>
        /// <param name="increment">Whether write increment or decrement function.</param>
        /// <returns>code for the requested function.</returns>
        public static string GetIncrementCode(Specification S, G25.CG.Shared.CGdata cgd, G25.FloatType FT,
            G25.CG.Shared.FuncArgInfo[] FAI, string resultName, bool increment)
        {
            G25.GMV gmv = S.m_GMV;

            StringBuilder SB = new StringBuilder();

            if (S.OutputC())
            {
                SB.AppendLine(FT.type + " val" + " = " +
                    FAI[0].MangledTypeName + "_" + gmv.Group(0)[0].ToLangString(S.m_basisVectorNames) + "(" + FAI[0].Name + ")" +
                    ((increment) ? " + " : " - ") + FT.DoubleToString(S, 1.0) + ";");

                SB.AppendLine(FAI[0].MangledTypeName + "_copy(" + resultName + ", " + FAI[0].Name + ");");
                SB.AppendLine(FAI[0].MangledTypeName + "_set_" + gmv.Group(0)[0].ToLangString(S.m_basisVectorNames) + "(" + resultName + ", val);");
            }
            else
            {
                if (S.OutputCpp())
                    SB.AppendLine(FAI[0].MangledTypeName + " " + resultName + "(" + FAI[0].Name + ");");
                else SB.AppendLine(FAI[0].MangledTypeName + " " + resultName + " = new " + FAI[0].MangledTypeName + "(" + FAI[0].Name + ");");
                SB.AppendLine(FT.type + " val" + " = " + resultName + ".get_" + gmv.Group(0)[0].ToLangString(S.m_basisVectorNames) + "()" +
                    ((increment) ? " + " : " - ") + FT.DoubleToString(S, 1.0) + ";");
                SB.AppendLine(resultName + ".set_" + gmv.Group(0)[0].ToLangString(S.m_basisVectorNames) + "(val);");
                SB.AppendLine("return " + resultName + ";");
            }

            return SB.ToString();
        } // end of GetIncrementCode()

    } // end of class CANSparts
} // end of namepace G25.CG.Shared

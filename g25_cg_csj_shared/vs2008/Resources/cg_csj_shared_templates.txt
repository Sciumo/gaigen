// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// gmvName = name of GMV class
// fabsFunc = name of floating point absolute function
${CODEBLOCK GMVlargestCoordinate}
<%if (S.m_outputLanguage == G25.OUTPUT_LANGUAGE.CSHARP) {%>
	/// <summary>returns the absolute largest coordinate.</summary>
<%} else {%>
	/** returns the absolute largest coordinate.*/
<%}%>
	public <%FT.type%> <%G25.CG.CSJ.Util.GetFunctionName(S, "largestCoordinate")%>() {
		<%FT.type%> maxValue = <%FT.DoubleToString(S, 0.0)%>, C;
		for (int g = 0; g < m_c.<%G25.CG.CSJ.Util.GetFunctionName(S, "length")%>; g++) {
			if (m_c[g] != null) {
				<%FT.type%>[] Cg = m_c[g];
				for (int b = 0; b < Cg.<%G25.CG.CSJ.Util.GetFunctionName(S, "length")%>; b++) {
					C = <%fabsFunc%>(Cg[b]);
					if (C > maxValue) {
						maxValue = C;
					}
				}
			}
		}
		return maxValue;
	}
	
<%if (S.m_outputLanguage == G25.OUTPUT_LANGUAGE.CSHARP) {%>
	/// <summary>returns the absolute largest coordinate and the corresponding basis blade bitmap (in 'bm') .</summary>
	public <%FT.type%> <%G25.CG.CSJ.Util.GetFunctionName(S, "largestBasisBlade")%>(ref int bm) {
<%} else {%>
	/** returns the absolute largest coordinate (entry [0]), and the corresponding basis blade bitmap (entry [1])  */
	public <%FT.type%>[] <%G25.CG.CSJ.Util.GetFunctionName(S, "largestBasisBlade")%>() {
<%}%>
		<%FT.type%> maxC = <%FT.DoubleToString(S, -1.0)%>, C;

		int idx = 0; // global index into coordinates (run from 0 to <%S.m_GMV.NbCoordinates%>).
<%if (S.m_outputLanguage == G25.OUTPUT_LANGUAGE.JAVA) {%>
		int bm; // bitmap of basis blade
<%}%>
		bm = 0;
		
		for (int g = 0; g < m_c.<%G25.CG.CSJ.Util.GetFunctionName(S, "length")%>; g++) {
			if (m_c[g] != null) {
				<%FT.type%>[] Cg = m_c[g];
				for (int b = 0; b < m_c[g].<%G25.CG.CSJ.Util.GetFunctionName(S, "length")%>; b++) {
					C = <%fabsFunc%>(Cg[b]);
					if (C > maxC) {
						maxC = C;
						bm = <%S.m_namespace%>.BasisElementBitmapByIndex[idx];
					}
					idx++;
				}
			
			}
			else idx += <%S.m_namespace%>.GroupSize[g];
		}

<%if (S.m_outputLanguage == G25.OUTPUT_LANGUAGE.CSHARP) {%>
		return maxC;
<%} else {%>
		return new <%FT.type%>[]{maxC, (<%FT.type%>)bm};
<%}%>
	} // end of <%G25.CG.CSJ.Util.GetFunctionName(S, "largestBasisBlade")%>()
	
${ENDCODEBLOCK}


// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
// userComment
${CODEBLOCK seriesExp}
<%new G25.CG.Shared.Comment("Computes exponential of " + inputType + " up to 12th term.\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x) {
	return <%funcName%>(x, 12);
}

<%new G25.CG.Shared.Comment("Computes exponential of " + inputType + ".\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x, <%if (S.OutputJava()) {%>final <%}%>int order) {
   
	{ // First try special cases: check if (x * x) is scalar
		<%returnType%> xSquared = <%gpFuncII%>(x, x);
		<%FT.type%> s_xSquared = xSquared.get_scalar();
		if ((<%normE2funcR%>(xSquared) - s_xSquared * s_xSquared) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
			// OK (x * x == ~scalar), so use special cases:
			if (s_xSquared < <%FT.DoubleToString(S, 0.0)%>) {
				<%FT.type%> a = <%sqrtFunc%>(-s_xSquared);
				return <%SASfuncI%>(x, <%sinFunc%>(a) / a, <%cosFunc%>(a));
			}
			else if (s_xSquared > <%FT.DoubleToString(S, 0.0)%>) {
				<%FT.type%> a = <%sqrtFunc%>(s_xSquared);
				return <%SASfuncI%>(x, <%sinhFunc%>(a) / a, <%coshFunc%>(a));
			}
			else {
				return <%SASfuncI%>(x, <%FT.DoubleToString(S, 1.0)%>, <%FT.DoubleToString(S, 1.0)%>);
			}
		}
	}

	// else do general series eval . . .

	// result = 1 + ....	
	<%returnType%> result = new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>);
	if (order == 0) return result;

	// find scale (power of 2) such that its norm is < 1
	<%if (S.OutputCSharp()) {%>u<%}%>long maxC = (<%if (S.OutputCSharp()) {%>u<%}%>long)x.<%G25.CG.CSJ.Util.GetFunctionName(S, "largestCoordinate")%>();
	int scale = 1;
	if (maxC > 1) scale <<= 1;
	while (maxC != 0)
	{
		maxC >>= 1;
		scale <<= 1;
	}

	// scale
	<%inputType%> xScaled = <%gpFuncIdouble%>(x, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)scale); 

	// taylor series approximation
	<%returnType%> xPow1 = new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>); 
	for (int i = 1; i <= order; i++) {
		<%returnType%> xPow2 = <%gpFuncRI%>(xPow1, xScaled);
		xPow1 = <%gpFuncRdouble%>(xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i);
		
		result = <%addFuncRR%>(result, xPow1); // result2 = result1 + xPow1
    }

	// undo scaling
	while (scale > 1)
	{
		result = <%gpFuncRR%>(result, result);
		scale >>= 1;
	}
    
    return result;
} // end of <%funcName%>()

${ENDCODEBLOCK}


// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesSinh}
<%new G25.CG.Shared.Comment("Computes hyperbolic sine of " + inputType + " up to 12th term.\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x) {
	return <%funcName%>(x, 12);
}

<%new G25.CG.Shared.Comment("Computes hyperbolic sine of " + inputType + ".\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x, <%if (S.OutputJava()) {%>final <%}%>int order) {
   
	{ // First try special cases: check if (x * x) is scalar
		<%returnType%> xSquared = <%gpFuncII%>(x, x);
		<%FT.type%> s_xSquared = xSquared.get_scalar();
		if ((<%normE2funcR%>(xSquared) - s_xSquared * s_xSquared) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
			// OK (x * x == ~scalar), so use special cases:
			if (s_xSquared < <%FT.DoubleToString(S, 0.0)%>) {
				<%FT.type%> a = <%sqrtFunc%>(-s_xSquared);
				return <%SASfuncI%>(x, <%sinFunc%>(a) / a, <%FT.DoubleToString(S, 0.0)%>);
			}
			else if (s_xSquared > <%FT.DoubleToString(S, 0.0)%>) {
				<%FT.type%> a = <%sqrtFunc%>(s_xSquared);
				return <%SASfuncI%>(x, <%sinhFunc%>(a) / a, <%FT.DoubleToString(S, 0.0)%>);
			}
			else {
<%if ((returnType != inputType) && (returnType != FT.GetMangledName(S, S.m_GMV.Name))) {%>
				return <%copyInputToReturnFunc%>(x);
<%} else {%>
				return x;
<%}%>
			}
		}
	}

	// else do general series eval . . .

	// result = A +  A^3/3! + A^5/5!
	<%returnType%> result = new <%returnType%>(); // result = 0
    if (order == 0) return result;
    	
	// taylor series approximation
	<%returnType%> xPow1 = new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>);
	for (int i = 1; i <= order; i++) {
		<%returnType%> xPow2 = <%gpFuncRI%>(xPow1, x); // xPow2 = xPow1 * x
		xPow1 = <%gpFuncRdouble%>(xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i); // xPow1 = xScaled^i / i! 
		
		if ((i % 2) == 1) {
			result = <%addFuncRR%>(result, xPow1); 
		}
	}

    return result;
} // end of <%funcName%>()
${ENDCODEBLOCK}

// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesCosh}
<%new G25.CG.Shared.Comment("Computes hyperbolic cosine of " + inputType + " up to 12th term.\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x) {
	return <%funcName%>(x, 12);
}

<%new G25.CG.Shared.Comment("Computes hyperbolic cosine of " + inputType + ".\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x, <%if (S.OutputJava()) {%>final <%}%>int order) {
   
	{ // First try special cases: check if (x * x) is scalar
		<%returnType%> xSquared = <%gpFuncII%>(x, x);
		<%FT.type%> s_xSquared = xSquared.get_scalar();
		if ((<%normE2funcR%>(xSquared) - s_xSquared * s_xSquared) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
			// OK (x * x == ~scalar), so use special cases:
			if (s_xSquared > <%FT.DoubleToString(S, 0.0)%>) {
				return new <%returnType%>(<%coshFunc%>(<%sqrtFunc%>(s_xSquared)));
			}
			else if (s_xSquared < <%FT.DoubleToString(S, 0.0)%>) {
				return new <%returnType%>(<%cosFunc%>(<%sqrtFunc%>(-s_xSquared)));
			}
			else {
				return new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>);
			}
		}
	}

	// else do general series eval . . .


	<%returnType%> result = new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>);
	if (order == 0) return result;

	// taylor series approximation
	<%returnType%> xPow1 = new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>);
	for (int i = 1; i <= order; i++) {
		<%returnType%> xPow2 = <%gpFuncRI%>(xPow1, x);
		xPow1 = <%gpFuncRdouble%>(xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i); // xPow1 = xScaled^i / i! 
		
		if ((i % 2) == 0) {
			result = <%addFuncRR%>(result, xPow1); 
		}
    }

    return result;
} // end of <%funcName%>()
${ENDCODEBLOCK}


// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesSin}
<%new G25.CG.Shared.Comment("Computes sine of " + inputType + " up to 12th term.\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x) {
	return <%funcName%>(x, 12);
}

<%new G25.CG.Shared.Comment("Computes sine of " + inputType + ".\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x, <%if (S.OutputJava()) {%>final <%}%>int order) {
   
	{ // First try special cases: check if (x * x) is scalar
		<%returnType%> xSquared = <%gpFuncII%>(x, x);
		<%FT.type%> s_xSquared = xSquared.get_scalar();
		if ((<%normE2funcR%>(xSquared) - s_xSquared * s_xSquared) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
			// OK (x * x == ~scalar), so use special cases:
			if (s_xSquared < <%FT.DoubleToString(S, 0.0)%>) {
				<%FT.type%> a = <%sqrtFunc%>(-s_xSquared);
				return <%SASfuncI%>(x, <%sinhFunc%>(a) / a, <%FT.DoubleToString(S, 0.0)%>);
			}
			else if (s_xSquared > <%FT.DoubleToString(S, 0.0)%>) {
				<%FT.type%> a = <%sqrtFunc%>(s_xSquared);
				return <%SASfuncI%>(x, <%sinFunc%>(a) / a, <%FT.DoubleToString(S, 0.0)%>);
			}
			else {
<%if ((returnType != inputType) && (returnType != FT.GetMangledName(S, S.m_GMV.Name))) {%>
				return <%copyInputToReturnFunc%>(x);
<%} else {%>
				return x;
<%}%>
			}
		}
	}

	// else do general series eval . . .

	// result = A -  ....	+ ... - ...
	<%returnType%> result = new <%returnType%>(); // result = 0;
    if (order == 0) return result;
    	
	// taylor series approximation
	<%returnType%> xPow1 = new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>); // xPow1 = 1.0
	for (int i = 1; i <= order; i++) {
		<%returnType%> xPow2 = <%gpFuncRI%>(xPow1, x); // xPow2 = xPow1 * x
		
		xPow1 = <%gpFuncRdouble%>(xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i); // xPow1 = xScaled^i / i! 
		
		if ((i % 4) == 3)
		{
			result = <%subFuncRR%>(result, xPow1); // result = result - xPow1
		}
		else if ((i % 4) == 1) 
		{
			result = <%addFuncRR%>(result, xPow1); // result = result + xPow1
		}
	}

	return result;
} // end of <%funcName%>()

${ENDCODEBLOCK}

// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesCos}
<%new G25.CG.Shared.Comment("Computes cosine of " + inputType + " up to 12th term.\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x) {
	return <%funcName%>(x, 12);
}

<%new G25.CG.Shared.Comment("Computes cosine of " + inputType + ".\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x, <%if (S.OutputJava()) {%>final <%}%>int order) {
	{ // First try special cases: check if (x * x) is scalar
		<%returnType%> xSquared = <%gpFuncII%>(x, x);
		<%FT.type%> s_xSquared = xSquared.get_scalar();
		if ((<%normE2funcR%>(xSquared) - s_xSquared * s_xSquared) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
			// OK (x * x == ~scalar), so use special cases:
			if (s_xSquared > <%FT.DoubleToString(S, 0.0)%>) {
				return new <%returnType%>(<%cosFunc%>(<%sqrtFunc%>(s_xSquared)));
			}
			else if (s_xSquared < <%FT.DoubleToString(S, 0.0)%>) {
				return new <%returnType%>(<%coshFunc%>(<%sqrtFunc%>(-s_xSquared)));
			}
			else {
				return new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>);
			}
		}
	}

	// else do general series eval . . .


	<%returnType%> result = new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>);
	if (order == 0) return result;

	// taylor series approximation
	<%returnType%> xPow1 = new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>); // xPow1 = 1.0
	for (int i = 1; i <= order; i++) {
		<%returnType%> xPow2 = <%gpFuncRI%>(xPow1, x); // xPow2 = xPow1 * x
		xPow1 = <%gpFuncRdouble%>(xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i); // xPow1 = xScaled^i / i! 
		
		if ((i % 4) == 2)
		{
			result = <%subFuncRR%>(result, xPow1); // result2 = result1 - xPow1
		}
		else if ((i % 4) == 0) 
		{
			result = <%addFuncRR%>(result, xPow1); // result2 = result1 + xPow1
		}		
    }

	return result;
} // end of <%funcName%>()
${ENDCODEBLOCK}

// S = Specification of algebra.
// functionName = name of generated function
// FT = floating point type
// mvType = multivector type name (with prefix/suffix)
// randomScalarFuncName = name of function which generates random scalar values
// gpopFuncName = name of geometric product or outer product function for two multivectors
// normFuncName = norm of multivector function (must return scalar)
// gpScalarFuncName = geometric product of multivector and scalar
// generatorVersor = bool (use geometric product or outer product)
${CODEBLOCK randomBladeVersor}

<%new G25.CG.Shared.Comment("Generates a random " + ((generatorVersor) ? "versor" : "blade") + ".\n"+
	"The scale is uniformly distributed over the interval [0 1).\n" + 
	"The maximum non-zero grade-part is 'grade'.\n" + 
	"\n" + 
	"Only the basis vectors marked in 'basisVectorBitmap' will be used to generate the versor/blade.\n" + 
	"Use 'basisVectorBitmap = -1' (the default) to use all basisvectors.").
	SetReturnComment(functionName + "_ex(arg1, scale, grade, basisVectorBitmap, 0.01, scale * 4.0)").
	ToString(S, 0)%>
public static <%mvType%> <%functionName%>(<%FT.type%> scale, int grade, int basisVectorBitmap) {
	<%FT.type%> minimumNorm = <%FT.DoubleToString(S, 0.01)%>;
	<%FT.type%> largestCoordinate = <%FT.DoubleToString(S, 4.0)%>;
	return <%functionName%>_ex(scale, grade, basisVectorBitmap, minimumNorm, scale * largestCoordinate);
}

<%new G25.CG.Shared.Comment("This version of " + functionName + "() has extra arguments which help to avoid\n" + 
	"near-singular blades / versors.\n" + 
	"\n" + 
	"Near-singular blades / versors are avoid by testing the norm and largest coordinate\n" + 
	"of the random blade / versor. If the test does not pass, the function recursively\n" + 
	"tries to generate another random blade / versor.\n" + 
	"\n" + 
	"'minimumNorm' is the minimum allowed norm of the blade/versor before scaling. \n" + 
	"'minimumNorm' must be > 0.0 for versors.\n" + 
	"\n" + 
	"'largestCoordinate' is the largest coordinate allowed after scaling.\n").
	SetReturnComment(functionName + "_ex(arg1, scale, grade, basisVectorBitmap, 0.01, scale * 4.0)").
	ToString(S, 0)%>
public static <%mvType%> <%functionName%>_ex(<%FT.type%> scale, int _grade, int basisVectorBitmap, 
		<%FT.type%> minimumNorm, <%FT.type%> largestCoordinate) 
{
	<%mvType%> randomVector = new <%mvType%>();
	//, tmp1, tmp2;
	<%FT.type%>[] randomValues = new <%FT.type%>[<%S.m_dimension%>];
	//<%FT.type%> n2, mul;
	int grade = _grade;
	
	// set IR (intermediate result) to 1
	<%mvType%> IR = new <%mvType%> (<%FT.DoubleToString(S, 1.0)%>);

	while (grade > 0) {	// loop until grade == 0
		// fill array with random values
		for (int i = 0; i < <%S.m_dimension%>; i++) 
			randomValues[i] = ((basisVectorBitmap & (1 << i)) == 0)
				? <%FT.DoubleToString(S, 0.0)%> 
				: (<%FT.DoubleToString(S, -1.0)%> + <%FT.DoubleToString(S, 2.0)%> * <%randomScalarFuncName%>());
		
		// make it a multivector:
		randomVector.<%G25.CG.CSJ.Util.GetFunctionName(S, "set")%>(GroupBitmap.GRADE_1, randomValues);
		
		// multiply 
		IR = <%gpopFuncName%>(IR, randomVector);
		
		// lower grade
		grade--;
	}
	
	// compute norm/multiplier, apply it, or recurse if we happened to create a near-null versor
	<%FT.type%> n2 = <%normFuncName%>(IR);
	if ((<%FT.type%>)<%G25.CG.Shared.CodeUtil.OpNameToLangString(S, FT, RefGA.Symbolic.UnaryScalarOp.ABS)%>(n2) > minimumNorm * minimumNorm) {
		if (n2 != <%FT.DoubleToString(S, 0.0)%>) {
			<%FT.type%> mul = scale * <%randomScalarFuncName%>() / n2;
			if (IR.<%G25.CG.CSJ.Util.GetFunctionName(S, "largestCoordinate")%>() * mul < largestCoordinate)
				return <%gpScalarFuncName%>(IR, mul);
		}
		else if (IR.<%G25.CG.CSJ.Util.GetFunctionName(S, "largestCoordinate")%>() < largestCoordinate)
			return IR;
	}
	
	// try again:
	return <%functionName%>_ex(scale, _grade, basisVectorBitmap, minimumNorm, largestCoordinate); 
}
${ENDCODEBLOCK}




// S = Specification of algebra.
${CODEBLOCK ParseExceptionSource_Java}
package <%S.m_namespace%>_pkg;

public class ParseException extends Exception {
	private static final long serialVersionUID = 1L;

	public ParseException(String message)
    {
    	super(message);
    }
}
${ENDCODEBLOCK}

// S = Specification of algebra.
${CODEBLOCK ParseExceptionSource_CSharp}
using System;

namespace <%S.m_namespace%>_ns {
	/// <summary>This exception is throws by parse() when there is an error in the input.</summary>
    public class ParseException : Exception
    {
        public ParseException(String message)
            : base(message)
        {
        }
    }
}
${ENDCODEBLOCK}


// S = Specification of algebra.
// FT = float type to be used
${CODEBLOCK BuiltinParserSource_CSharp_Java}
<%{
	string BOOL_TYPE = (S.OutputJava()) ? "boolean" : "bool";
	string FINAL = (S.OutputJava()) ? "final " : "";
	string CONST = (S.OutputJava()) ? "" : "const ";
%>


<%if (S.OutputJava()) {%>
package <%S.m_namespace%>_pkg;
<%} else {%>
namespace <%S.m_namespace%>_ns {
<%}%>

	public class Parser {
		private class BasisBlade
		{
			private int bitmap = 0;
			private <%FT.type%> scale = <%FT.DoubleToString(S, 1.0)%>;

			public int getBitmap() { return bitmap;  }
			public <%FT.type%> getScale() { return scale;  }

			public void wedgeBasisVector(int bvIdx)
			{
				int b;

				b = 1 << bvIdx;
				if ((bitmap & b) != 0)
				{ // bv ^ bv = 0
					scale = <%FT.DoubleToString(S, 0.0)%>;
					return;
				}
				else
				{
					// add basis vector to bitmap	
					bitmap |= b;

					bvIdx++;
					for (; bvIdx <= <%S.m_dimension%>; bvIdx++) // compute sign flips due to anti commuting basis vectors
						if ((bitmap & (1 << bvIdx)) != 0) scale = -scale;
				}
			}

			public void multiply(<%FT.type%> scalar)
			{
				scale *= scalar;
			}
		}

		private String inputString;
		private String sourceString;
		private int startIdx = 0;
		private int endIdx = 0;
		private int lineIdx = 0;
		private int currentLineStart = 0;
		private <%FT.type%>[] coord = new <%FT.type%>[<%1 << S.m_dimension%>];

		// TOKEN IDs: (for internal use only)
		private <%FINAL%><%CONST%>int T_BAD_IDENTIFIER = -100;
		private <%FINAL%><%CONST%>int T_BAD_NUMBER = -10;
		private <%FINAL%><%CONST%>int T_BAD_CHARACTER = -1;
		private <%FINAL%><%CONST%>int T_END_OF_STRING = 0;
		private <%FINAL%><%CONST%>int T_WEDGE = 1;
		private <%FINAL%><%CONST%>int T_MUL = 2;
		private <%FINAL%><%CONST%>int T_PLUS = 3;
		private <%FINAL%><%CONST%>int T_MINUS = 4;
		private <%FINAL%><%CONST%>int T_NUMBER = 10;
		private <%FINAL%><%CONST%>int T_FIRST_BASIS_VECTOR = 100;
		private <%FINAL%><%CONST%>int T_LAST_BASIS_VECTOR = <%100 + S.m_dimension%>;

		private <%FINAL%>ParseException GetException(<%FINAL%>String reason)
		{
			return new ParseException(reason + " at " + sourceString + ", line " + (lineIdx+1) + ", column " + (startIdx - currentLineStart +1));
		}

		private Parser(<%FINAL%>String input, <%FINAL%>String source) {
			inputString = input;
			sourceString = source;
			if ((sourceString == null) || (length(sourceString) == 0))
				sourceString = "string";
		}

		private <%FINAL%>void sum(<%FINAL%>BasisBlade bb) {
			int idx = <%S.m_namespace%>.BasisElementIndexByBitmap[bb.getBitmap()];
			coord[idx] += bb.getScale() / (<%FT.type%>)<%S.m_namespace%>.BasisElementSignByIndex[idx];
		}

	<%if (S.OutputJava()) {%>
		private final static boolean isLetter(final char x) {
    		return Character.isLetter(x);
		}
		private final static boolean isDigit(final char x) {
    		return Character.isDigit(x);
		}
		private final static boolean isLetterOrDigit(final char x) {
    		return Character.isLetterOrDigit(x);
		}
		private final String substring(final int startIdx, final int endIdx) {
    		return inputString.substring(startIdx, endIdx+1); // endIdx of String.substring is exclusive!
		}
		private final static int length(final String str) {
    		return str.length();
		}
		private final static char charAt(final String str, final int idx) {
    		return str.charAt(idx);
		}
	<%} else {%>
		private static bool isLetter(char x) {
    		return Char.IsLetter(x);
		}
		private static bool isDigit(char x) {
    		return Char.IsDigit(x);
		}
		private static bool isLetterOrDigit(char x) {
    		return Char.IsLetterOrDigit(x);
		}
		private String substring(int startIdx, int endIdx) {
    		return inputString.Substring(startIdx, endIdx - startIdx + 1);
		}
		private static int length(String str) {
    		return str.Length;
		}
		private static char charAt(String str, int idx) {
    		return str[idx];
		}    
	<%}%>
	   

		private <%FINAL%>int getNextToken() {
			int l = length(inputString);
			
			// skip all whitespace and other empty stuff, keep track of line index
			while ((startIdx < l) && (charAt(inputString, startIdx) >= 0) && (charAt(inputString, startIdx) <= ' ')) {
				if (charAt(inputString, startIdx) == 0x0A) { // start of new line
					lineIdx++;
					currentLineStart = startIdx+1;
				}
				startIdx++;
			}

			// detect end of string
			if (startIdx == l) {
				startIdx = endIdx;
				return T_END_OF_STRING; // EOS
			}

			// operators
			if (charAt(inputString, startIdx) == '^') {endIdx = startIdx; return T_WEDGE;} // ^
			else if (charAt(inputString, startIdx) == '*') {endIdx = startIdx; return T_MUL;} // *
			else if (charAt(inputString, startIdx) == '+') {endIdx = startIdx; return T_PLUS;} // +
			else if (charAt(inputString, startIdx) == '-') {endIdx = startIdx; return T_MINUS;} // -

			else if (isDigit(charAt(inputString, startIdx)) || (charAt(inputString, startIdx) == '.')) { // parse number?
				endIdx = startIdx;

				// eat up all digits and at most one point
				<%BOOL_TYPE%> pointFound = false;
				while ((endIdx < l) && (isDigit(charAt(inputString, endIdx)) || (charAt(inputString, endIdx) == '.'))) {
					endIdx++;
					if (charAt(inputString, endIdx) == '.') {
						endIdx++;
						pointFound = true;
						break;
					}
				}
	    		
				if (pointFound) { // if point found, eat up all digits
					while ((endIdx < l) && isDigit(charAt(inputString, endIdx))) {
						endIdx++;
					}
				}

				// see if there is a 'e' or 'E'
				if  ((charAt(inputString, endIdx) == 'e') || (charAt(inputString, endIdx) == 'E')) {
					endIdx++;
					// accept at most one +-
					if  ((charAt(inputString, endIdx) == '-') || (charAt(inputString, endIdx) == '+')) {
						endIdx++;
					}

					// if there is an 'e', there must be some digit
					if (!isDigit(charAt(inputString, endIdx))) return T_BAD_NUMBER; // bad number

					// eat up all digits
					while ((endIdx < l) && isDigit(charAt(inputString, endIdx))) {
						endIdx++;
					}
				}
				endIdx--; // end index is inclusive
				return T_NUMBER;
			}

			else if (isLetter(charAt(inputString, startIdx)) || (charAt(inputString, startIdx) == '_')) { // parse identifier?
				// find end of chain of numbers, letters and '_'
				endIdx = startIdx + 1;

				while ((endIdx < l) && (isLetterOrDigit(charAt(inputString, endIdx)) || (charAt(inputString, endIdx) == '_'))) endIdx++;
				endIdx--;  // end index is inclusive

				// see which basis vector it is
				String bvName = substring(startIdx, endIdx);
				for (int i = 0; i < <%S.m_dimension%>; i++)
					if (<%S.m_namespace%>.BasisVectorNames[i].<%G25.CG.CSJ.Util.GetFunctionName(S, "equals")%>(bvName)) return T_FIRST_BASIS_VECTOR + i; // basis vector
				return T_BAD_IDENTIFIER; // bad identifier
			}

			else return T_BAD_CHARACTER;
		} // end of getNextToken()

<%new G25.CG.Shared.Comment("Parses a multivector string (e.g., as created by " + FT.GetMangledName(S, S.m_GMV.Name) + ".ToString())\nThrows a ParseException when the input cannot be parsed.\n").
			SetParamComment("str", "The multivector string.").
			SetParamComment("strSourceName", "Description of where the string came from (may be null). This string is used in exception messages.").
			ToString(S, 2)%>
		public <%FINAL%>static <%FT.GetMangledName(S, S.m_GMV.Name)%> <%G25.CG.CSJ.Util.GetFunctionName(S, "parse")%>(<%FINAL%>String str, <%FINAL%>String strSourceName) <%if (S.OutputJava()) {%>throws ParseException<%}%> 
		{
			return new Parser(str, strSourceName).<%G25.CG.CSJ.Util.GetFunctionName(S, "parse")%>();
		}
	    
		private <%FINAL%><%FT.GetMangledName(S, S.m_GMV.Name)%> <%G25.CG.CSJ.Util.GetFunctionName(S, "parse")%>() <%if (S.OutputJava()) {%>throws ParseException <%}%>{
			int token;
			<%BOOL_TYPE%> firstLoop = true;

			// get the first token
			token = getNextToken();

			while (true) {
				// reset for next basis blade
				BasisBlade bb = new BasisBlade();
				<%BOOL_TYPE%> beDone = false; // basis element done

				if (token == T_END_OF_STRING) break;

				int cnt = 0;
				while ((token == T_PLUS) || (token == T_MINUS)) { // accept all +- 
					cnt++;
					startIdx = endIdx+1;
					if (token == T_MINUS) bb.multiply(<%FT.DoubleToString(S, -1.0)%>); // -
					token = getNextToken();
				}
	    		
				// require at least one +- if this is not the first term:
				if ((!firstLoop) && (cnt == 0)) {
					throw GetException("Expected '+' or '-'");
				}

				if ((token == T_NUMBER) || 
					((token >= T_FIRST_BASIS_VECTOR) && (token <= T_LAST_BASIS_VECTOR))) // must be number or basis vector
				{ 
					if (token == T_NUMBER) {
						{ // multiply scale with value of number
							try {
								bb.multiply((<%FT.type%>)Double.<%if (S.OutputJava()) {%>parseDouble<%} else {%>Parse<%}%>(substring(startIdx, endIdx)));
							} catch (Exception <%if (S.OutputJava()) {%>ex<%}%>) {
								throw GetException("Cannot parse number"); 
							}
						}
						startIdx = endIdx+1;

						// * or ^ ?
						token = getNextToken();
						if ((token == T_WEDGE) || (token == T_MUL)) {
							startIdx = endIdx+1;

							// must find basis vector
							token = getNextToken();
						}
						else { // just a single scalar is OK
							startIdx = endIdx+1;
							beDone = true;
						}

					}

					if (!beDone) {
						if ((token >= T_FIRST_BASIS_VECTOR) && (token <= T_LAST_BASIS_VECTOR)) {
							int bvIdx = token - T_FIRST_BASIS_VECTOR;
							bb.wedgeBasisVector(bvIdx);
							startIdx = endIdx+1;
						}
						else {
							throw GetException("Expected basis vector");
						}
					}

					if (!beDone) {
						// accept ^ basis vector as many times as it takes
						while (true) {
							// ^
							token = getNextToken();
							if (token != T_WEDGE) break;
							startIdx = endIdx+1;

							// basis vector
							token = getNextToken();
							if ((token >= T_FIRST_BASIS_VECTOR) && (token <= T_LAST_BASIS_VECTOR)) {
								int bvIdx = token - T_FIRST_BASIS_VECTOR;
								bb.wedgeBasisVector(bvIdx);
								startIdx = endIdx+1;
							}
							else {
								throw GetException("Expected basis vector");
							}


						}

					}
				} // end of 'if number or bv'
				else if (token == T_BAD_CHARACTER) {
					throw GetException("Bad character");
				}
				else if (token == T_BAD_NUMBER) {
					throw GetException("Bad number");
				}
				else if (token == T_BAD_IDENTIFIER) {
					throw GetException("Bad identifier");
				}
				else {
					throw GetException("Unexpected token");
				}

				// add
				sum(bb);
	    		
				// remember that the first loop is done
				firstLoop = false;
			}

			
			<%FT.GetMangledName(S, S.m_GMV.Name)%> result = new <%FT.GetMangledName(S, S.m_GMV.Name)%>(<%for (int i = 0; i <= S.m_dimension; i++) {%>GroupBitmap.GRADE_<%i%> | <%}%>0,  coord);
			result.<%G25.CG.CSJ.Util.GetFunctionName(S, "compress")%>(<%FT.DoubleToString(S, 0.0)%>);
			return result;
		} // end of Parse()


	} // end of class Parser

<%if (S.OutputCSharp()) {%>
}
<%}%>

<%}%>

${ENDCODEBLOCK}

// S = Specification of algebra.
// FT = floatType
${CODEBLOCK ANTLRgrammar_CSharp_Java}
<%{
	string BOOL_TYPE = (S.OutputJava()) ? "boolean" : "bool";
	string FINAL = (S.OutputJava()) ? "final " : "";
	string TEXT =  (S.OutputJava()) ? "getText()" : "Text";
	string PARSE_DOUBLE =  (S.OutputJava()) ? "parseDouble" : "Parse";
	string SET =  (S.OutputJava()) ? "set" : "Set";
%>
grammar <%S.m_namespace%>;

options
{
    language=<%if (S.OutputJava()) {%>Java<%} else {%>CSharp2<%}%>;
}


tokens
{
	PLUS 	= '+' ;
	MINUS	= '-' ;
	GP	= '*' ;
	OP	= '^' ;
}

<%if (S.OutputJava()) {%>

@lexer::header {
package <%S.m_namespace%>_pkg;
}
@parser::header {
package <%S.m_namespace%>_pkg;
}

<%} else {%>

@lexer::namespace {
    <%S.m_namespace%>_ns
}
@parser::namespace {
    <%S.m_namespace%>_ns
}

<%}%>


@members
{
	private <%FINAL%>void sum(<%FINAL%><%FT.type%>[] coord, <%FINAL%>BasisBlade bb) {
		int idx = <%S.m_namespace%>.BasisElementIndexByBitmap[bb.getBitmap()];
		coord[idx] += bb.getScale() / (<%FT.type%>)<%S.m_namespace%>.BasisElementSignByIndex[idx];
	}
	
	public class BasisBlade
	{
		private int bitmap = 0;
		private <%FT.type%> scale = <%FT.DoubleToString(S, 1.0)%>;

		public <%FINAL%>int getBitmap() { return bitmap;  }
		public <%FINAL%><%FT.type%> getScale() { return scale;  }

		public <%FINAL%>void wedgeBasisVector(int bvIdx)
		{
			int b;

			b = 1 << bvIdx;
			if ((bitmap & b) != 0)
			{ // bv ^ bv = 0
				scale = <%FT.DoubleToString(S, 0.0)%>;
				return;
			}
			else
			{
				// add basis vector to bitmap	
				bitmap |= b;

				bvIdx++;
				for (; bvIdx <= <%S.m_dimension%>; bvIdx++) // compute sign flips due to anti commuting basis vectors
					if ((bitmap & (1 << bvIdx)) != 0) scale = -scale;
			}
		}

		public <%FINAL%>void wedgeBasisVector(<%FINAL%>String bvName)
		{
			// see which basis vector it is
			for (int i = 0; i < <%S.m_dimension%>; i++)
				if (<%S.m_namespace%>.BasisVectorNames[i].<%G25.CG.CSJ.Util.GetFunctionName(S, "equals")%>(bvName)) 
				{
					wedgeBasisVector(i);
					return;
				}
		}
		
		public <%FINAL%>void multiply(<%FINAL%><%FT.type%> scalar)
		{
			scale *= scalar;
		}
	}

}


/*------------------------------------------------------------------
 * PARSER RULES
 *------------------------------------------------------------------*/

antlr_multivector returns [<%FT.GetMangledName(S, S.m_GMV.Name)%> result]
@init{
	<%FT.type%> scale = <%FT.DoubleToString(S, 1.0)%>;
	<%FT.type%>[] coord = new <%FT.type%>[<%1<<S.m_dimension%>];
}
@after{
	result = new <%FT.GetMangledName(S, S.m_GMV.Name)%>(<%for (int i = 0; i <= S.m_dimension; i++) {%>GroupBitmap.GRADE_<%i%> | <%}%>0, coord);
	result.<%G25.CG.CSJ.Util.GetFunctionName(S, "compress")%>(<%FT.DoubleToString(S, 0.0)%>);
}
:
(sg=antlr_sign {scale = sg;})* bb=antlr_basis_element {bb.multiply(scale); sum(coord, bb);}
(sg=antlr_sign {scale = sg;} (sg=antlr_sign {scale *= sg;})* bb=antlr_basis_element {bb.multiply(scale); sum(coord, bb);})*
;

antlr_basis_element returns [BasisBlade bb]
@init{
	bb = new BasisBlade();
}
:
	t1=NUMBER {bb.multiply((<%FT.type%>)Double.<%PARSE_DOUBLE%>(t1.<%TEXT%>));}  
((GP | OP)?
	(t2=BASIS_VECTOR {bb.wedgeBasisVector(t2.<%TEXT%>);} ) 
(OP t3=BASIS_VECTOR {bb.wedgeBasisVector(t3.<%TEXT%>);})*)? |
((t5=BASIS_VECTOR {bb.wedgeBasisVector(t5.<%TEXT%>);}) 
(OP t6=BASIS_VECTOR {bb.wedgeBasisVector(t6.<%TEXT%>);})*)
;

antlr_sign returns [<%FT.type%> sg]
@init{sg = <%FT.DoubleToString(S, 1.0)%>;}
:
	(PLUS | MINUS {sg = -sg;})
;

/*------------------------------------------------------------------
 * LEXER RULES
 *------------------------------------------------------------------*/

WHITESPACE  	: ( '\t' | ' ' | '\r' | '\n'| '\u000C' )+ {$channel = HIDDEN;};

BASIS_VECTOR	: ('<%S.m_basisVectorNames[0]%>'<%for (int i = 1; i < S.m_dimension; i++) {%> | '<%S.m_basisVectorNames[i]%>'<%}%>);

NUMBER		: (INT ('.' INT)? | '.' INT) (('e' | 'E') ('+' | '-')? INT)?;


fragment
INT : ('0'..'9')+ ;

<%}%>
${ENDCODEBLOCK}

// S = Specification of algebra (G25.Specification)
${CODEBLOCK runtimeGpTablesDefs}
	/*
	 * Tables for computing the geometric product at runtime. 
	 * The tables are initialized by initRuntimeGpTable() as needed,
	 * or all at once by calling initAllRuntimeGpTables().
	 */
<%foreach (G25.Metric M in S.m_metric)
{%><%for (int g1 = 0; g1 < S.m_GMV.NbGroups; g1++) {%><%for (int g2 = 0; g2 < S.m_GMV.NbGroups; g2++) {%><%for (int gd = 0; gd < S.m_GMV.NbGroups; gd++){%>
<%if (!S.m_GMV.IsZeroGP(g1, g2, gd)) {%>
	private static byte[] runtimeGpProductTable_<%M.m_name%>_<%g1.ToString()%>_<%g2.ToString()%>_<%gd.ToString()%> = null;
<%}%><%}%><%}%><%}%><%}%>
${ENDCODEBLOCK}

// S = Specification of algebra.
${CODEBLOCK bitmapGp}
<%new G25.CG.Shared.Comment("Returns the number of 1 bits in 'i'.").ToString(S, 1)%>
	private static int BitCount(int i)
	{
		i = i - ((i >> 1) & 0x55555555);
		i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
		i = (i + (i >> 4)) & 0x0F0F0F0F;
		i = i + (i >> 8);
		i = i + (i >> 16);
		return i & 0x0000003F;
	}

<%new G25.CG.Shared.Comment("Returns sign change due to putting the basis blades represented\n" + 
	"by 'a' and 'b' into canonical order.\n" + 
	"The canonical order of a basis blade is the order in which the basis\n" + 
	"vectors are listed in alphabetical order. E.g. 'e1^e2^e4' is in canonical order,\n" + 
	"while 'e1^e4^e2' is not.\n").
	SetReturnComment("either +1 or -1").
	ToString(S, 1)%>
	private static int CanonicalReorderingSign(int a, int b)
	{
		int sum = 0;

		// Count the number of basis vector flips required to
		// get a and b into canonical order.
		a >>= 1;
		while (a != 0)
		{
			sum += BitCount(a & b);
			a >>= 1;
		}

		// even number of flips -> return 1
		// odd number of flips -> return 1
		return ((sum & 1) == 0) ? 1 : -1;
	}


	/* 
	 * Computes the geometric product of basis blades (bitmaps) 'a' and 'b'.
	 * The returned 'resultBitmap' is the new bitmap, 'resultSign' is the sign.
	 * Input and output blades/bitmaps are assumed to be in canonical order.
	 *
	 * 'metricId' is the ID of the metric which is hard coded into the function:
<%for (int mIdx = 0; mIdx < S.m_metric.Count; mIdx++) {
		G25.Metric M = S.m_metric[mIdx];
%>
	 *  metricId = <%mIdx.ToString()%>: <%M.m_name%>
	<%}%> */
	private static void BitmapGp(int a, int b, int metricId, int[] result) // bitmap = result[0], sign = result[1]
	{
		int an = a & b;
	    
	<%for (int mIdx = 0; mIdx < S.m_metric.Count; mIdx++) {
		G25.Metric M = S.m_metric[mIdx];
	%>
<%if (M.m_metric.HasValueOnDiagonal(0.0)) {%>
		// check here for annihilated basis vectors with 0 metric
		if ((metricId == <%mIdx%>) && (<%for (int d = 0; d < S.m_dimension; d++) {%>
<%if (M.m_metric.DiagonalValue(d) == 0.0) {%>
	((an & <%(1<<d).ToString()%>) != 0) ||<%}%><%}%> false)) {
    		result[1] = 0;
    		result[0] = 0;
    		return;
		}
<%}%>
<%}%>
	    
		// compute the bitmap:
		result[0] = a ^ b;

		// compute the sign change due to reordering:
		result[1] = CanonicalReorderingSign(a, b);

	<%for (int mIdx = 0; mIdx < S.m_metric.Count; mIdx++) {
		G25.Metric M = S.m_metric[mIdx];
	%>
	<%if (M.m_metric.HasValueOnDiagonal(-1.0)) {%>
		// check here for annihilated basis vectors with -1 metric
		if (metricId == <%mIdx%>) {
	<%for (int d = 0; d < S.m_dimension; d++) {%>
	<%if (M.m_metric.DiagonalValue(d) == -1.0) {%>
			if (an & <%(1<<d).ToString()%>)<%}%><%}%> result[1] *= -1;
		}
	<%} /* close for if statement for -1 metric */ %>
	<%} /* close for loop over metrics */ %>
	
	}   
${ENDCODEBLOCK}

// S = Specification of algebra (G25.Specification)
${CODEBLOCK runtimeGpTable}
	private static int RT_GP_T_ALL_DONE = 127;
	private static int RT_GP_T_COORD_DONE = 126;
	private static int RT_GP_T_SKIP_MAX = 125;
	private static int RT_GP_T_SKIP_RESULT_MAX = 255;
	private static int RT_GP_SIGN_BIT = 0x80;
	
	// how much mem used by tables, so far	
	private static int runtimeGpTableMemUsed = 0;
	
<%new G25.CG.Shared.Comment("This function initializes a table which is used to compute the geometric product.\n" + 
	"by 'a' and 'b' into canonical order.\n" + 
	"The canonical order of a basis blade is the order in which the basis\n" + 
	"vectors are listed in alphabetical order. E.g. 'e1^e2^e4' is in canonical order,\n" + 
	"while 'e1^e4^e2' is not.\n").
	AddParamComment("metricId", "the ID of the metric.").
	AddParamComment("srcG1", "the grade/group of the first operand.").
	AddParamComment("srcG2", "the grade/group of the second operand").
	AddParamComment("metricId", "the grade/group of the destionation (other grades/groups are ignored).").
	ToString(S, 1)%>
	private static byte[] InitRuntimeGpTable(int metricId, int srcG1, int srcG2, int dstG) {
		int srcG1size, srcG2size, dstGsize, idx, Tlength, i1, i2, iDst, sign1, sign2, signDst, baseIdx1, baseIdx2, baseIdxDst, prevI2, skip;
		int[] tmp = new int[2];
		int bitmap1, bitmap2, bitmapDst;
		byte[] T = null;
		
		// get size of input and destination grades/groups
		srcG1size = GroupSize[srcG1];
		srcG2size = GroupSize[srcG2];
		dstGsize = MvSize[(1<<srcG1)-1];
		baseIdx1 = MvSize[(1<<srcG1)-1];
		baseIdx2 = MvSize[(1<<srcG2)-1];

		idx = 0; // index into T
		Tlength = srcG1size * srcG2size * 6; // is this a safe upper bound?
		T = new byte[Tlength];

		// Loop over all basis blades of group 1, and then over all basis blade of group 2.
		// Compute their geometric products. If the result is in the destination group, write a table entry
		for (i1 = 0; i1 < srcG1size; i1++) {
			// get bitmap representation and sign of src1 basis blade
			bitmap1 = BasisElementBitmapByIndex[baseIdx1 + i1];
			sign1 = (int)BasisElementSignByIndex[baseIdx1 + i1];
			
			prevI2 = 0;
			for (i2 = 0; i2 < srcG2size; i2++) {
				// get bitmap representation and sign of src2 basis blade
				bitmap2 = BasisElementBitmapByIndex[baseIdx2 + i2];
				sign2 = (int)BasisElementSignByIndex[baseIdx2 + i2];

				// compute bitmap representation and sign of (dst = src1 src2) basis blade
				BitmapGp(bitmap1, bitmap2, metricId, tmp);
				bitmapDst = tmp[0];
				signDst = tmp[1];
				
				if (signDst == 0) continue; // 0 is due to null metric
				
				// check if group of bitmapDst is the destination group.
				if (dstG != BasisElementGroupByBitmap[bitmapDst]) continue; 
				
				// get index of bitmapDst inside its group
				baseIdxDst = MvSize[(1<<dstG)-1];
				iDst = BasisElementIndexByBitmap[bitmapDst] - baseIdxDst;
				
				signDst *= sign1 * sign2 * (int)BasisElementSignByBitmap[bitmapDst];
				
				// write table:
				// how many positions to skip of to get to the next i2 which will lead to a result
				skip = i2 - prevI2;
				do {
					if (skip >= RT_GP_T_SKIP_MAX) {
						T[idx++] = (byte)RT_GP_T_SKIP_MAX;
						skip -= RT_GP_T_SKIP_MAX;
					}
					if (skip < RT_GP_T_SKIP_MAX) {
						T[idx++] = (byte)skip;
						skip = 0;
					}
				} while (skip > 0);
				prevI2 = i2;
				
				// write the sign of the result
				T[idx-1] |= (byte)((signDst < 0) ? RT_GP_SIGN_BIT : 0);

				// where to write the result
				do {
					if (iDst >= RT_GP_T_SKIP_RESULT_MAX) {
						T[idx++] = (byte)RT_GP_T_SKIP_RESULT_MAX;
						iDst -= RT_GP_T_SKIP_RESULT_MAX;
					}
					if (iDst < RT_GP_T_SKIP_RESULT_MAX) {
						T[idx++] = (byte)iDst;
						iDst = 0;
					}				
				} while (iDst > 0);
				
			} // end of loop over all basis blade of group 2
			T[idx++] = (byte)RT_GP_T_COORD_DONE;
		} // end of loop over all basis blade of group 2
		T[idx-1] = (byte)RT_GP_T_ALL_DONE; // this overwrites the last RT_GP_T_COORD_DONE

		if (idx <= 4 * Tlength / 5) { // reallocate of more than 80% of memory is wasted
			Array.Resize(ref T, idx);
		}
		else if (idx >= Tlength) {
			throw new Exception("Buffer overflow in initRuntimeGpTable() (" + idx + " >= " + Tlength + ")\n");
		}
		
		runtimeGpTableMemUsed += idx;
		
		return T;
	} // end of InitRuntimeGpTable()
${ENDCODEBLOCK}

${CODEBLOCK runtimeGpInitTables}
	public static void InitAllRuntimeGpTables() {
<%for (int m = 0; m < S.m_metric.Count; m++) { G25.Metric M = S.m_metric[m];%>
<%for (int g1 = 0; g1 < S.m_GMV.NbGroups; g1++) {%><%for (int g2 = 0; g2 < S.m_GMV.NbGroups; g2++) {%><%for (int gd = 0; gd < S.m_GMV.NbGroups; gd++) {%>
<%if (!S.m_GMV.IsZeroGP(g1, g2, gd)) {%>
		runtimeGpProductTable_<%M.m_name%>_<%g1.ToString()%>_<%g2.ToString()%>_<%gd.ToString()%> = InitRuntimeGpTable(<%m%>, <%g1%>, <%g2%>, <%gd%>);
<%}%><%}%><%}%><%}%><%}%>
	} // end of InitAllRuntimeGpTables()
${ENDCODEBLOCK}

${CODEBLOCK runtimeGpFreeTables}
	public static void FreeAllRuntimeGpTables() {
<%for (int m = 0; m < S.m_metric.Count; m++) { G25.Metric M = S.m_metric[m];%>
<%for (int g1 = 0; g1 < S.m_GMV.NbGroups; g1++) {%><%for (int g2 = 0; g2 < S.m_GMV.NbGroups; g2++) {%><%for (int gd = 0; gd < S.m_GMV.NbGroups; gd++) {%>
<%if (!S.m_GMV.IsZeroGP(g1, g2, gd)) {%>
		runtimeGpProductTable_<%M.m_name%>_<%g1.ToString()%>_<%g2.ToString()%>_<%gd.ToString()%> = null;
<%}%><%}%><%}%><%}%><%}%>
	} // end of FreeAllRuntimeGpTables()
${ENDCODEBLOCK}

// S = Specification of algebra (G25.Specification)
// FT = floating point type (G25.FloatType)
${CODEBLOCK runtimeComputeGp}
<%new G25.CG.Shared.Comment("Computes the geometric product at runtime using a table.\n").
	ToString(S, 1)%>
	private static void RuntimeComputeGp_<%FT.type%>(<%FT.type%>[] src1, <%FT.type%>[] src2, <%FT.type%>[] dst, 
		byte[] table, int metricId, int g1, int g2, int gdst) 
	{
		int idx = 0; // index into *table
		int skip, moreSkip, dstIdx, moreDstIdx;
		//<%FT.type%>[] currentSrc2 = src2; // currentSrc2 will be incremented/reset in the loop below
		int src1Idx = 0, src2Idx = 0;
		<%FT.type%> sign;
		
		while (table[idx] != (byte)RT_GP_T_ALL_DONE) { 
			// get next index into src2;
			if (table[idx] == (byte)RT_GP_T_COORD_DONE) { 
				// move on to the next coordinate of g1
				src1Idx++;
				src2Idx = 0;
				idx++;
				continue;
			}
			else {
				// skip the right amount of coordinate in group 2
				skip = ((int)table[idx++] & (0xFF^RT_GP_SIGN_BIT));
				if (skip == RT_GP_T_SKIP_MAX) {
					do {
						moreSkip = (int)table[idx++] & (0xFF^RT_GP_SIGN_BIT);
						skip += moreSkip;
					} while (moreSkip == RT_GP_T_SKIP_MAX);
				}
				src2Idx += skip;
				
				// get the sign of the result (is on the last bit of the previous byte in the table
				sign = ((table[idx-1] & RT_GP_SIGN_BIT) != 0) ? <%FT.DoubleToString(S, -1.0)%> : <%FT.DoubleToString(S, 1.0)%>;
				
				// get the index in the destination vector
				dstIdx = (int)table[idx++] & 0xFF; // plus any extra if required
				if (dstIdx == RT_GP_T_SKIP_RESULT_MAX) {
					do {
						moreDstIdx = (int)table[idx++] & 0xFF;
						dstIdx += moreDstIdx;
					} while (moreDstIdx == RT_GP_T_SKIP_RESULT_MAX);
				}
				dst[dstIdx] += sign * src1[src1Idx] * src2[src2Idx];
			}
		}
	} // end of RuntimeComputeGp_<%FT.type%>()
${ENDCODEBLOCK}

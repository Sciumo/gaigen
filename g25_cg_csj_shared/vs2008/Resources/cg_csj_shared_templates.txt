// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// gmvName = name of GMV class
// fabsFunc = name of floating point absolute function
${CODEBLOCK GMVlargestCoordinate}
<%if (S.m_outputLanguage == G25.OUTPUT_LANGUAGE.CSHARP) {%>
	/// <summary>returns the absolute largest coordinate.</summary>
<%} else {%>
	/** returns the absolute largest coordinate.*/
<%}%>
	public <%FT.type%> <%G25.CG.CSJ.Util.GetFunctionName(S, "largestCoordinate")%>() {
		<%FT.type%> maxValue = <%FT.DoubleToString(S, 0.0)%>, C;
		for (int g = 0; g < m_c.<%G25.CG.CSJ.Util.GetFunctionName(S, "length")%>; g++) {
			if (m_c[g] != null) {
				<%FT.type%>[] Cg = m_c[g];
				for (int b = 0; b < Cg.<%G25.CG.CSJ.Util.GetFunctionName(S, "length")%>; b++) {
					C = <%fabsFunc%>(Cg[b]);
					if (C > maxValue) {
						maxValue = C;
					}
				}
			}
		}
		return maxValue;
	}
	
<%if (S.m_outputLanguage == G25.OUTPUT_LANGUAGE.CSHARP) {%>
	/// <summary>returns the absolute largest coordinate and the corresponding basis blade bitmap (in 'bm') .</summary>
	public <%FT.type%> <%G25.CG.CSJ.Util.GetFunctionName(S, "largestBasisBlade")%>(ref int bm) {
<%} else {%>
	/** returns the absolute largest coordinate (entry [0]), and the corresponding basis blade bitmap (entry [1])  */
	public <%FT.type%>[] <%G25.CG.CSJ.Util.GetFunctionName(S, "largestBasisBlade")%>() {
<%}%>
		<%FT.type%> maxC = <%FT.DoubleToString(S, -1.0)%>, C;

		int idx = 0; // global index into coordinates (run from 0 to <%S.m_GMV.NbCoordinates%>).
<%if (S.m_outputLanguage == G25.OUTPUT_LANGUAGE.JAVA) {%>
		int bm; // bitmap of basis blade
<%}%>
		bm = 0;
		
		for (int g = 0; g < m_c.<%G25.CG.CSJ.Util.GetFunctionName(S, "length")%>; g++) {
			if (m_c[g] != null) {
				<%FT.type%>[] Cg = m_c[g];
				for (int b = 0; b < m_c[g].<%G25.CG.CSJ.Util.GetFunctionName(S, "length")%>; b++) {
					C = <%fabsFunc%>(Cg[b]);
					if (C > maxC) {
						maxC = C;
						bm = <%S.m_namespace%>.BasisElementBitmapByIndex[idx];
					}
					idx++;
				}
			
			}
			else idx += <%S.m_namespace%>.GroupSize[g];
		}

<%if (S.m_outputLanguage == G25.OUTPUT_LANGUAGE.CSHARP) {%>
		return maxC;
<%} else {%>
		return new <%FT.type%>[]{maxC, (<%FT.type%>)bm};
<%}%>
	} // end of <%G25.CG.CSJ.Util.GetFunctionName(S, "largestBasisBlade")%>()
	
${ENDCODEBLOCK}


// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
// userComment
${CODEBLOCK seriesExp}
<%new G25.CG.Shared.Comment("Computes exponential of " + inputType + " up to 12th term.\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x) {
	return <%funcName%>(x, 12);
}

<%new G25.CG.Shared.Comment("Computes exponential of " + inputType + ".\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x, <%if (S.OutputJava()) {%>final <%}%>int order) {
   
	{ // First try special cases: check if (x * x) is scalar
		<%returnType%> xSquared = <%gpFuncII%>(x, x);
		<%FT.type%> s_xSquared = xSquared.get_scalar();
		if ((<%normE2funcR%>(xSquared) - s_xSquared * s_xSquared) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
			// OK (x * x == ~scalar), so use special cases:
			if (s_xSquared < <%FT.DoubleToString(S, 0.0)%>) {
				<%FT.type%> a = <%sqrtFunc%>(-s_xSquared);
				return <%SASfuncI%>(x, <%sinFunc%>(a) / a, <%cosFunc%>(a));
			}
			else if (s_xSquared > <%FT.DoubleToString(S, 0.0)%>) {
				<%FT.type%> a = <%sqrtFunc%>(s_xSquared);
				return <%SASfuncI%>(x, <%sinhFunc%>(a) / a, <%coshFunc%>(a));
			}
			else {
				return <%SASfuncI%>(x, <%FT.DoubleToString(S, 1.0)%>, <%FT.DoubleToString(S, 1.0)%>);
			}
		}
	}

	// else do general series eval . . .

	// result = 1 + ....	
	<%returnType%> result = new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>);
	if (order == 0) return result;

	// find scale (power of 2) such that its norm is < 1
	<%if (S.OutputCSharp()) {%>u<%}%>long maxC = (<%if (S.OutputCSharp()) {%>u<%}%>long)x.<%G25.CG.CSJ.Util.GetFunctionName(S, "largestCoordinate")%>();
	int scale = 1;
	if (maxC > 1) scale <<= 1;
	while (maxC != 0)
	{
		maxC >>= 1;
		scale <<= 1;
	}

	// scale
	<%inputType%> xScaled = <%gpFuncIdouble%>(x, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)scale); 

	// taylor series approximation
	<%returnType%> xPow1 = new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>); 
	for (int i = 1; i <= order; i++) {
		<%returnType%> xPow2 = <%gpFuncRI%>(xPow1, xScaled);
		xPow1 = <%gpFuncRdouble%>(xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i);
		
		result = <%addFuncRR%>(result, xPow1); // result2 = result1 + xPow1
    }

	// undo scaling
	while (scale > 1)
	{
		result = <%gpFuncRR%>(result, result);
		scale >>= 1;
	}
    
    return result;
} // end of <%funcName%>()

${ENDCODEBLOCK}


// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesSinh}
<%new G25.CG.Shared.Comment("Computes hyperbolic sine of " + inputType + " up to 12th term.\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x) {
	return <%funcName%>(x, 12);
}

<%new G25.CG.Shared.Comment("Computes hyperbolic sine of " + inputType + ".\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x, <%if (S.OutputJava()) {%>final <%}%>int order) {
   
	{ // First try special cases: check if (x * x) is scalar
		<%returnType%> xSquared = <%gpFuncII%>(x, x);
		<%FT.type%> s_xSquared = xSquared.get_scalar();
		if ((<%normE2funcR%>(xSquared) - s_xSquared * s_xSquared) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
			// OK (x * x == ~scalar), so use special cases:
			if (s_xSquared < <%FT.DoubleToString(S, 0.0)%>) {
				<%FT.type%> a = <%sqrtFunc%>(-s_xSquared);
				return <%SASfuncI%>(x, <%sinFunc%>(a) / a, <%FT.DoubleToString(S, 0.0)%>);
			}
			else if (s_xSquared > <%FT.DoubleToString(S, 0.0)%>) {
				<%FT.type%> a = <%sqrtFunc%>(s_xSquared);
				return <%SASfuncI%>(x, <%sinhFunc%>(a) / a, <%FT.DoubleToString(S, 0.0)%>);
			}
			else {
<%if ((returnType != inputType) && (returnType != FT.GetMangledName(S, S.m_GMV.Name))) {%>
				return <%copyInputToReturnFunc%>(x);
<%} else {%>
				return x;
<%}%>
			}
		}
	}

	// else do general series eval . . .

	// result = A +  A^3/3! + A^5/5!
	<%returnType%> result = new <%returnType%>(); // result = 0
    if (order == 0) return result;
    	
	// taylor series approximation
	<%returnType%> xPow1 = new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>);
	for (int i = 1; i <= order; i++) {
		<%returnType%> xPow2 = <%gpFuncRI%>(xPow1, x); // xPow2 = xPow1 * x
		xPow1 = <%gpFuncRdouble%>(xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i); // xPow1 = xScaled^i / i! 
		
		if ((i % 2) == 1) {
			result = <%addFuncRR%>(result, xPow1); 
		}
	}

    return result;
} // end of <%funcName%>()
${ENDCODEBLOCK}

// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesCosh}
<%new G25.CG.Shared.Comment("Computes hyperbolic cosine of " + inputType + " up to 12th term.\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x) {
	return <%funcName%>(x, 12);
}

<%new G25.CG.Shared.Comment("Computes hyperbolic cosine of " + inputType + ".\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x, <%if (S.OutputJava()) {%>final <%}%>int order) {
   
	{ // First try special cases: check if (x * x) is scalar
		<%returnType%> xSquared = <%gpFuncII%>(x, x);
		<%FT.type%> s_xSquared = xSquared.get_scalar();
		if ((<%normE2funcR%>(xSquared) - s_xSquared * s_xSquared) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
			// OK (x * x == ~scalar), so use special cases:
			if (s_xSquared > <%FT.DoubleToString(S, 0.0)%>) {
				return new <%returnType%>(<%coshFunc%>(<%sqrtFunc%>(s_xSquared)));
			}
			else if (s_xSquared < <%FT.DoubleToString(S, 0.0)%>) {
				return new <%returnType%>(<%cosFunc%>(<%sqrtFunc%>(-s_xSquared)));
			}
			else {
				return new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>);
			}
		}
	}

	// else do general series eval . . .


	<%returnType%> result = new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>);
	if (order == 0) return result;

	// taylor series approximation
	<%returnType%> xPow1 = new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>);
	for (int i = 1; i <= order; i++) {
		<%returnType%> xPow2 = <%gpFuncRI%>(xPow1, x);
		xPow1 = <%gpFuncRdouble%>(xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i); // xPow1 = xScaled^i / i! 
		
		if ((i % 2) == 0) {
			result = <%addFuncRR%>(result, xPow1); 
		}
    }

    return result;
} // end of <%funcName%>()
${ENDCODEBLOCK}


// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesSin}
<%new G25.CG.Shared.Comment("Computes sine of " + inputType + " up to 12th term.\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x) {
	return <%funcName%>(x, 12);
}

<%new G25.CG.Shared.Comment("Computes sine of " + inputType + ".\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x, <%if (S.OutputJava()) {%>final <%}%>int order) {
   
	{ // First try special cases: check if (x * x) is scalar
		<%returnType%> xSquared = <%gpFuncII%>(x, x);
		<%FT.type%> s_xSquared = xSquared.get_scalar();
		if ((<%normE2funcR%>(xSquared) - s_xSquared * s_xSquared) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
			// OK (x * x == ~scalar), so use special cases:
			if (s_xSquared < <%FT.DoubleToString(S, 0.0)%>) {
				<%FT.type%> a = <%sqrtFunc%>(-s_xSquared);
				return <%SASfuncI%>(x, <%sinhFunc%>(a) / a, <%FT.DoubleToString(S, 0.0)%>);
			}
			else if (s_xSquared > <%FT.DoubleToString(S, 0.0)%>) {
				<%FT.type%> a = <%sqrtFunc%>(s_xSquared);
				return <%SASfuncI%>(x, <%sinFunc%>(a) / a, <%FT.DoubleToString(S, 0.0)%>);
			}
			else {
<%if ((returnType != inputType) && (returnType != FT.GetMangledName(S, S.m_GMV.Name))) {%>
				return <%copyInputToReturnFunc%>(x);
<%} else {%>
				return x;
<%}%>
			}
		}
	}

	// else do general series eval . . .

	// result = A -  ....	+ ... - ...
	<%returnType%> result = new <%returnType%>(); // result = 0;
    if (order == 0) return result;
    	
	// taylor series approximation
	<%returnType%> xPow1 = new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>); // xPow1 = 1.0
	for (int i = 1; i <= order; i++) {
		<%returnType%> xPow2 = <%gpFuncRI%>(xPow1, x); // xPow2 = xPow1 * x
		
		xPow1 = <%gpFuncRdouble%>(xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i); // xPow1 = xScaled^i / i! 
		
		if ((i % 4) == 3)
		{
			result = <%subFuncRR%>(result, xPow1); // result = result - xPow1
		}
		else if ((i % 4) == 1) 
		{
			result = <%addFuncRR%>(result, xPow1); // result = result + xPow1
		}
	}

	return result;
} // end of <%funcName%>()

${ENDCODEBLOCK}

// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesCos}
<%new G25.CG.Shared.Comment("Computes cosine of " + inputType + " up to 12th term.\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x) {
	return <%funcName%>(x, 12);
}

<%new G25.CG.Shared.Comment("Computes cosine of " + inputType + ".\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x, <%if (S.OutputJava()) {%>final <%}%>int order) {
	{ // First try special cases: check if (x * x) is scalar
		<%returnType%> xSquared = <%gpFuncII%>(x, x);
		<%FT.type%> s_xSquared = xSquared.get_scalar();
		if ((<%normE2funcR%>(xSquared) - s_xSquared * s_xSquared) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
			// OK (x * x == ~scalar), so use special cases:
			if (s_xSquared > <%FT.DoubleToString(S, 0.0)%>) {
				return new <%returnType%>(<%cosFunc%>(<%sqrtFunc%>(s_xSquared)));
			}
			else if (s_xSquared < <%FT.DoubleToString(S, 0.0)%>) {
				return new <%returnType%>(<%coshFunc%>(<%sqrtFunc%>(-s_xSquared)));
			}
			else {
				return new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>);
			}
		}
	}

	// else do general series eval . . .


	<%returnType%> result = new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>);
	if (order == 0) return result;

	// taylor series approximation
	<%returnType%> xPow1 = new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>); // xPow1 = 1.0
	for (int i = 1; i <= order; i++) {
		<%returnType%> xPow2 = <%gpFuncRI%>(xPow1, x); // xPow2 = xPow1 * x
		xPow1 = <%gpFuncRdouble%>(xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i); // xPow1 = xScaled^i / i! 
		
		if ((i % 4) == 2)
		{
			result = <%subFuncRR%>(result, xPow1); // result2 = result1 - xPow1
		}
		else if ((i % 4) == 0) 
		{
			result = <%addFuncRR%>(result, xPow1); // result2 = result1 + xPow1
		}		
    }

	return result;
} // end of <%funcName%>()
${ENDCODEBLOCK}

// S = Specification of algebra.
// functionName = name of generated function
// FT = floating point type
// mvType = multivector type name (with prefix/suffix)
// randomScalarFuncName = name of function which generates random scalar values
// gpopFuncName = name of geometric product or outer product function for two multivectors
// normFuncName = norm of multivector function (must return scalar)
// gpScalarFuncName = geometric product of multivector and scalar
// generatorVersor = bool (use geometric product or outer product)
${CODEBLOCK randomBladeVersor}

<%new G25.CG.Shared.Comment("Generates a random " + ((generatorVersor) ? "versor" : "blade") + ".\n"+
	"The scale is uniformly distributed over the interval [0 1).\n" + 
	"The maximum non-zero grade-part is 'grade'.\n" + 
	"\n" + 
	"Only the basis vectors marked in 'basisVectorBitmap' will be used to generate the versor/blade.\n" + 
	"Use 'basisVectorBitmap = -1' (the default) to use all basisvectors.").
	SetReturnComment(functionName + "_ex(arg1, scale, grade, basisVectorBitmap, 0.01, scale * 4.0)").
	ToString(S, 0)%>
public static <%mvType%> <%functionName%>(<%FT.type%> scale, int grade, int basisVectorBitmap) {
	<%FT.type%> minimumNorm = <%FT.DoubleToString(S, 0.01)%>;
	<%FT.type%> largestCoordinate = <%FT.DoubleToString(S, 4.0)%>;
	return <%functionName%>_ex(scale, grade, basisVectorBitmap, minimumNorm, scale * largestCoordinate);
}

<%new G25.CG.Shared.Comment("This version of " + functionName + "() has extra arguments which help to avoid\n" + 
	"near-singular blades / versors.\n" + 
	"\n" + 
	"Near-singular blades / versors are avoid by testing the norm and largest coordinate\n" + 
	"of the random blade / versor. If the test does not pass, the function recursively\n" + 
	"tries to generate another random blade / versor.\n" + 
	"\n" + 
	"'minimumNorm' is the minimum allowed norm of the blade/versor before scaling. \n" + 
	"'minimumNorm' must be > 0.0 for versors.\n" + 
	"\n" + 
	"'largestCoordinate' is the largest coordinate allowed after scaling.\n").
	SetReturnComment(functionName + "_ex(arg1, scale, grade, basisVectorBitmap, 0.01, scale * 4.0)").
	ToString(S, 0)%>
public static <%mvType%> <%functionName%>_ex(<%FT.type%> scale, int _grade, int basisVectorBitmap, 
		<%FT.type%> minimumNorm, <%FT.type%> largestCoordinate) 
{
	<%mvType%> randomVector = new <%mvType%>();
	//, tmp1, tmp2;
	<%FT.type%>[] randomValues = new <%FT.type%>[<%S.m_dimension%>];
	//<%FT.type%> n2, mul;
	int grade = _grade;
	
	// set IR (intermediate result) to 1
	<%mvType%> IR = new <%mvType%> (<%FT.DoubleToString(S, 1.0)%>);

	while (grade > 0) {	// loop until grade == 0
		// fill array with random values
		for (int i = 0; i < <%S.m_dimension%>; i++) 
			randomValues[i] = ((basisVectorBitmap & (1 << i)) == 0)
				? (<%FT.DoubleToString(S, -1.0)%> + <%FT.DoubleToString(S, 2.0)%> * <%randomScalarFuncName%>())
				: <%FT.DoubleToString(S, 0.0)%>;
		
		// make it a multivector:
		randomVector.<%G25.CG.CSJ.Util.GetFunctionName(S, "set")%>(GroupBitmap.GRADE_1, randomValues);
		
		// multiply 
		IR = <%gpopFuncName%>(IR, randomVector);
		
		// lower grade
		grade--;
	}
	
	// compute norm/multiplier, apply it, or recurse if we happened to create a near-null versor
	<%FT.type%> n2 = <%normFuncName%>(IR);
	if ((<%FT.type%>)<%G25.CG.Shared.CodeUtil.OpNameToLangString(S, FT, RefGA.Symbolic.ScalarOp.ABS)%>(n2) > minimumNorm * minimumNorm) {
		if (n2 != <%FT.DoubleToString(S, 0.0)%>) {
			<%FT.type%> mul = scale * <%randomScalarFuncName%>() / n2;
			if (IR.<%G25.CG.CSJ.Util.GetFunctionName(S, "largestCoordinate")%>() * mul < largestCoordinate)
				return <%gpScalarFuncName%>(IR, mul);
		}
		else if (IR.<%G25.CG.CSJ.Util.GetFunctionName(S, "largestCoordinate")%>() < largestCoordinate)
			return IR;
	}
	
	// try again:
	return <%functionName%>_ex(scale, _grade, basisVectorBitmap, minimumNorm, largestCoordinate); 
}
${ENDCODEBLOCK}

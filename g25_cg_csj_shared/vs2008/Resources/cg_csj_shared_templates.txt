// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// gmvName = name of GMV class
// fabsFunc = name of floating point absolute function
${CODEBLOCK GMVlargestCoordinate}
<%if (S.m_outputLanguage == G25.OUTPUT_LANGUAGE.CSHARP) {%>
	/// <summary>returns the absolute largest coordinate.</summary>
<%} else {%>
	/** returns the absolute largest coordinate.*/
<%}%>
	public <%FT.type%> <%G25.CG.CSJ.Util.GetFunctionName(S, "largestCoordinate")%>() {
		<%FT.type%> maxValue = <%FT.DoubleToString(S, 0.0)%>, C;
		for (int g = 0; g < m_c.<%G25.CG.CSJ.Util.GetFunctionName(S, "length")%>; g++) {
			if (m_c[g] != null) {
				<%FT.type%>[] Cg = m_c[g];
				for (int b = 0; b < Cg.<%G25.CG.CSJ.Util.GetFunctionName(S, "length")%>; b++) {
					C = <%fabsFunc%>(Cg[b]);
					if (C > maxValue) {
						maxValue = C;
					}
				}
			}
		}
		return maxValue;
	}
	
<%if (S.m_outputLanguage == G25.OUTPUT_LANGUAGE.CSHARP) {%>
	/// <summary>returns the absolute largest coordinate and the corresponding basis blade bitmap (in 'bm') .</summary>
	public <%FT.type%> <%G25.CG.CSJ.Util.GetFunctionName(S, "largestBasisBlade")%>(ref int bm) {
<%} else {%>
	/** returns the absolute largest coordinate (entry [0]), and the corresponding basis blade bitmap (entry [1])  */
	public <%FT.type%>[] <%G25.CG.CSJ.Util.GetFunctionName(S, "largestBasisBlade")%>() {
<%}%>
		<%FT.type%> maxC = <%FT.DoubleToString(S, -1.0)%>, C;

		int idx = 0; // global index into coordinates (run from 0 to <%S.m_GMV.NbCoordinates%>).
<%if (S.m_outputLanguage == G25.OUTPUT_LANGUAGE.JAVA) {%>
		int bm; // bitmap of basis blade
<%}%>
		bm = 0;
		
		for (int g = 0; g < m_c.<%G25.CG.CSJ.Util.GetFunctionName(S, "length")%>; g++) {
			if (m_c[g] != null) {
				<%FT.type%>[] Cg = m_c[g];
				for (int b = 0; b < m_c[g].<%G25.CG.CSJ.Util.GetFunctionName(S, "length")%>; b++) {
					C = <%fabsFunc%>(Cg[b]);
					if (C > maxC) {
						maxC = C;
						bm = <%S.m_namespace%>.BasisElementBitmapByIndex[idx];
					}
					idx++;
				}
			
			}
			else idx += <%S.m_namespace%>.GroupSize[g];
		}

<%if (S.m_outputLanguage == G25.OUTPUT_LANGUAGE.CSHARP) {%>
		return maxC;
<%} else {%>
		return new <%FT.type%>[]{maxC, (<%FT.type%>)bm};
<%}%>
	} // end of <%G25.CG.CSJ.Util.GetFunctionName(S, "largestBasisBlade")%>()
	
${ENDCODEBLOCK}


// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
// userComment
${CODEBLOCK seriesExp}
<%new G25.CG.Shared.Comment("Computes exponential of " + inputType + " up to 12th term.\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x) {
	return <%funcName%>(x, 12);
}

<%new G25.CG.Shared.Comment("Computes exponential of " + inputType + ".\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x, <%if (S.OutputJava()) {%>final <%}%>int order) {
   
	{ // First try special cases: check if (x * x) is scalar
		<%returnType%> xSquared = <%gpFuncII%>(x, x);
		<%FT.type%> s_xSquared = xSquared.get_scalar();
		if ((<%normE2funcR%>(xSquared) - s_xSquared * s_xSquared) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
			// OK (x * x == ~scalar), so use special cases:
			if (s_xSquared < <%FT.DoubleToString(S, 0.0)%>) {
				<%FT.type%> a = <%sqrtFunc%>(-s_xSquared);
				return <%SASfuncI%>(x, <%sinFunc%>(a) / a, <%cosFunc%>(a));
			}
			else if (s_xSquared > <%FT.DoubleToString(S, 0.0)%>) {
				<%FT.type%> a = <%sqrtFunc%>(s_xSquared);
				return <%SASfuncI%>(x, <%sinhFunc%>(a) / a, <%coshFunc%>(a));
			}
			else {
				return <%SASfuncI%>(x, <%FT.DoubleToString(S, 1.0)%>, <%FT.DoubleToString(S, 1.0)%>);
			}
		}
	}

	// else do general series eval . . .

	// result = 1 + ....	
	<%returnType%> result = new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>);
	if (order == 0) return result;

	// find scale (power of 2) such that its norm is < 1
	<%if (S.OutputCSharp()) {%>u<%}%>long maxC = (<%if (S.OutputCSharp()) {%>u<%}%>long)x.<%G25.CG.CSJ.Util.GetFunctionName(S, "largestCoordinate")%>();
	int scale = 1;
	if (maxC > 1) scale <<= 1;
	while (maxC != 0)
	{
		maxC >>= 1;
		scale <<= 1;
	}

	// scale
	<%inputType%> xScaled = <%gpFuncIdouble%>(x, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)scale); 

	// taylor series approximation
	<%returnType%> xPow1 = new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>); 
	for (int i = 1; i <= order; i++) {
		<%returnType%> xPow2 = <%gpFuncRI%>(xPow1, xScaled);
		xPow1 = <%gpFuncRdouble%>(xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i);
		
		result = <%addFuncRR%>(result, xPow1); // result2 = result1 + xPow1
    }

	// undo scaling
	while (scale > 1)
	{
		result = <%gpFuncRR%>(result, result);
		scale >>= 1;
	}
    
    return result;
} // end of <%funcName%>()

${ENDCODEBLOCK}


// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesSinh}
<%new G25.CG.Shared.Comment("Computes hyperbolic sine of " + inputType + " up to 12th term.\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x) {
	return <%funcName%>(x, 12);
}

<%new G25.CG.Shared.Comment("Computes hyperbolic sine of " + inputType + ".\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x, <%if (S.OutputJava()) {%>final <%}%>int order) {
   
	{ // First try special cases: check if (x * x) is scalar
		<%returnType%> xSquared = <%gpFuncII%>(x, x);
		<%FT.type%> s_xSquared = xSquared.get_scalar();
		if ((<%normE2funcR%>(xSquared) - s_xSquared * s_xSquared) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
			// OK (x * x == ~scalar), so use special cases:
			if (s_xSquared < <%FT.DoubleToString(S, 0.0)%>) {
				<%FT.type%> a = <%sqrtFunc%>(-s_xSquared);
				return <%SASfuncI%>(x, <%sinFunc%>(a) / a, <%FT.DoubleToString(S, 0.0)%>);
			}
			else if (s_xSquared > <%FT.DoubleToString(S, 0.0)%>) {
				<%FT.type%> a = <%sqrtFunc%>(s_xSquared);
				return <%SASfuncI%>(x, <%sinhFunc%>(a) / a, <%FT.DoubleToString(S, 0.0)%>);
			}
			else {
<%if ((returnType != inputType) && (returnType != FT.GetMangledName(S, S.m_GMV.Name))) {%>
				return <%copyInputToReturnFunc%>(x);
<%} else {%>
				return x;
<%}%>
			}
		}
	}

	// else do general series eval . . .

	// result = A +  A^3/3! + A^5/5!
	<%returnType%> result = new <%returnType%>(); // result = 0
    if (order == 0) return result;
    	
	// taylor series approximation
	<%returnType%> xPow1 = new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>);
	for (int i = 1; i <= order; i++) {
		<%returnType%> xPow2 = <%gpFuncRI%>(xPow1, x); // xPow2 = xPow1 * x
		xPow1 = <%gpFuncRdouble%>(xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i); // xPow1 = xScaled^i / i! 
		
		if ((i % 2) == 1) {
			result = <%addFuncRR%>(result, xPow1); 
		}
	}

    return result;
} // end of <%funcName%>()
${ENDCODEBLOCK}

// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesCosh}
<%new G25.CG.Shared.Comment("Computes hyperbolic cosine of " + inputType + " up to 12th term.\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x) {
	return <%funcName%>(x, 12);
}

<%new G25.CG.Shared.Comment("Computes hyperbolic cosine of " + inputType + ".\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x, <%if (S.OutputJava()) {%>final <%}%>int order) {
   
	{ // First try special cases: check if (x * x) is scalar
		<%returnType%> xSquared = <%gpFuncII%>(x, x);
		<%FT.type%> s_xSquared = xSquared.get_scalar();
		if ((<%normE2funcR%>(xSquared) - s_xSquared * s_xSquared) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
			// OK (x * x == ~scalar), so use special cases:
			if (s_xSquared > <%FT.DoubleToString(S, 0.0)%>) {
				return new <%returnType%>(<%coshFunc%>(<%sqrtFunc%>(s_xSquared)));
			}
			else if (s_xSquared < <%FT.DoubleToString(S, 0.0)%>) {
				return new <%returnType%>(<%cosFunc%>(<%sqrtFunc%>(-s_xSquared)));
			}
			else {
				return new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>);
			}
		}
	}

	// else do general series eval . . .


	<%returnType%> result = new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>);
	if (order == 0) return result;

	// taylor series approximation
	<%returnType%> xPow1 = new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>);
	for (int i = 1; i <= order; i++) {
		<%returnType%> xPow2 = <%gpFuncRI%>(xPow1, x);
		xPow1 = <%gpFuncRdouble%>(xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i); // xPow1 = xScaled^i / i! 
		
		if ((i % 2) == 0) {
			result = <%addFuncRR%>(result, xPow1); 
		}
    }

    return result;
} // end of <%funcName%>()
${ENDCODEBLOCK}


// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesSin}
<%new G25.CG.Shared.Comment("Computes sine of " + inputType + " up to 12th term.\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x) {
	return <%funcName%>(x, 12);
}

<%new G25.CG.Shared.Comment("Computes sine of " + inputType + ".\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x, <%if (S.OutputJava()) {%>final <%}%>int order) {
   
	{ // First try special cases: check if (x * x) is scalar
		<%returnType%> xSquared = <%gpFuncII%>(x, x);
		<%FT.type%> s_xSquared = xSquared.get_scalar();
		if ((<%normE2funcR%>(xSquared) - s_xSquared * s_xSquared) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
			// OK (x * x == ~scalar), so use special cases:
			if (s_xSquared < <%FT.DoubleToString(S, 0.0)%>) {
				<%FT.type%> a = <%sqrtFunc%>(-s_xSquared);
				return <%SASfuncI%>(x, <%sinhFunc%>(a) / a, <%FT.DoubleToString(S, 0.0)%>);
			}
			else if (s_xSquared > <%FT.DoubleToString(S, 0.0)%>) {
				<%FT.type%> a = <%sqrtFunc%>(s_xSquared);
				return <%SASfuncI%>(x, <%sinFunc%>(a) / a, <%FT.DoubleToString(S, 0.0)%>);
			}
			else {
<%if ((returnType != inputType) && (returnType != FT.GetMangledName(S, S.m_GMV.Name))) {%>
				return <%copyInputToReturnFunc%>(x);
<%} else {%>
				return x;
<%}%>
			}
		}
	}

	// else do general series eval . . .

	// result = A -  ....	+ ... - ...
	<%returnType%> result = new <%returnType%>(); // result = 0;
    if (order == 0) return result;
    	
	// taylor series approximation
	<%returnType%> xPow1 = new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>); // xPow1 = 1.0
	for (int i = 1; i <= order; i++) {
		<%returnType%> xPow2 = <%gpFuncRI%>(xPow1, x); // xPow2 = xPow1 * x
		
		xPow1 = <%gpFuncRdouble%>(xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i); // xPow1 = xScaled^i / i! 
		
		if ((i % 4) == 3)
		{
			result = <%subFuncRR%>(result, xPow1); // result = result - xPow1
		}
		else if ((i % 4) == 1) 
		{
			result = <%addFuncRR%>(result, xPow1); // result = result + xPow1
		}
	}

	return result;
} // end of <%funcName%>()

${ENDCODEBLOCK}

// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesCos}
<%new G25.CG.Shared.Comment("Computes cosine of " + inputType + " up to 12th term.\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x) {
	return <%funcName%>(x, 12);
}

<%new G25.CG.Shared.Comment("Computes cosine of " + inputType + ".\n" + userComment).ToString(S, 0)%>
public <%if (S.OutputJava()) {%>final <%}%>static <%returnType%> <%funcName%>(<%if (S.OutputJava()) {%>final <%}%><%inputType%> x, <%if (S.OutputJava()) {%>final <%}%>int order) {
	{ // First try special cases: check if (x * x) is scalar
		<%returnType%> xSquared = <%gpFuncII%>(x, x);
		<%FT.type%> s_xSquared = xSquared.get_scalar();
		if ((<%normE2funcR%>(xSquared) - s_xSquared * s_xSquared) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
			// OK (x * x == ~scalar), so use special cases:
			if (s_xSquared > <%FT.DoubleToString(S, 0.0)%>) {
				return new <%returnType%>(<%cosFunc%>(<%sqrtFunc%>(s_xSquared)));
			}
			else if (s_xSquared < <%FT.DoubleToString(S, 0.0)%>) {
				return new <%returnType%>(<%coshFunc%>(<%sqrtFunc%>(-s_xSquared)));
			}
			else {
				return new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>);
			}
		}
	}

	// else do general series eval . . .


	<%returnType%> result = new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>);
	if (order == 0) return result;

	// taylor series approximation
	<%returnType%> xPow1 = new <%returnType%>(<%FT.DoubleToString(S, 1.0)%>); // xPow1 = 1.0
	for (int i = 1; i <= order; i++) {
		<%returnType%> xPow2 = <%gpFuncRI%>(xPow1, x); // xPow2 = xPow1 * x
		xPow1 = <%gpFuncRdouble%>(xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i); // xPow1 = xScaled^i / i! 
		
		if ((i % 4) == 2)
		{
			result = <%subFuncRR%>(result, xPow1); // result2 = result1 - xPow1
		}
		else if ((i % 4) == 0) 
		{
			result = <%addFuncRR%>(result, xPow1); // result2 = result1 + xPow1
		}		
    }

	return result;
} // end of <%funcName%>()
${ENDCODEBLOCK}

// S = Specification of algebra.
// functionName = name of generated function
// FT = floating point type
// mvType = multivector type name (with prefix/suffix)
// randomScalarFuncName = name of function which generates random scalar values
// gpopFuncName = name of geometric product or outer product function for two multivectors
// normFuncName = norm of multivector function (must return scalar)
// gpScalarFuncName = geometric product of multivector and scalar
// generatorVersor = bool (use geometric product or outer product)
${CODEBLOCK randomBladeVersor}

<%new G25.CG.Shared.Comment("Generates a random " + ((generatorVersor) ? "versor" : "blade") + ".\n"+
	"The scale is uniformly distributed over the interval [0 1).\n" + 
	"The maximum non-zero grade-part is 'grade'.\n" + 
	"\n" + 
	"Only the basis vectors marked in 'basisVectorBitmap' will be used to generate the versor/blade.\n" + 
	"Use 'basisVectorBitmap = -1' (the default) to use all basisvectors.").
	SetReturnComment(functionName + "_ex(arg1, scale, grade, basisVectorBitmap, 0.01, scale * 4.0)").
	ToString(S, 0)%>
public static <%mvType%> <%functionName%>(<%FT.type%> scale, int grade, int basisVectorBitmap) {
	<%FT.type%> minimumNorm = <%FT.DoubleToString(S, 0.01)%>;
	<%FT.type%> largestCoordinate = <%FT.DoubleToString(S, 4.0)%>;
	return <%functionName%>_ex(scale, grade, basisVectorBitmap, minimumNorm, scale * largestCoordinate);
}

<%new G25.CG.Shared.Comment("This version of " + functionName + "() has extra arguments which help to avoid\n" + 
	"near-singular blades / versors.\n" + 
	"\n" + 
	"Near-singular blades / versors are avoid by testing the norm and largest coordinate\n" + 
	"of the random blade / versor. If the test does not pass, the function recursively\n" + 
	"tries to generate another random blade / versor.\n" + 
	"\n" + 
	"'minimumNorm' is the minimum allowed norm of the blade/versor before scaling. \n" + 
	"'minimumNorm' must be > 0.0 for versors.\n" + 
	"\n" + 
	"'largestCoordinate' is the largest coordinate allowed after scaling.\n").
	SetReturnComment(functionName + "_ex(arg1, scale, grade, basisVectorBitmap, 0.01, scale * 4.0)").
	ToString(S, 0)%>
public static <%mvType%> <%functionName%>_ex(<%FT.type%> scale, int _grade, int basisVectorBitmap, 
		<%FT.type%> minimumNorm, <%FT.type%> largestCoordinate) 
{
	<%mvType%> randomVector = new <%mvType%>();
	//, tmp1, tmp2;
	<%FT.type%>[] randomValues = new <%FT.type%>[<%S.m_dimension%>];
	//<%FT.type%> n2, mul;
	int grade = _grade;
	
	// set IR (intermediate result) to 1
	<%mvType%> IR = new <%mvType%> (<%FT.DoubleToString(S, 1.0)%>);

	while (grade > 0) {	// loop until grade == 0
		// fill array with random values
		for (int i = 0; i < <%S.m_dimension%>; i++) 
			randomValues[i] = ((basisVectorBitmap & (1 << i)) == 0)
				? (<%FT.DoubleToString(S, -1.0)%> + <%FT.DoubleToString(S, 2.0)%> * <%randomScalarFuncName%>())
				: <%FT.DoubleToString(S, 0.0)%>;
		
		// make it a multivector:
		randomVector.<%G25.CG.CSJ.Util.GetFunctionName(S, "set")%>(GroupBitmap.GRADE_1, randomValues);
		
		// multiply 
		IR = <%gpopFuncName%>(IR, randomVector);
		
		// lower grade
		grade--;
	}
	
	// compute norm/multiplier, apply it, or recurse if we happened to create a near-null versor
	<%FT.type%> n2 = <%normFuncName%>(IR);
	if ((<%FT.type%>)<%G25.CG.Shared.CodeUtil.OpNameToLangString(S, FT, RefGA.Symbolic.ScalarOp.ABS)%>(n2) > minimumNorm * minimumNorm) {
		if (n2 != <%FT.DoubleToString(S, 0.0)%>) {
			<%FT.type%> mul = scale * <%randomScalarFuncName%>() / n2;
			if (IR.<%G25.CG.CSJ.Util.GetFunctionName(S, "largestCoordinate")%>() * mul < largestCoordinate)
				return <%gpScalarFuncName%>(IR, mul);
		}
		else if (IR.<%G25.CG.CSJ.Util.GetFunctionName(S, "largestCoordinate")%>() < largestCoordinate)
			return IR;
	}
	
	// try again:
	return <%functionName%>_ex(scale, _grade, basisVectorBitmap, minimumNorm, largestCoordinate); 
}
${ENDCODEBLOCK}




// S = Specification of algebra.
${CODEBLOCK ParseExceptionSource_Java}
package <%S.m_namespace%>_pkg;

public class ParseException extends Exception {
	private static final long serialVersionUID = 1L;

	public ParseException(String message)
    {
    	super(message);
    }
}
${ENDCODEBLOCK}



// S = Specification of algebra.
// FT = float type to be used
${CODEBLOCK BuiltinParserSource_CSharp_Java}
<%{
	string BOOL_TYPE = (S.OutputJava()) ? "boolean" : "bool";
	string FINAL = (S.OutputJava()) ? "final " : "";
%>


<%if (S.OutputJava()) {%>
package <%S.m_namespace%>_pkg;
<%} else {%>
namespace <%S.m_namespace%>_ns {

	/// <summary>This exception is throws by parse() when there is an error in the input.</summary>
    public class ParseException : Exception
    {
        public ParseException(String message)
            : base(message)
        {
        }
    }
<%}%>

	public class Parser {
		private class BasisBlade
		{
			private int bitmap = 0;
			private <%FT.type%> scale = <%FT.DoubleToString(S, 1.0)%>;

			public int getBitmap() { return bitmap;  }
			public <%FT.type%> getScale() { return scale;  }

			public void wedgeBasisVector(int bvIdx)
			{
				int b;

				b = 1 << bvIdx;
				if ((bitmap & b) != 0)
				{ // bv ^ bv = 0
					scale = <%FT.DoubleToString(S, 0.0)%>;
					return;
				}
				else
				{
					// add basis vector to bitmap	
					bitmap |= b;

					bvIdx++;
					for (; bvIdx <= <%S.m_dimension%>; bvIdx++) // compute sign flips due to anti commuting basis vectors
						if ((bitmap & (1 << bvIdx)) != 0) scale = -scale;
				}
			}

			public void multiply(<%FT.type%> scalar)
			{
				scale *= scalar;
			}
		}

		private String inputString;
		private String sourceString;
		private int startIdx = 0;
		private int endIdx = 0;
		private int lineIdx = 0;
		private int currentLineStart = 0;
		private <%FT.type%>[] coord = new <%FT.type%>[<%1 << S.m_dimension%>];

		// TOKEN IDs: (for internal use only)
		private <%FINAL%>int T_BAD_IDENTIFIER = -100;
		private <%FINAL%>int T_BAD_NUMBER = -10;
		private <%FINAL%>int T_BAD_CHARACTER = -1;
		private <%FINAL%>int T_END_OF_STRING = 0;
		private <%FINAL%>int T_WEDGE = 1;
		private <%FINAL%>int T_MUL = 2;
		private <%FINAL%>int T_PLUS = 3;
		private <%FINAL%>int T_MINUS = 4;
		private <%FINAL%>int T_NUMBER = 10;
		private <%FINAL%>int T_FIRST_BASIS_VECTOR = 100;
		private <%FINAL%>int T_LAST_BASIS_VECTOR = 104;

		private <%FINAL%>ParseException GetException(<%FINAL%>String reason)
		{
			return new ParseException(reason + " at " + sourceString + ", line " + (lineIdx+1) + ", column " + (startIdx - currentLineStart +1));
		}

		private Parser(<%FINAL%>String input, <%FINAL%>String source) {
			inputString = input;
			sourceString = source;
			if ((sourceString == null) || (length(sourceString) == 0))
				sourceString = "string";
		}

		private <%FINAL%>void sum(<%FINAL%>BasisBlade bb) {
			int idx = <%S.m_namespace%>.BasisElementIndexByBitmap[bb.getBitmap()];
			coord[idx] += bb.getScale() / (<%FT.type%>)<%S.m_namespace%>.BasisElementSignByIndex[idx];
		}

	<%if (S.OutputJava()) {%>
		private final static boolean isLetter(final char x) {
    		return Character.isLetter(x);
		}
		private final static boolean isDigit(final char x) {
    		return Character.isDigit(x);
		}
		private final static boolean isLetterOrDigit(final char x) {
    		return Character.isLetterOrDigit(x);
		}
		private final String substring(final int startIdx, final int endIdx) {
    		return inputString.substring(startIdx, endIdx);
		}
		private final static int length(final String str) {
    		return str.length();
		}
		private final static char charAt(final String str, final int idx) {
    		return str.charAt(idx);
		}
	<%} else {%>
		private static bool isLetter(char x) {
    		return Char.IsLetter(x);
		}
		private static bool isDigit(char x) {
    		return Char.IsDigit(x);
		}
		private static bool isLetterOrDigit(char x) {
    		return Char.IsLetterOrDigit(x);
		}
		private String substring(int startIdx, int endIdx) {
    		return inputString.Substring(startIdx, endIdx - startIdx + 1);
		}
		private static int length(String str) {
    		return str.Length;
		}
		private static char charAt(String str, int idx) {
    		return str[idx];
		}    
	<%}%>
	   

		private <%FINAL%>int getNextToken() {

			// skip all whitespace and other empty stuff, keep track of line index
			while (startIdx < length(inputString) && (charAt(inputString, startIdx) >= 0) && (charAt(inputString, startIdx) <= ' ')) {
				if (charAt(inputString, startIdx) == 0x0A) { // start of new line
					lineIdx++;
					currentLineStart = startIdx+1;
				}
				startIdx++;
			}

			// detect end of string
			if (startIdx == length(inputString)) {
				startIdx = endIdx;
				return T_END_OF_STRING; // EOS
			}

			// operators
			if (charAt(inputString, startIdx) == '^') {endIdx = startIdx; return T_WEDGE;} // ^
			else if (charAt(inputString, startIdx) == '*') {endIdx = startIdx; return T_MUL;} // *
			else if (charAt(inputString, startIdx) == '+') {endIdx = startIdx; return T_PLUS;} // +
			else if (charAt(inputString, startIdx) == '-') {endIdx = startIdx; return T_MINUS;} // -

			else if (isDigit(charAt(inputString, startIdx)) || (charAt(inputString, startIdx) == '.')) { // parse number?
				endIdx = startIdx;

				// eat up all digits and at most one point
				<%BOOL_TYPE%> pointFound = false;
				while (isDigit(charAt(inputString, endIdx)) || (charAt(inputString, endIdx) == '.')) {
					endIdx++;
					if (charAt(inputString, endIdx) == '.') {
						endIdx++;
						pointFound = true;
						break;
					}
				}
	    		
				if (pointFound) { // if point found, eat up all digits
					while (isDigit(charAt(inputString, endIdx))) {
						endIdx++;
					}
				}

				// see if there is a 'e' or 'E'
				if  ((charAt(inputString, endIdx) == 'e') || (charAt(inputString, endIdx) == 'E')) {
					endIdx++;
					// accept at most one +-
					if  ((charAt(inputString, endIdx) == '-') || (charAt(inputString, endIdx) == '+')) {
						endIdx++;
					}

					// if there is an 'e', there must be some digit
					if (!isDigit(charAt(inputString, endIdx))) return T_BAD_NUMBER; // bad number

					// eat up all digits
					while (isDigit(charAt(inputString, endIdx))) {
						endIdx++;
					}
				}
				endIdx--; // end index is inclusive
				return T_NUMBER;
			}

			else if (isLetter(charAt(inputString, startIdx)) || (charAt(inputString, startIdx) == '_')) { // parse identifier?
				// find end of chain of numbers, letters and '_'
				endIdx = startIdx + 1;

				while (isLetterOrDigit(charAt(inputString, endIdx)) || (charAt(inputString, endIdx) == '_')) endIdx++;
				endIdx--;  // end index is inclusive

				// see which basis vector it is
				for (int i = 0; i < <%S.m_dimension%>; i++)
					if (<%S.m_namespace%>.BasisVectorNames[i].<%G25.CG.CSJ.Util.GetFunctionName(S, "equals")%>(substring(startIdx, endIdx))) return T_FIRST_BASIS_VECTOR + i; // basis vector
				return T_BAD_IDENTIFIER; // bad identifier
			}

			else return T_BAD_CHARACTER;
		} // end of getNextToken()

<%new G25.CG.Shared.Comment("Parses a multivector string (e.g., as created by " + FT.GetMangledName(S, S.m_GMV.Name) + ".ToString())\nThrows a ParseException when the input cannot be parsed.\n").
			SetParamComment("str", "The multivector string.").
			SetParamComment("strSourceName", "Description of where the string came from (may be null). This string is used in exception messages.").
			ToString(S, 2)%>
		public <%FINAL%>static <%FT.GetMangledName(S, S.m_GMV.Name)%> <%G25.CG.CSJ.Util.GetFunctionName(S, "parse")%>(<%FINAL%>String str, <%FINAL%>String strSourceName) <%if (S.OutputJava()) {%>throws ParseException<%}%> 
		{
			return new Parser(str, strSourceName).<%G25.CG.CSJ.Util.GetFunctionName(S, "parse")%>();
		}
	    
		private <%FINAL%><%FT.GetMangledName(S, S.m_GMV.Name)%> <%G25.CG.CSJ.Util.GetFunctionName(S, "parse")%>() <%if (S.OutputJava()) {%>throws ParseException <%}%>{
			int token;
			<%BOOL_TYPE%> firstLoop = true;

			// get the first token
			token = getNextToken();

			while (true) {
				// reset for next basis blade
				BasisBlade bb = new BasisBlade();
				<%BOOL_TYPE%> beDone = false; // basis element done

				if (token == T_END_OF_STRING) break;

				int cnt = 0;
				while ((token == T_PLUS) || (token == T_MINUS)) { // accept all +- 
					cnt++;
					startIdx = endIdx+1;
					if (token == T_MINUS) bb.multiply(<%FT.DoubleToString(S, -1.0)%>); // -
					token = getNextToken();
				}
	    		
				// require at least one +- if this is not the first term:
				if ((!firstLoop) && (cnt == 0)) {
					throw GetException("Expected '+' or '-'");
				}

				if ((token == T_NUMBER) || 
					((token >= T_FIRST_BASIS_VECTOR) && (token <= T_LAST_BASIS_VECTOR))) // must be number or basis vector
				{ 
					if (token == T_NUMBER) {
						{ // multiply scale with value of number
							try {
								bb.multiply((<%FT.type%>)Double.<%if (S.OutputJava()) {%>parseDouble<%} else {%>Parse<%}%>(substring(startIdx, endIdx)));
							} catch (Exception <%if (S.OutputJava()) {%>ex<%}%>) {
								throw GetException("Cannot parse number"); 
							}
						}
						startIdx = endIdx+1;

						// * or ^ ?
						token = getNextToken();
						if ((token == T_WEDGE) || (token == T_MUL)) {
							startIdx = endIdx+1;

							// must find basis vector
							token = getNextToken();
						}
						else { // just a single scalar is OK
							startIdx = endIdx+1;
							beDone = true;
						}

					}

					if (!beDone) {
						if ((token >= T_FIRST_BASIS_VECTOR) && (token <= T_LAST_BASIS_VECTOR)) {
							int bvIdx = token - T_FIRST_BASIS_VECTOR;
							bb.wedgeBasisVector(bvIdx);
							startIdx = endIdx+1;
						}
						else {
							throw GetException("Expected basis vector");
						}
					}

					if (!beDone) {
						// accept ^ basis vector as many times as it takes
						while (true) {
							// ^
							token = getNextToken();
							if (token != T_WEDGE) break;
							startIdx = endIdx+1;

							// basis vector
							token = getNextToken();
							if ((token >= T_FIRST_BASIS_VECTOR) && (token <= T_LAST_BASIS_VECTOR)) {
								int bvIdx = token - T_FIRST_BASIS_VECTOR;
								bb.wedgeBasisVector(bvIdx);
								startIdx = endIdx+1;
							}
							else {
								throw GetException("Expected basis vector");
							}


						}

					}
				} // end of 'if number or bv'
				else if (token == T_BAD_CHARACTER) {
					throw GetException("Bad character");
				}
				else if (token == T_BAD_NUMBER) {
					throw GetException("Bad number");
				}
				else if (token == T_BAD_IDENTIFIER) {
					throw GetException("Bad identifier");
				}
				else {
					throw GetException("Unexpected token");
				}

				// add
				sum(bb);
	    		
				// remeber that the first loop is done
				firstLoop = false;
			}

			// compress
			return new <%FT.GetMangledName(S, S.m_GMV.Name)%>(<%for (int i = 0; i <= S.m_dimension; i++) {%>GroupBitmap.GRADE_<%i%> | <%}%>0,  coord);
		} // end of Parse()


	} // end of class Parser

<%if (S.OutputCSharp()) {%>
}
<%}%>

<%}%>

${ENDCODEBLOCK}

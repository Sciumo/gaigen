// S = specification
// FT = floatType
${CODEBLOCK GMVmemberVariables}
    /// <summary>
	/// the coordinates
    /// </summary>
	protected internal <%FT.type%>[][] m_c = new <%FT.type%>[<%S.m_GMV.NbGroups%>][]; 
	
<%if (S.m_reportUsage) {%>
    /// <summary>
	/// Specialized multivector type. Used to report about non-optimized function usage.
    /// </summary>
	protected internal SmvType m_t = SmvType.<%G25.CG.Shared.ReportUsage.GetSpecializedConstantName(S, "none")%>; 
<%}%>
${ENDCODEBLOCK}
 
 // S = specification
// className = mangled class name
// FT = floatType
${CODEBLOCK GMVconstructors}
<%{
bool dynMem = S.m_GMV.MemoryAllocationMethod == G25.GMV.MEM_ALLOC_METHOD.DYNAMIC;
bool repUsage = S.m_reportUsage;
%>

    /// <summary>
	/// Constructs a new <%className%> with value 0.
    /// </summary>
	public <%className%>() {Set();}

    /// <summary>
	/// Copy constructor.
    /// </summary>
	public <%className%>(<%className%> A) {Set(A);}

<%foreach (G25.FloatType otherFT in S.m_floatTypes) {
	 if (FT == otherFT) continue;%>
    /// <summary>
	/// Copies from <%otherFT.type%> to <%FT.type%>.
    /// </summary>
	public <%className%>(<%otherFT.GetMangledName(S, S.m_GMV.Name)%> A) {Set(A);}	 
<%}%>

    /// <summary>
	/// Constructs a new <%className%> with scalar value 'scalar'.
    /// </summary>
	public <%className%>(<%FT.type%> scalar) {Set(scalar);}

    /// <summary>
	/// Constructs a new <%className%> from compressed 'coordinates'.
	/// <param name="gu">bitwise OR of the GRADEs or GROUPs that are non-zero.</param>
	/// <param name="coordinates"> compressed coordinates.</param>
    /// </summary>
	public <%className%>(<%G25.CG.CSJ.GMV.GROUP_BITMAP%> gu, <%FT.type%>[] coordinates) {Set(gu, coordinates);}

    /// <summary>
	/// Constructs a new <%className%> from 'coordinates'.
	/// <param name="coordinates">The coordinates (one array for each group, entries may be null). The arrays are kept.</param>
    /// </summary>
	public <%className%>(<%FT.type%>[][] coordinates) {Set(coordinates);}
	
<%foreach(G25.SMV smv in S.m_SMV) {
string smvClassName = FT.GetMangledName(S, smv.Name);%>
    /// <summary>
	/// Converts a <%smvClassName%> to a <%className%>.
    /// </summary>
	public <%className%>(<%smvClassName%> A) {Set(A);}
<%}%>

<%}%>
${ENDCODEBLOCK}

// S = specification
// gmv = gmv type
// FT = floatType
${CODEBLOCK GMVsetGroupUsage}
    /// <summary>
	/// Reserves memory for the groups specified by 'gu'.
	/// Keeps old memory (and values) when possible.
    /// </summary>
	private void AllocateGroups(<%G25.CG.CSJ.GMV.GROUP_BITMAP%> gu) {
		for (int i = 0; (1 << i) <= (int)gu; i++) {
			if (((1 << i) & (int)gu) != 0) {
				if (m_c[i] == null)
					m_c[i] = new <%FT.type%>[<%S.m_namespace%>.MvSize[1 << i]];
			}
			else m_c[i] = null;
		}		
	}
${ENDCODEBLOCK}

// S = specification
// gmv = gmv type
// FT = floatType
${CODEBLOCK GMVreserveGroups}
<%for (int groupIdx = 0; groupIdx < gmv.NbGroups; groupIdx++) { %>
	/// <summary>
	/// Reserves memory for coordinate GROUP_<%groupIdx%>.
	/// If the group is already present, nothing changes.
	/// If the group is not present, memory is allocated for the new group,
	/// and the coordinates for the group are set to zero.
	/// </summary>
	private void ReserveGroup_<%groupIdx%>() {
		if (m_c[<%groupIdx%>] == null) {
			m_c[<%groupIdx%>] = new <%FT.type%>[<%gmv.Group(groupIdx).Length%>];
		}
	}
<%}%>
${ENDCODEBLOCK}



// S = specification
// FT = floatType
${CODEBLOCK GMVgetGroupUsageCoords}
    /// <summary>
	/// returns group usage bitmap
    /// </summary>
	public <%G25.CG.CSJ.GMV.GROUP_BITMAP%> gu() {
		return 
<%for (int g = 0; g < S.m_GMV.NbGroups; g++) {%>
			((m_c[<%g%>] == null) ? 0 : <%G25.CG.CSJ.GroupBitmap.GetGroupBitmapCode(g)%>) |
<%}%>
			0;
	}
    /// <summary>
	/// Returns array of array of coordinates.
	/// Each entry contain the coordinates for one group/grade.
    /// </summary>
	public <%FT.type%>[][] c() { return m_c; }
	
${ENDCODEBLOCK}

// FT = floatType
// COORD_TYPE_STRING = string of type which describes coordinates
${CODEBLOCK SMVgetCoords}
    /// <summary>
	/// returns coordinates.
    /// </summary>
    /// <param name="coordOrder">pass the value <%COORD_TYPE_STRING%></param>
	public <%FT.type%>[] c(<%G25.CG.Shared.SmvUtil.COORDINATE_ORDER_ENUM%> coordOrder) { return m_c; }	
${ENDCODEBLOCK}

// S = Specification of algebra.
// MAX_N = maximum number of coordinates to set to zero explicitly
// FT = float type
${CODEBLOCK float_zero_copy_def}
<%for (int n = 1; n <= MAX_N; n++) {%>
    /// <summary>Sets <%n%> <%FT.type%>s to zero.</summary>
	protected internal static void Zero_<%n%>(<%FT.type%>[] dst) {
		<%for (int i = 0; i < n; i++) {%>dst[<%i%>]=<%}%><%FT.DoubleToString(S, 0.0)%>;
	}
	/// <summary>Copies <%n%> <%FT.type%>s from 'src' to 'dst'. </summary>
	protected internal static void Copy_<%n%>(<%FT.type%>[] dst, <%FT.type%>[] src) {
	<%for (int i = 0; i < n; i++) {%>
		dst[<%i%>] = src[<%i%>];
	<%}%>
}
<%}%>
	/// <summary>Sets N <%FT.type%>s to zero.</summary>
	protected internal static void Zero_N(<%FT.type%>[] dst, int N) {
		for (int i = 0; i < N; i++)
			dst[i] = <%FT.DoubleToString(S, 0.0)%>;
	}
	/// <summary>Copies N <%FT.type%>s from 'src' to 'dst'. </summary>
	protected internal static void Copy_N(<%FT.type%>[] dst, <%FT.type%>[] src, int N) {
		for (int i = 0; i < N; i++)
			dst[i] = src[i];
	}
${ENDCODEBLOCK}

// S = specification
// FT = float type
// gmv = gmv type
// gmvName = name of first GMV type
${CODEBLOCK sourceToString}

	private const string DEFAULT_FP = "F2";
	private const string DEFAULT_START = "";
	private const string DEFAULT_END = "";
	private const string DEFAULT_MUL = "*";
	private const string DEFAULT_WEDGE = "^";
	private const string DEFAULT_PLUS = " + ";
	private const string DEFAULT_MINUS = " - ";

	// These strings determine how the output of string() is formatted.
	// You can alter them at runtime using setStringFormat(). 
	protected static string string_fp = DEFAULT_FP;
	protected static string string_start = DEFAULT_START;
	protected static string string_end = DEFAULT_END;
	protected static string string_mul = DEFAULT_MUL;
	protected static string string_wedge = DEFAULT_WEDGE;
	protected static string string_plus = DEFAULT_PLUS;
	protected static string string_minus = DEFAULT_MINUS;
	
	public const string STRING_FP = "fp";
	public const string STRING_START = "start";
	public const string STRING_END = "end";
	public const string STRING_MUL = "mul";
	public const string STRING_WEDGE = "wedge";
	public const string STRING_PLUS = "plus";
	public const string STRING_MINUS= "minus";

	/// <summary>
	/// Sets the formatting of toString().
	/// </summary>
	/// 
	/// <param name="what">What formatter to set. Valid values: string_FP, string_START, string_END, string_MUL, string_WEDGE, string_PLUS, string_MINUS.</param>
	/// <param name="format">The value for 'what'. Use 'null' to set the default value.</param>
	public static void SetStringFormat(string what, string format) {
		if (what.Equals(STRING_FP)) 
			string_fp = (format != null) ? format : DEFAULT_FP;
		else if (what.Equals(STRING_START)) 
			string_start = (format != null) ? format : DEFAULT_START;
		else if (what.Equals(STRING_END)) 
			string_end = (format != null) ? format : DEFAULT_END;
		else if (what.Equals(STRING_MUL)) 
			string_mul = (format != null) ? format : DEFAULT_MUL;
		else if (what.Equals(STRING_WEDGE)) 
			string_wedge = (format != null) ? format : DEFAULT_WEDGE;
		else if (what.Equals(STRING_PLUS)) 
			string_plus = (format != null) ? format : DEFAULT_PLUS;
		else if (what.Equals(STRING_MINUS)) 
			string_minus = (format != null) ? format : DEFAULT_MINUS;
		else throw new ArgumentException("invalid argument to setStringFormat(): " + what);
	}
	
    /// <summary>Converts a multivector to a string using default float format.</summary>
	public static string String(<%gmvName%> obj) {
		return String(obj, null);
	}
	
   /** 
    * 
	* @param fp 
	*/
	/// <summary>
	/// Converts a multivector to a string according to a float format like  "F"
	/// </summary>
	/// <param name="fp">floating point format. Use 'null' for the default format (see setStringFormat()).</param>
	public static string String(<%gmvName%> obj, string fp) {
		System.Text.StringBuilder result = new System.Text.StringBuilder();
		int ia = 0; // global index into coordinates (runs from 0 to <%(gmv.NbCoordinates-1)%>)
		int cnt = 0; // how many coordinates printed so far

		// set up the floating point precision
		if (fp == null) fp = string_fp;

		// start the string
		result.Append(string_start);

		// print all coordinates
		for (int g = 0; g < <%gmv.NbGroups%>; g++) {
			<%FT.type%>[] Cg = obj.m_c[g];
			if (Cg != null) {
				for (int b = 0; b < GroupSize[g]; b++) {
					<%FT.type%> coord = (double)BasisElementSignByIndex[ia] * Cg[b];
					
					// goal: print [+|-]obj.m_c[k][* basisVector1 ^ ... ^ basisVectorN]
					
					string tmpFloatStr = Math.Abs(coord).ToString(fp);

					if (Double.Parse(tmpFloatStr) != 0.0) {
						// print [+|-]
						result.Append((coord >= 0.0) 
							? ((cnt>0) ? string_plus : "")
							: string_minus);
						// print obj.m_c[k]
						result.Append(tmpFloatStr);

						if (g != 0) { // if not grade 0, print [* basisVector1 ^ ... ^ basisVectorN]
							result.Append(string_mul);

							// print all basis vectors
							int bei = 0;
							while (BasisElements[ia][bei] >= 0) {
								if (bei > 0)
									result.Append(string_wedge);
								result.Append(BasisVectorNames[BasisElements[ia][bei]]);
								bei++;
							}
						}

						cnt++;
					}
					ia++;
				}
			}
			else ia += GroupSize[g];
		}

		// if no coordinates printed: 0
		if (cnt == 0) result.Append("0");

		// end the string
		result.Append(string_end);

		return result.ToString();
	}

${ENDCODEBLOCK}

// S = specification
// FT = float type
${CODEBLOCK GMVtoString}
	/// <summary>
	/// Returns this multivector, converted to a string.
	/// The floating point formatter is controlled via <%S.m_namespace%>.setStringFormat().
	/// </summary>
	public override string ToString() {
<%if (FT == S.m_floatTypes[0]) {%>
		return <%S.m_namespace%>.String(this);
<%} else {%>
		return <%S.m_namespace%>.String(new <%S.m_floatTypes[0].GetMangledName(S, S.m_GMV.Name)%>(this));
<%}%>
	}
	
	/// <summary>
	/// Returns this multivector, converted to a string.
	/// <param name="fp">floating point format. Use 'null' for the default format (see setStringFormat()).</param>
	/// </summary>
	public string ToString(string fp) {
<%if (FT == S.m_floatTypes[0]) {%>
		return <%S.m_namespace%>.String(this, fp);
<%} else {%>
		return <%S.m_namespace%>.String(new <%S.m_floatTypes[0].GetMangledName(S, S.m_GMV.Name)%>(this), fp);
<%}%>
	}
${ENDCODEBLOCK}



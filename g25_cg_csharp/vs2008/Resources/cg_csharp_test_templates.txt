// S = Specification
// testFunctionNames = array of string of names of test functions
// randomNumberSeedFunctionNames = array of string of names of random number generator seed-with-current-time functions
${CODEBLOCK testSuiteMain}
static void Main(string[] args)
{
	int retVal = 0;
	// The number of tests will be proportional to this value.
	// This should become a command-line option
	const int NB_TESTS_SCALER = 16384;
	
	// seed random number generators with current time
<%foreach(string funcName in randomNumberSeedFunctionNames) {%>
	<%S.m_namespace%>.<%funcName%>();
<%}%>

	// run all test functions
<%foreach(string funcName in testFunctionNames) {%>
	if (<%funcName%>(NB_TESTS_SCALER) == 0) retVal = -1;
<%}%>

	if (retVal != 0) Console.WriteLine("Test failed.\n");
	else Console.WriteLine("Done.\n");	

	Environment.Exit(retVal);
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// M = metric
// gmv = GMV type
// gmvName = name of gmv
// testFuncName = name of function
// gpGmvFuncName = name of function for gp of two 'gmv'
${CODEBLOCK testMetric}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int i, j;
	<%FT.type%>[] arr = new <%FT.type%>[<%S.m_dimension%>];
	<%FT.type%> dif;
	<%gmvName%> A;
	<%gmvName%>[] bv = new <%gmvName%>[<%S.m_dimension%>];
	<%FT.type%>[] M = new <%FT.type%>[<%S.m_dimension * S.m_dimension%>+1]{
		<%for (int i = 0; i < S.m_dimension; i++) { for (int j = 0; j < S.m_dimension; j++) {%><%FT.DoubleToString(S, M.m_metric.GetEntry(i, j))%>, <%}%><%}%><%FT.DoubleToString(S, 0.0)%>
	}; // metric matrix

	// get all basis vectors
<%for (int v = 0; v < S.m_dimension; v++) {
	RefGA.BasisBlade B = new RefGA.BasisBlade((uint)(1 << v));
	int groupIdx = gmv.GetGroupIdx(B);
	int elemIdx = gmv.GetElementIdx(B);
	RefGA.BasisBlade R = S.m_GMV.BasisBlade(groupIdx, elemIdx);
%>

	<%G25.CG.Shared.Util.GetSetToZeroCode(S, FT, "arr", gmv.Group(groupIdx).Length)%>
	arr[<%elemIdx%>] = <%FT.DoubleToString(S, 1.0 / R.scale)%>;
	bv[<%v%>] = new <%gmvName%>(GroupBitmap.GROUP_<%groupIdx%>, arr);
<%}%>

	for (i = 0; i < <%S.m_dimension%>; i++) {
		for (j = 0; j < <%S.m_dimension%>; j++) {
			A = <%gpGmvFuncName%>(bv[i], bv[j]);
			dif = M[i * <%S.m_dimension%> + j] - A.get_scalar();
			if ((dif < <%FT.DoubleToString(S, -FT.PrecisionEpsilon())%>) || (dif > <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>)) {
				Console.WriteLine("<%testFuncName%>() test failed for " + BasisVectorNames[i] + " " + BasisVectorNames[j]);
				return 0;
			}
		}
	}
	
	return 1;
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// testFuncName = name of testing function
// gmvName = name of gmv
// targetFuncName = name of function to test
// randomScalarFuncName = name of random generator function
// randomVersorFuncName = name of function for random 'gmv'
// subtractGmvFuncName = name of function for adding two 'gmv'
${CODEBLOCK testParse}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%(4 * S.m_GMV.NbCoordinates)%>;
	<%gmvName%> A, B, C;
	String str;
	
	int i, basisVectorBitmap = -1;

	for (i = 0; i < NB_LOOPS; i++) {
		A = <%randomVersorFuncName%>(<%randomScalarFuncName%>(), (int)(<%randomScalarFuncName%>() * <%FT.DoubleToString(S, S.m_dimension + 0.5)%>), basisVectorBitmap);
		
		str = A.ToString("E20");
		
		try {
			B = <%targetFuncName%>(str);
		} catch (ParseException ex) {
			Console.WriteLine("<%targetFuncName%>() test failed: " + ex.ToString());
			return 0; // failure
		}

		C = <%subtractGmvFuncName%>(A, B);

		if (C.LargestCoordinate() > <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed (largest coordinate: " + C.LargestCoordinate() + ")");
			return 0; // failure
		}
	}
	
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// testAdd = whether addition (true) or subtraction (false) is being tested
// testFuncName = name of testing function
// gmv = gmv type
// gmvName = name of gmv
// targetFuncName = name of function to test
// randomScalarFuncName = name of random generator function
// randomGmvFuncName = name of function for random 'gmv'
// negateGmvFuncName = name of negation of a GMVs
${CODEBLOCK testAddSubtractGMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%S.m_GMV.NbCoordinates%>;
	<%gmvName%> A, B, C;
	int i, g;
	<%FT.type%> s;
	int basisVectorBitmap = -1;
	
	for (i = 0; i < NB_LOOPS; i++) {
		s = <%randomScalarFuncName%>();
		g = (int)(<%randomScalarFuncName%>() * <%FT.DoubleToString(S, S.m_dimension + 0.5)%>);
		A = <%randomGmvFuncName%>(s, g, basisVectorBitmap);
		
<%if (testAdd) { %>
		// B = -A
		B = <%negateGmvFuncName%>(A);
<%} else {%>
		B = A;
<%}%>
		
		C = <%targetFuncName%>(A, B);
		
		// check
		if (C.LargestCoordinate() > <%FT.DoubleToString(S, 10.0 * FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed");
			return 0; // failure
		}
		
	}
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// testFuncName = name of testing function
// smv1 = smv1 type
// smv2 = smv2 type
// smv1Name = name of smv1
// smv2Name = name of smv2
// smvRName = name of return type smv
// gmvName = name of gmv
// targetFuncName = name of function to test
// randomScalarFuncName = name of random generator function
// randomSmv1FuncName = name of function for random 'smv1'
// randomSmv2FuncName = name of function for random 'smv2'
// addOrSubtractGmvFuncName = name of addition or subtraction of two GMVs (which on depends on the target function)
// subtractGmvFuncName = name of subtraction of two GMVs
${CODEBLOCK testAddSubtractSMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%(smv1.NbCoordinates + smv2.NbCoordinates)%>;
	<%smv1Name%> A;
	<%smv2Name%> B;
	<%smvRName%> C;
	<%gmvName%> gA, gB, gC1, gC2;
	
	<%FT.type%> s;
	int i;
	
	for (i = 0; i < NB_LOOPS; i++) {
		s = <%randomScalarFuncName%>();
		A = <%randomSmv1FuncName%>(s);
		B = <%randomSmv2FuncName%>(s);
		
		// add/subtract A and B
		
		C = <%targetFuncName%>(A, B);
		gC1 = new <%gmvName%>(C);
		
		// convert all A and B to gmv and add/subtract as GMVs
		gA = new <%gmvName%>(A);
		gB = new <%gmvName%>(B);
		gC2 = <%addOrSubtractGmvFuncName%>(gA, gB);
		
		// see if result is equal up to precision:
		gA = <%subtractGmvFuncName%>(gC1, gC2);
		if (gA.LargestCoordinate() > <%FT.DoubleToString(S, 10.0 * FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed");
			return 0; // failure
		}		
	}
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// gmvName = name of gmv
// targetFuncName = name of function to test
// testFuncName = name of testing function
// randomScalarFuncName = name of random generator function
// randomVersorFuncName = name of function for random 'gmv'
// gradeGmvFuncName = name of function for taking a grade part of a 'gmv'
// inverseGroupBitmap = bitmap argument for  'gradeGmvFuncName', the inverse of the gradeX
// addGmvFuncName = name of function for adding two 'gmv'
// subtractGmvFuncName = name of function for adding two 'gmv'
${CODEBLOCK testGradeXGMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%S.m_GMV.NbCoordinates%>;
	<%gmvName%> A, B, C, D;
	int i;
	int basisVectorBitmap = -1;
	
	for (i = 0; i < NB_LOOPS; i++) {
		// get random versor
		A = <%randomVersorFuncName%>(<%randomScalarFuncName%>(), (int)(<%randomScalarFuncName%>() * <%FT.DoubleToString(S, S.m_dimension + 0.5)%>), basisVectorBitmap);
		
		B = <%targetFuncName%>(A);
		
		C = <%gradeGmvFuncName%>(A, <%inverseGroupBitmap%>);
		
		// sum all into 'B'
		D = <%addGmvFuncName%>(B, C);

		// check if equal to original:
		C = <%subtractGmvFuncName%>(A, D);
		if (C.LargestCoordinate() > <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed");
			return 0; // failure
		}
	}
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// gmvName = name of gmv
// targetFuncName = name of function to test
// testFuncName = name of testing function
// randomScalarFuncName = name of random generator function
// randomVersorFuncName = name of function for random 'gmv'
// addGmvFuncName = name of function for adding two 'gmv'
// subtractGmvFuncName = name of function for adding two 'gmv'
${CODEBLOCK testGradeGMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%S.m_GMV.NbCoordinates%>;
	<%gmvName%> A, B, C<%for (int i = 0; i < S.m_GMV.NbGroups; i++) {%>, G<%i%><%}%>;
	int i;
	int basisVectorBitmap = -1;
	
	for (i = 0; i < NB_LOOPS; i++) {
		// get random versor
		A = <%randomVersorFuncName%>(<%randomScalarFuncName%>(), (int)(<%randomScalarFuncName%>() * <%FT.DoubleToString(S, S.m_dimension + 0.5)%>), basisVectorBitmap);
		// split it up into groups/grades:
<%for (int i = 0; i < S.m_GMV.NbGroups; i++) {%>
		G<%i%> = <%targetFuncName%>(A, GroupBitmap.GROUP_<%i%>);
<%}%>
		// sum all into 'B'
		B = new <%gmvName%>();
<%for (int i = 0; i < S.m_GMV.NbGroups; i++) {%>
		B = <%addGmvFuncName%>(B, G<%i%>);
<%}%>

		// check if equal to original:
		C = <%subtractGmvFuncName%>(A, B);
		if (C.LargestCoordinate() > <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed (largestCoordinate = " + (double)C.LargestCoordinate() + ")");
			return 0; // failure
		}
	}
	return 1; // success
}
${ENDCODEBLOCK}

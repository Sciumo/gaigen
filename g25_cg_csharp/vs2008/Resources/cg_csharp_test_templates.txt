// S = Specification
// testFunctionNames = array of string of names of test functions
// randomNumberSeedFunctionNames = array of string of names of random number generator seed-with-current-time functions
${CODEBLOCK testSuiteMain}
static void Main(string[] args)
{
	int retVal = 0;
	// The number of tests will be proportional to this value.
	// This should become a command-line option
	const int NB_TESTS_SCALER = 16384;
	
	// seed random number generators with current time
<%foreach(string funcName in randomNumberSeedFunctionNames) {%>
	<%S.m_namespace%>.<%funcName%>();
<%}%>

	// run all test functions
<%foreach(string funcName in testFunctionNames) {%>
	if (<%funcName%>(NB_TESTS_SCALER) == 0) retVal = -1;
<%}%>

	if (retVal != 0) Console.WriteLine("Test failed.\n");
	else Console.WriteLine("Done.\n");	

	Environment.Exit(retVal);
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// M = metric
// gmv = GMV type
// gmvName = name of gmv
// testFuncName = name of function
// gpGmvFuncName = name of function for gp of two 'gmv'
${CODEBLOCK testMetric}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int i, j;
	<%FT.type%>[] arr = new <%FT.type%>[<%S.m_dimension%>];
	<%FT.type%> dif;
	<%gmvName%> A;
	<%gmvName%>[] bv = new <%gmvName%>[<%S.m_dimension%>];
	<%FT.type%>[] M = new <%FT.type%>[<%S.m_dimension * S.m_dimension%>+1]{
		<%for (int i = 0; i < S.m_dimension; i++) { for (int j = 0; j < S.m_dimension; j++) {%><%FT.DoubleToString(S, M.m_metric.GetEntry(i, j))%>, <%}%><%}%><%FT.DoubleToString(S, 0.0)%>
	}; // metric matrix

	// get all basis vectors
<%for (int v = 0; v < S.m_dimension; v++) {
	RefGA.BasisBlade B = new RefGA.BasisBlade((uint)(1 << v));
	int groupIdx = gmv.GetGroupIdx(B);
	int elemIdx = gmv.GetElementIdx(B);
	RefGA.BasisBlade R = S.m_GMV.BasisBlade(groupIdx, elemIdx);
%>

	<%G25.CG.Shared.Util.GetSetToZeroCode(S, FT, "arr", gmv.Group(groupIdx).Length)%>
	arr[<%elemIdx%>] = <%FT.DoubleToString(S, 1.0 / R.scale)%>;
	bv[<%v%>] = new <%gmvName%>(GroupBitmap.GROUP_<%groupIdx%>, arr);
<%}%>

	for (i = 0; i < <%S.m_dimension%>; i++) {
		for (j = 0; j < <%S.m_dimension%>; j++) {
			A = <%gpGmvFuncName%>(bv[i], bv[j]);
			dif = M[i * <%S.m_dimension%> + j] - A.get_scalar();
			if ((dif < <%FT.DoubleToString(S, -FT.PrecisionEpsilon())%>) || (dif > <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>)) {
				Console.WriteLine("<%testFuncName%>() test failed for " + BasisVectorNames[i] + " " + BasisVectorNames[j]);
				return 0;
			}
		}
	}
	
	return 1;
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// testFuncName = name of testing function
// gmvName = name of gmv
// targetFuncName = name of function to test
// randomScalarFuncName = name of random generator function
// randomVersorFuncName = name of function for random 'gmv'
// subtractGmvFuncName = name of function for adding two 'gmv'
${CODEBLOCK testParse}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%(4 * S.m_GMV.NbCoordinates)%>;
	<%gmvName%> A, B, C;
	String str;
	
	int i, basisVectorBitmap = -1;

	for (i = 0; i < NB_LOOPS; i++) {
		A = <%randomVersorFuncName%>(<%randomScalarFuncName%>(), (int)(<%randomScalarFuncName%>() * <%FT.DoubleToString(S, S.m_dimension + 0.5)%>), basisVectorBitmap);
		
		str = A.ToString("E20");
		
		try {
			B = <%targetFuncName%>(str);
		} catch (ParseException ex) {
			Console.WriteLine("<%targetFuncName%>() test failed: " + ex.ToString());
			return 0; // failure
		}

		C = <%subtractGmvFuncName%>(A, B);

		if (C.LargestCoordinate() > <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed (largest coordinate: " + C.LargestCoordinate() + ")");
			return 0; // failure
		}
	}
	
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// testAdd = whether addition (true) or subtraction (false) is being tested
// testFuncName = name of testing function
// gmv = gmv type
// gmvName = name of gmv
// targetFuncName = name of function to test
// randomScalarFuncName = name of random generator function
// randomGmvFuncName = name of function for random 'gmv'
// negateGmvFuncName = name of negation of a GMVs
${CODEBLOCK testAddSubtractGMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%S.m_GMV.NbCoordinates%>;
	<%gmvName%> A, B, C;
	int i, g;
	<%FT.type%> s;
	int basisVectorBitmap = -1;
	
	for (i = 0; i < NB_LOOPS; i++) {
		s = <%randomScalarFuncName%>();
		g = (int)(<%randomScalarFuncName%>() * <%FT.DoubleToString(S, S.m_dimension + 0.5)%>);
		A = <%randomGmvFuncName%>(s, g, basisVectorBitmap);
		
<%if (testAdd) { %>
		// B = -A
		B = <%negateGmvFuncName%>(A);
<%} else {%>
		B = A;
<%}%>
		
		C = <%targetFuncName%>(A, B);
		
		// check
		if (C.LargestCoordinate() > <%FT.DoubleToString(S, 10.0 * FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed");
			return 0; // failure
		}
		
	}
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// testFuncName = name of testing function
// smv1 = smv1 type
// smv2 = smv2 type
// smv1Name = name of smv1
// smv2Name = name of smv2
// smvRName = name of return type smv
// gmvName = name of gmv
// targetFuncName = name of function to test
// randomScalarFuncName = name of random generator function
// randomSmv1FuncName = name of function for random 'smv1'
// randomSmv2FuncName = name of function for random 'smv2'
// addOrSubtractGmvFuncName = name of addition or subtraction of two GMVs (which on depends on the target function)
// subtractGmvFuncName = name of subtraction of two GMVs
${CODEBLOCK testAddSubtractSMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%(smv1.NbCoordinates + smv2.NbCoordinates)%>;
	<%smv1Name%> A;
	<%smv2Name%> B;
	<%smvRName%> C;
	<%gmvName%> gA, gB, gC1, gC2;
	
	<%FT.type%> s;
	int i;
	
	for (i = 0; i < NB_LOOPS; i++) {
		s = <%randomScalarFuncName%>();
		A = <%randomSmv1FuncName%>(s);
		B = <%randomSmv2FuncName%>(s);
		
		// add/subtract A and B
		
		C = <%targetFuncName%>(A, B);
		gC1 = new <%gmvName%>(C);
		
		// convert all A and B to gmv and add/subtract as GMVs
		gA = new <%gmvName%>(A);
		gB = new <%gmvName%>(B);
		gC2 = <%addOrSubtractGmvFuncName%>(gA, gB);
		
		// see if result is equal up to precision:
		gA = <%subtractGmvFuncName%>(gC1, gC2);
		if (gA.LargestCoordinate() > <%FT.DoubleToString(S, 10.0 * FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed");
			return 0; // failure
		}		
	}
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// gmvName = name of gmv
// targetFuncName = name of function to test
// testFuncName = name of testing function
// randomScalarFuncName = name of random generator function
// randomVersorFuncName = name of function for random 'gmv'
// gradeGmvFuncName = name of function for taking a grade part of a 'gmv'
// inverseGroupBitmap = bitmap argument for  'gradeGmvFuncName', the inverse of the gradeX
// addGmvFuncName = name of function for adding two 'gmv'
// subtractGmvFuncName = name of function for adding two 'gmv'
${CODEBLOCK testGradeXGMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%S.m_GMV.NbCoordinates%>;
	<%gmvName%> A, B, C, D;
	int i;
	int basisVectorBitmap = -1;
	
	for (i = 0; i < NB_LOOPS; i++) {
		// get random versor
		A = <%randomVersorFuncName%>(<%randomScalarFuncName%>(), (int)(<%randomScalarFuncName%>() * <%FT.DoubleToString(S, S.m_dimension + 0.5)%>), basisVectorBitmap);
		
		B = <%targetFuncName%>(A);
		
		C = <%gradeGmvFuncName%>(A, <%inverseGroupBitmap%>);
		
		// sum all into 'B'
		D = <%addGmvFuncName%>(B, C);

		// check if equal to original:
		C = <%subtractGmvFuncName%>(A, D);
		if (C.LargestCoordinate() > <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed");
			return 0; // failure
		}
	}
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// gmvName = name of gmv
// targetFuncName = name of function to test
// testFuncName = name of testing function
// randomScalarFuncName = name of random generator function
// randomVersorFuncName = name of function for random 'gmv'
// addGmvFuncName = name of function for adding two 'gmv'
// subtractGmvFuncName = name of function for adding two 'gmv'
${CODEBLOCK testGradeGMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%S.m_GMV.NbCoordinates%>;
	<%gmvName%> A, B, C<%for (int i = 0; i < S.m_GMV.NbGroups; i++) {%>, G<%i%><%}%>;
	int i;
	int basisVectorBitmap = -1;
	
	for (i = 0; i < NB_LOOPS; i++) {
		// get random versor
		A = <%randomVersorFuncName%>(<%randomScalarFuncName%>(), (int)(<%randomScalarFuncName%>() * <%FT.DoubleToString(S, S.m_dimension + 0.5)%>), basisVectorBitmap);
		// split it up into groups/grades:
<%for (int i = 0; i < S.m_GMV.NbGroups; i++) {%>
		G<%i%> = <%targetFuncName%>(A, GroupBitmap.GROUP_<%i%>);
<%}%>
		// sum all into 'B'
		B = new <%gmvName%>();
<%for (int i = 0; i < S.m_GMV.NbGroups; i++) {%>
		B = <%addGmvFuncName%>(B, G<%i%>);
<%}%>

		// check if equal to original:
		C = <%subtractGmvFuncName%>(A, B);
		if (C.LargestCoordinate() > <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed (largestCoordinate = " + (double)C.LargestCoordinate() + ")");
			return 0; // failure
		}
	}
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// gmvName = name of gmv
// smv = smv type
// smvName = smv type
// smvRName = return smv type
// targetFuncName = name of function to test
// testFuncName = name of testing function
// randomScalarFuncName = name of random generator function
// randomSmvFuncName = name of function for random 'smv'
// gradeGmvFuncName = name of function for taking a grade part of a 'gmv'
// groupBitmap = bitmap argument for  'gradeGmvFuncName', the inverse of the gradeX
// inverseGroupBitmap = bitmap argument for  'gradeGmvFuncName', the inverse of the gradeX (not used anymore)
// addGmvFuncName = name of function for adding two 'gmv'
// subtractGmvFuncName = name of function for subtracting two 'gmv'
${CODEBLOCK testGradeXSMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%(1 + smv.NbCoordinates)%>;
	<%smvName%> A;
	<%gmvName%> gA, gB, gC, gD;
	
	int i;
	
	for (i = 0; i < NB_LOOPS; i++) {
		// get random versor
		A = <%randomSmvFuncName%>(<%randomScalarFuncName%>());
		
		gB = new <%gmvName%>(<%targetFuncName%>(A));

		gA = new <%gmvName%>(A);
		gC = <%gradeGmvFuncName%>(gA, <%groupBitmap%>);
		
		// check if equal to original:
		gD = <%subtractGmvFuncName%>(gB, gC);
		if (gD.LargestCoordinate() > <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed");
			return 0; // failure
		}
	}
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// testFuncName = name of testing function
// randomScalarFuncName = name of function returning random float
${CODEBLOCK testRandomScalar}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_BINS = 256;
	int NB_LOOPS = NB_BINS * 1024;
	int[] bins = new int[256];
	<%FT.type%> avg = <%FT.DoubleToString(S, 0.0)%>;
	<%FT.type%> r;
	int idx, i;
	
	// generate a lot of random values, compute average (should be 0.5) and fill bins
	for (i = 0; i < NB_LOOPS; i++) {
		r = <%randomScalarFuncName%>();
		avg += r;
		idx = (int)(r * (<%FT.type%>)NB_BINS);
		if (idx >= NB_BINS) idx = NB_BINS-1;
		bins[idx]++;
	}
	avg /= (<%FT.type%>)NB_LOOPS;
	
	if ((avg < <%FT.DoubleToString(S, 0.49)%>) || (avg > <%FT.DoubleToString(S, 0.51)%>)) {
		Console.WriteLine("Random number generator <%randomScalarFuncName%>() likely failed: average is " + (double)avg + " instead of 0.5.");
		return 0; // failure
	}
	
	for (i = 0; i < NB_BINS; i++) {
		if ((bins[i] < (6 * NB_LOOPS / NB_BINS / 8)) ||
			(bins[i] > (10 * NB_LOOPS / NB_BINS / 8))) {
			Console.WriteLine("It is very likely that the random number generator <%randomScalarFuncName%>() failed:");
			Console.WriteLine("The distribution is not uniform (bin " + i + " of " + NB_BINS + ", value=" + bins[i] + ", expected value=" + (NB_LOOPS / NB_BINS) + ")");
			return 0; // failure
		}
	}
	
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// gmv = gmv type
// gmvName = name of gmv
// targetFuncName = name of function to test
// testFuncName = name of testing function
// randomScalarFuncName = name of random generator function
// randomVersorFuncName = name of function for random blade
// extractGradeFuncName = name of extract grade function
// nbEntries = number of entries in signArray
// signArray = array of 1, -1, 1, -1 which describes the behaviour of targetFuncName
${CODEBLOCK testToggleSignGMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%gmv.NbCoordinates%>;
	<%gmvName%> A, B, GA, GB;
	int i, c, n, g;
	int basisVectorBitmap = -1;
	<%FT.type%> s, dif;
	int[] signTable = new int[]{<%signArray%>};
	
	for (i = 0; i < NB_LOOPS; i++) {
		// get random blade
		s = <%randomScalarFuncName%>();
		g = (int)(<%randomScalarFuncName%>() * <%FT.DoubleToString(S, S.m_dimension + 0.5)%>);
		A = <%randomVersorFuncName%>(s, g, basisVectorBitmap);

		// apply function
		B = <%targetFuncName%>(A);
		
		// check grade
		for (n = 0; n <= <%S.m_dimension%>; n++) {
			GA = <%extractGradeFuncName%>(A, Grades[n]);
			GB = <%extractGradeFuncName%>(B, Grades[n]);
			
			// check if grade usage matches
			if (GA.gu() != GB.gu()) {
				Console.WriteLine("<%targetFuncName%>() test failed (grade usage does not match)");
				return 0; // failure
			}
			
			// check each coordinate 
			for (c = 0; c < MvSize[(int)GA.gu()]; c++) {
				dif = (<%FT.type%>)Math.Abs(GA.m_c[n][c] * (<%FT.type%>)signTable[n] - GB.m_c[n][c]);
				if (dif > <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
					Console.WriteLine("<%targetFuncName%>() test failed (dif = " + dif + ")");
					return 0; // failure
				}
			}
		}
		
	}
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// gmvName = name of gmv
// targetFuncName = name of function to test
// targetFuncReturnsFloat = true when target function returns result as a float 
// testFuncName = name of testing function
// smv = name of SMV type
// smvName = name of SMV type
// resultSmvName = name of GMV type
// randomScalarFuncName = name of random generator function
// randomSmvFuncName = name of function for random 'smv' blade
// subtractGmvFuncName = name of function for subtracting two 'gmv's
// gmvToggleSignFuncName = name of function for 'targetFuncName' two 'gmv's
${CODEBLOCK testToggleSignSMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%smv.NbCoordinates%>;
	<%smvName%> A;
	<%gmvName%> gmvA, gmvB, gmvC, dif;
	int i;
	
	for (i = 0; i < NB_LOOPS; i++) {
		// get random Smv
		A = <%randomSmvFuncName%>(<%randomScalarFuncName%>());
		gmvA = new <%gmvName%>(A);
		
		gmvB = new <%gmvName%>(<%targetFuncName%>(A));
		
		// compute via GMV
		gmvC = <%gmvToggleSignFuncName%>(gmvA);
		
		// check if equal:
		dif = <%subtractGmvFuncName%>(gmvC, gmvB);
		if (dif.LargestCoordinate() > <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed (largestCoordinate = " + dif.LargestCoordinate() + ")");
			return 0; // failure
		}
	}
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// testFuncName = name of testing function
// gmv = gmv type
// gmvName = name of gmv
// targetFuncName = name of function to test
// randomScalarFuncName = name of random generator function
// randomGmvFuncName = name of function for random 'gmv'
// addGmvFuncName = name of function for adding two 'gmv'
// subtractGmvFuncName = name of function for adding two 'gmv'
${CODEBLOCK testGpGMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%(4 * S.m_GMV.NbCoordinates)%>;
	<%gmvName%> A, B, C, D, E, V1, V2;
	int i;
	int o;
	int basisVectorBitmap = -1;
	
	for (i = 0; i < NB_LOOPS; i++) {
		o = (<%randomScalarFuncName%>() < <%FT.DoubleToString(S, 0.5)%>) ? 0 : 1; // even or odd?
		A = <%randomGmvFuncName%>(<%randomScalarFuncName%>(), ((int)(<%randomScalarFuncName%>() * <%FT.DoubleToString(S, S.m_dimension + 0.5)%>) & 0xFFFE) + o, basisVectorBitmap);
		B = <%randomGmvFuncName%>(<%randomScalarFuncName%>(), ((int)(<%randomScalarFuncName%>() * <%FT.DoubleToString(S, S.m_dimension + 0.5)%>) & 0xFFFE) + o, basisVectorBitmap);
		C = <%randomGmvFuncName%>(<%randomScalarFuncName%>(), ((int)(<%randomScalarFuncName%>() * <%FT.DoubleToString(S, S.m_dimension + 0.5)%>) & 0xFFFE) + o, basisVectorBitmap);
		
		{ // test (A+B) C = A C + B C
			// D = A + B
			D = <%addGmvFuncName%>(A, B);
			// V1 = D C
			V1 = <%targetFuncName%>(D, C);
			// D = A C
			D = <%targetFuncName%>(A, C);
			// E = B C
			E = <%targetFuncName%>(B, C);
			// V2 = D + E
			V2 = <%addGmvFuncName%>(D, E);
			// test equality
			D = <%subtractGmvFuncName%>(V1, V2);
			// use <%gmvName%>_largestCoordinate() to verify
			if (D.LargestCoordinate() > <%FT.DoubleToString(S, 1000.0 * FT.PrecisionEpsilon())%>) {
				Console.WriteLine("<%targetFuncName%>() test failed on '(A+B) C = A C + B C' (dif=" + D.LargestCoordinate() + ")");
				return 0; // failure
			}
		}
		
		{ // test A (B+C) = A B + A C
			// D = B + C
			D = <%addGmvFuncName%>(B, C);
			// V1 = A D
			V1 = <%targetFuncName%>(A, D);
			// D = A B
			D = <%targetFuncName%>(A, B);
			// E = A C
			E = <%targetFuncName%>(A, C);
			// V2 = D + E
			V2 = <%addGmvFuncName%>(D, E);
			// test equality
			D = <%subtractGmvFuncName%>(V1, V2);
			// use largestCoordinate() to verify
			if (D.LargestCoordinate() > <%FT.DoubleToString(S, 100.0 * FT.PrecisionEpsilon())%>) {
				Console.WriteLine("<%targetFuncName%>() test failed on 'A (B+C) = A B + A C' (dif=" + D.LargestCoordinate() + ")");
				return 0; // failure
			}
		}
		
		{ // test A (B C) = (A B) C
			// D = B C
			D = <%targetFuncName%>(B, C);
			// V1 = A D
			V1 = <%targetFuncName%>(A, D);
			// D = A B
			D = <%targetFuncName%>(A, B);
			// V2 = D C
			V2 = <%targetFuncName%>(D, C);
			// test equality
			D = <%subtractGmvFuncName%>(V1, V2);
			// use largestCoordinate() to verify
			if (D.LargestCoordinate() > <%FT.DoubleToString(S, 100.0 * FT.PrecisionEpsilon())%>) {
				Console.WriteLine("<%targetFuncName%>() test failed on 'A (B C) = (A B) C' (dif=" + D.LargestCoordinate() + ")");
				return 0; // failure
			}
		}		
	}
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// testFuncName = name of testing function
// smv1 = smv1 type
// smv2 = smv2 type
// smv1Name = name of smv1
// smv2Name = name of smv2
// smvRName = name of return type smv
// gmvName = name of gmv
// targetFuncName = name of function to test
// randomScalarFuncName = name of random generator function
// randomSmv1FuncName = name of function for random 'smv1'
// randomSmv2FuncName = name of function for random 'smv2'
// gpGmvFuncName = name of gp func of two GMVs (which on depends on the target function)
// subtractGmvFuncName = name of subtraction of two GMVs
${CODEBLOCK testGpSMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%(smv1.NbCoordinates + smv2.NbCoordinates)%>;
	<%smv1Name%> A;
	<%smv2Name%> B;
	<%smvRName%> C;
	<%gmvName%> gA, gB, gC1, gC2;
	
	<%FT.type%> s;
	int i;
	
	for (i = 0; i < NB_LOOPS; i++) {
		s = <%randomScalarFuncName%>();
		A = <%randomSmv1FuncName%>(s);
		B = <%randomSmv2FuncName%>(s);
		
		// A gp B
		C = <%targetFuncName%>(A, B);
		gC1 = new <%gmvName%>(C);
		
		// convert all A and B to gmv and add/subtract as GMVs
		gA = new <%gmvName%>(A);
		gB = new <%gmvName%>(B);
		gC2 = <%gpGmvFuncName%>(gA, gB);
		
		// see if result is equal up to precision:
		gA = <%subtractGmvFuncName%>(gC1, gC2);
		if (gA.LargestCoordinate() > <%FT.DoubleToString(S, 10.0 * FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed (largestCoordinate = " + gA.LargestCoordinate() + ")");
			return 0; // failure
		}		
	}
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// gmvName = name of gmv
// targetFuncName = name of function to test
// testFuncName = name of testing function
// randomScalarFuncName = name of random generator function
// randomVersorFuncName = name of function for random 'gmv' blade
// subtractFuncName = name of function for subtraction of two 'gmv'
// gpFuncName = name of function for geometric product of two 'gmv'
// versorInverseFuncName = name of function for versor inverse of 'gmv'
${CODEBLOCK testIGP_GMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%S.m_GMV.NbCoordinates%>;
	<%gmvName%> A, B, IB, C, D, E;
	int i;
	int basisVectorBitmap = -1;

	for (i = 0; i < NB_LOOPS; i++) {
		// get two random versors
		A = <%randomVersorFuncName%>(<%randomScalarFuncName%>() + <%FT.DoubleToString(S, 0.5)%>, (int)(<%randomScalarFuncName%>() * <%FT.DoubleToString(S, S.m_dimension + 0.5)%>), basisVectorBitmap);
		B = <%randomVersorFuncName%>(<%randomScalarFuncName%>() + <%FT.DoubleToString(S, 0.5)%>, (int)(<%randomScalarFuncName%>() * <%FT.DoubleToString(S, S.m_dimension + 0.5)%>), basisVectorBitmap);
		
		C = <%targetFuncName%>(A, B);
		
		// get versor inverse of B, compute A * versorInverse(B)
		IB = <%versorInverseFuncName%>(B);
		D = <%gpFuncName%>(A, IB);
		
		E = <%subtractFuncName%>(C, D);
		
		if (E.LargestCoordinate() > <%FT.DoubleToString(S, 1000.0 * FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed (largestCoordinate of E = " + E.LargestCoordinate() + ")");
			return 0; // failure
		}
	}
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// testFuncName = name of testing function
// smv1 = smv1 type
// smv2 = smv2 type
// smv1Name = name of smv1
// smv2Name = name of smv2
// smvRName = name of return type smv
// gmvName = name of gmv
// targetFuncName = name of function to test
// randomScalarFuncName = name of random generator function
// randomSmv1FuncName = name of function for random 'smv1'
// randomSmv2FuncName = name of function for random 'smv2'
// subtractGmvFuncName = name of subtraction of two GMVs
// gpFuncName = name of function for geometric product of two 'gmv'
// versorInverseFuncName = name of function for versor inverse of 'gmv'
${CODEBLOCK testIGP_SMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%smv1.NbCoordinates%>;
	<%smv1Name%> A;
	<%smv2Name%> B;
	<%smvRName%> C;
	<%gmvName%> gA, gB, gC, IB, D, E;
	
	int i;
	
	for (i = 0; i < NB_LOOPS; i++) {
		A = <%randomSmv1FuncName%>(<%FT.DoubleToString(S, 1.0)%>);
		B = <%randomSmv2FuncName%>(<%FT.DoubleToString(S, 1.0)%>);
		
		// apply IGP
		C = <%targetFuncName%>(A, B);
		
		// convert A, B, C to GMV
		gA = new <%gmvName%>(A);
		gB = new <%gmvName%>(B);
		gC = new <%gmvName%>(C);
		
		// get versor inverse of B, compute A * versorInverse(B)
		IB = <%versorInverseFuncName%>(gB);
		D = <%gpFuncName%>(gA, IB);
		
		E = <%subtractFuncName%>(gC, D);
		
		if (E.LargestCoordinate() > <%FT.DoubleToString(S, 1000.0 * FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed (largestCoordinate of E = " + (double)E.LargestCoordinate() + ")");
			return 0; // failure
		}
	}
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// testFuncName = name of testing function
// targetFuncName = name of function to test
// gmv = gmv type
// gmvName = name of gmv
// productName = name of product to be tested (op, mhip, hip, lc, rc, sp)
// randomScalarFuncName = name of random generator function
// randomBladeFuncName = name of function for random 'gmv'
// gpGmvFuncName = name of geometric product of a GMVs
// extractGradeFuncName = name of function to extract a grade part from a GMV
// subtractGmvFuncName = name of function for subtracting two 'gmv'
${CODEBLOCK testFilteredGpGMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%gmv.NbCoordinates%>;
	<%gmvName%> A, B, C, D, E, dif;
	int i, ga, gb, gd;
	<%FT.type%> s;
	int basisVectorBitmap = -1;
	
	for (i = 0; i < NB_LOOPS; i++) {
		s = <%randomScalarFuncName%>();
		ga = (int)(<%randomScalarFuncName%>() * <%FT.DoubleToString(S, S.m_dimension + 0.5)%>);
		A = <%randomBladeFuncName%>(s, ga, basisVectorBitmap);
		
		s = <%randomScalarFuncName%>();
		gb = (int)(<%randomScalarFuncName%>() * <%FT.DoubleToString(S, S.m_dimension + 0.5)%>);
		B = <%randomBladeFuncName%>(s, gb, basisVectorBitmap);
		
		// compute product using <%targetFuncName%>()
		C = new <%gmvName%>(<%targetFuncName%>(A, B));
		
		// simulate product using geometric product & grade part selection
		D = <%gpGmvFuncName%>(A, B);
		gd = (ga > gb) ? ga - gb : gb - ga;
<%if (productName.Equals("op")) {%>
		E = <%extractGradeFuncName%>(D,  Grades[ga + gb]);
<%} else if (productName.Equals("hip")) {%>
		if ((ga == 0) || (gb == 0)) E = new <%gmvName%>(<%FT.DoubleToString(S, 0.0)%>);
		else E = <%extractGradeFuncName%>(D, Grades[gd]);
<%} else if (productName.Equals("mhip")) {%>
		E = <%extractGradeFuncName%>(D, Grades[gd]);
<%} else if (productName.Equals("lc")) {%>
		if (ga > gb) E = new <%gmvName%>(<%FT.DoubleToString(S, 0.0)%>);
		else E = <%extractGradeFuncName%>(D, Grades[gd]);
<%} else if (productName.Equals("rc")) {%>
		if (ga < gb) E = new <%gmvName%>(<%FT.DoubleToString(S, 0.0)%>);
		else E = <%extractGradeFuncName%>(D, Grades[gd]);
<%} else if (productName.Equals("sp")) {%>
		E = <%extractGradeFuncName%>(D, Grades[0]);
<%}%>

		// check if equal:
		dif = <%subtractGmvFuncName%>(C, E);
		if (dif.LargestCoordinate() > <%FT.DoubleToString(S, 100.0 * FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed (largestCoordinate = " + (double)dif.LargestCoordinate() + ")");
			return 0; // failure
		}
	}
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// testFuncName = name of testing function
// targetFuncName = name of function to test
// gmv = gmv type
// gmvName = name of gmv
// smv1
// smv1Name = name of smv1
// smv2Name = name of smv2
// productName = name of product to be tested (op, mhip, hip, lc, rc, sp)
// randomSmv1FuncName = name of function for random 'smv1'
// randomSmv2FuncName = name of function for random 'smv2'
// gmvProductFuncName = name of geometric product of a GMVs
// subtractGmvFuncName = name of function for subtracting two 'gmv'
${CODEBLOCK testFilteredGpSMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%smv1.NbCoordinates%>;
	<%smv1Name%> A;
	<%smv2Name%> B;
<%if (!targetFuncReturnsFloat) {%>
//	<%resultSmvName%> C;
<%}%>	

	<%gmvName%> gmvA, gmvB, gmvC, gmvD, dif;
	int i;
	
	for (i = 0; i < NB_LOOPS; i++) {
		A = <%randomSmv1FuncName%>(<%FT.DoubleToString(S, 1.0)%>);
		B = <%randomSmv2FuncName%>(<%FT.DoubleToString(S, 1.0)%>);
		
		// convert smv to GMV
		gmvA = new <%gmvName%>(A);
		gmvB = new <%gmvName%>(B);
				
		// compute product using <%targetFuncName%>()
		gmvC = new <%gmvName%>(<%targetFuncName%>(A, B));
		
		// perform GMV version 
		gmvD = new <%gmvName%>(<%gmvProductFuncName%>(gmvA, gmvB));

		// check if equal:
		dif = <%subtractGmvFuncName%>(gmvC, gmvD);
		if (dif.LargestCoordinate() > <%FT.DoubleToString(S, 100.0 * FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed (largestCoordinate = " + (double)dif.LargestCoordinate() + ")");
			return 0; // failure
		}
	}
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// testFuncName = name of testing function
// targetFuncName = name of function to test
// gmv = gmv type
// gmvName = name of gmv
// randomScalarFuncName = name of random generator function
// randomBladeFuncName = name of function for random 'gmv'
${CODEBLOCK testOpGMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%gmv.NbCoordinates%>;
	<%gmvName%> A, B;
	int i, ga;
	<%FT.type%> s;
	int basisVectorBitmap = -1;
	
	for (i = 0; i < NB_LOOPS; i++) {
		s = <%randomScalarFuncName%>();
		ga = (int)(<%randomScalarFuncName%>() * <%FT.DoubleToString(S, S.m_dimension + 0.5)%>);
		if (ga == 0) continue; // do not perform this test for grade 0
		A = <%randomBladeFuncName%>(s, ga, basisVectorBitmap);
		
		// compute A ^ A (should be zero)
		B = <%targetFuncName%>(A, A);
		
		// check if B is zero:
		if (B.LargestCoordinate() > <%FT.DoubleToString(S, 10.0 * FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed (largestCoordinate = " + (double)B.LargestCoordinate() + ")");
			return 0; // failure
		}
	}
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// gmv = gmv type
// gmvName = name of gmv
// returnTypeName = name of return type of targetFuncName
// targetFuncName = name of function to test
// targetFuncReturnsFloat = true when target function returns result as a float 
// normSquared = true when norm squared is computed
// testFuncName = name of testing function
// randomScalarFuncName = name of random generator function
// randomBladeFuncName = name of function for random blade
// reverseFuncName = name of function for subtracting two 'gmv'
// gpFuncName = name of function for subtracting two 'gmv'
${CODEBLOCK testNormGMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%gmv.NbCoordinates%>;
	<%gmvName%> A, reverseA, tmp;
<%if (!targetFuncReturnsFloat) {%>
	<%returnTypeName%> tmpScalar;
<%}%>	
	int i, g;
	int basisVectorBitmap = -1;
	<%FT.type%> s;
	<%FT.type%> n1, n2;
	
	for (i = 0; i < NB_LOOPS; i++) {
		// get random blade
		s = <%randomScalarFuncName%>();
		g = (int)(<%randomScalarFuncName%>() * <%FT.DoubleToString(S, S.m_dimension + 0.5)%>);
		A = <%randomBladeFuncName%>(s, g, basisVectorBitmap);
		
		// compute norm
<%if (targetFuncReturnsFloat) {%>
		n1 = <%targetFuncName%>(A);
<%} else  {%>
		tmpScalar = <%targetFuncName%>(A);
		n1 = tmpScalar.get_scalar();
<%}%>
		
		// compute norm manually (A . reverse(A))
		reverseA = <%reverseFuncName%>(A);
		tmp = <%gpFuncName%>(A, reverseA);
		n2 = tmp.get_scalar();
<%if (!normSquared) {%>
		n2 = (<%FT.type%>)Math.Sqrt(Math.Abs(n2));
<%}%>
		
		// check if equal to original:
		if (Math.Abs(n1 - n2) > <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed (difference = " + (double)Math.Abs(n1 - n2) + ")");
			return 0; // failure
		}
	}
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// gmvName = name of gmv
// targetFuncName = name of function to test
// targetFuncReturnsFloat = true when target function returns result as a float 
// normSquared = true when norm squared is computed
// testFuncName = name of testing function
// smv = name of SMV type
// smvName = name of SMV type
// resultSmvName = name of GMV type
// randomScalarFuncName = name of random generator function
// randomSmvFuncName = name of function for random 'smv' blade
// undualFuncName = name of function for computing undual of 'gmv'
// subtractGmvFuncName = name of function for subtracting two 'gmv'
${CODEBLOCK testNormSMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%smv.NbCoordinates%>;
	<%smvName%> A;
<%if (!targetFuncReturnsFloat) {%>
	<%resultSmvName%> B;
<%}%>
	<%gmvName%> gmvA, reverseA, tmp;
	
	int i;
	<%FT.type%> n1, n2;
	
	for (i = 0; i < NB_LOOPS; i++) {
		// get random blade
		A = <%randomSmvFuncName%>(<%randomScalarFuncName%>());
		
		gmvA = new <%gmvName%>(A);
		
<%if (targetFuncReturnsFloat) {%>
		n1 = <%targetFuncName%>(A);
<%} else  {%>
		B = <%targetFuncName%>(A);
		n1 = B.get_scalar();
<%}%>
		
		// compute norm manually (A . reverse(A))
		reverseA = <%reverseFuncName%>(gmvA);
		tmp = <%gpFuncName%>(gmvA, reverseA);
		n2 = tmp.get_scalar();
<%if (!normSquared) {%>
		n2 = (<%FT.type%>)Math.Sqrt(Math.Abs(n2));
<%}%>
		
		// check if equal to original:
		if (Math.Abs(n1 - n2) > <%FT.DoubleToString(S, 10.0 * FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed (difference = " + (double)Math.Abs(n1 - n2) + ")");
			return 0; // failure
		}
	}
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// gmvName = name of gmv
// targetFuncName = name of function to test
// testFuncName = name of testing function
// randomScalarFuncName = name of random generator function
// randomBladeFuncName = name of function for random 'gmv'
// undualFuncName = name of function for computing undual of 'gmv'
// subtractGmvFuncName = name of function for subtracting two 'gmv'
${CODEBLOCK testDualGMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%S.m_GMV.NbCoordinates%>;
	<%gmvName%> A, B, C, dif;
	int i;
	int basisVectorBitmap = -1;
	
	for (i = 0; i < NB_LOOPS; i++) {
		// get random blade
		A = <%randomBladeFuncName%>(<%randomScalarFuncName%>(), (int)(<%randomScalarFuncName%>() * <%FT.DoubleToString(S, S.m_dimension + 0.5)%>), basisVectorBitmap);
		
		B = <%targetFuncName%>(A);
		
		C = <%undualFuncName%>(B);
		
		// check if equal to original:
		dif = <%subtractGmvFuncName%>(A, C);
		if (dif.LargestCoordinate() > <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed (largestCoordinate = " + (double)dif.LargestCoordinate() + ")");
			return 0; // failure
		}
	}
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// gmvName = name of gmv
// targetFuncName = name of function to test
// testFuncName = name of testing function
// smv = name of SMV type
// smvName = name of SMV type
// resultSmvName = name of GMV type
// randomScalarFuncName = name of random generator function
// randomSmvFuncName = name of function for random 'smv' blade
// undualFuncName = name of function for computing undual of 'gmv'
// subtractGmvFuncName = name of function for subtracting two 'gmv'
${CODEBLOCK testDualSMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%smv.NbCoordinates%>;
	<%smvName%> A;
	<%resultSmvName%> B;
	<%gmvName%> gmvA, gmvB, C, dif;
	int i;
	
	for (i = 0; i < NB_LOOPS; i++) {
		// get random blade
		A = <%randomSmvFuncName%>(<%randomScalarFuncName%>());
		gmvA = new <%gmvName%>(A);
		
		B = <%targetFuncName%>(A);
		gmvB = new <%gmvName%>(B);
		
		C = <%undualFuncName%>(gmvB);
		
		// check if equal to original:
		dif = <%subtractGmvFuncName%>(gmvA, C);
		if (dif.LargestCoordinate() > <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed (largestCoordinate = " + (double)dif.LargestCoordinate() + ")");
			return 0; // failure
		}
	}
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// gmvName = name of gmv
// targetFuncName = name of function to test
// testFuncName = name of testing function
// randomScalarFuncName = name of random generator function
// randomBladeFuncName = name of function for random 'gmv' blade
// reverseFuncName = name of function for reverse of 'gmv'
// spFuncName = name of function for scalar product of two 'gmv'
${CODEBLOCK testUnitGMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%S.m_GMV.NbCoordinates%>;
	<%gmvName%> A, UA, RUA;
	int i;
	int basisVectorBitmap = -1;
	<%FT.type%> n;
	
	for (i = 0; i < NB_LOOPS; i++) {
		// get random blade
		A = <%randomBladeFuncName%>(<%randomScalarFuncName%>(), (int)(<%randomScalarFuncName%>() * <%FT.DoubleToString(S, S.m_dimension + 0.5)%>), basisVectorBitmap);
		
		UA = <%targetFuncName%>(A);
		RUA = <%reverseFuncName%>(UA);
		n = <%spFuncName%>(RUA, UA);
		
		if ((<%FT.type%>)(Math.Abs(n) - <%FT.DoubleToString(S, 1.0)%>) > <%FT.DoubleToString(S, 100.0 * FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed (|norm|-1 = " + (double)(Math.Abs((double)n) - 1.0) + ")");
			return 0; // failure
		}

	}
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// gmvName = name of gmv
// targetFuncName = name of function to test
// testFuncName = name of testing function
// smv = name of SMV type
// smvName = name of SMV type
// resultSmvName = name of SMV type returned by targetFuncName
// randomSmvFuncName = name of function for random 'smv' blade
// randomScalarFuncName = name of random generator function
// reverseFuncName = name of function for reverse of 'gmv'
// spFuncName = name of function for scalar product of two 'gmv'
${CODEBLOCK testUnitSMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%S.m_GMV.NbCoordinates%>;
	<%smvName%> A;
	<%resultSmvName%> UA;
	<%gmvName%> gmvUA, RUA;
	int i;
	<%FT.type%> n;
	
	for (i = 0; i < NB_LOOPS; i++) {
		A = <%randomSmvFuncName%>(<%randomScalarFuncName%>());
		
		UA = <%targetFuncName%>(A);
		
		gmvUA = new <%gmvName%>(UA);
		
		RUA = <%reverseFuncName%>(gmvUA);
		n = <%spFuncName%>(RUA, gmvUA);
		
		if ((<%FT.type%>)(Math.Abs(n) - <%FT.DoubleToString(S, 1.0)%>) > <%FT.DoubleToString(S, 100.0 * FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed (|norm|-1 = %e)\n", (double)(Math.Abs((double)n) - 1.0));
			return 0; // failure
		}

	}
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// testFuncName = name of testing function
// targetFuncName = name of function to test
// gmv = GMV type
// gmvName = name of GMV type
// unit = whether versor should be unit
// explicitInverse = whether explicit inverse should be used
// randomScalarFuncName = name of random generator function
// randomVersorFuncName = name of function for random versor
// randomBladeFuncName = name of function for random blade
// unitVersorFuncName = name of function for unit versor
// innerProductFuncName = name of modified hestenes inner product function
// subtractGmvFuncName = name of subtraction of two GMVs
// basisVectorBitmap = bitmap of basisvectors that may be used to generate random versors.
${CODEBLOCK testApplyVersor_GMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) {
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%gmv.NbCoordinates%>;
	<%FT.type%> baseScale = <%FT.DoubleToString(S, 0.5)%>;
	int g, i;
	<%FT.type%> s;
	<%gmvName%> V, IV, X, Y, VX, VY, IVVX, XdY, VXdVY, dif;
<%if (unit) {%>
	<%gmvName%> tmp;
<%}%>
	int versorBasisVectorBitmap = <%basisVectorBitmap%>; // note: random versors restricted to Euclidean basis vectors.
	int bladeBasisVectorBitmap = -1;
	
	for (i = 0; i < NB_LOOPS; i++) {
		// get random versor and its inverse. Optionally make versor unit.
		s = baseScale + <%randomScalarFuncName%>();
		g = (int)(<%randomScalarFuncName%>() * <%FT.DoubleToString(S, S.m_dimension + 0.5)%>);
		V = <%randomVersorFuncName%>(s, g, versorBasisVectorBitmap);
		
		// avoid 'near'-singular versors
		if (V.LargestCoordinate() > <%FT.DoubleToString(S, 2.0)%>)
			continue;		
		
<%if (unit) {%>
		tmp = <%unitVersorFuncName%>(V);
		V = tmp;
<%}%>
		IV = <%inverseVersorFuncName%>(V);

		// get two random blades		
		s = baseScale + <%randomScalarFuncName%>();
		g = (int)(<%randomScalarFuncName%>() * <%FT.DoubleToString(S, S.m_dimension + 0.5)%>);
		X = <%randomBladeFuncName%>(s, g, bladeBasisVectorBitmap);
		s = baseScale + <%randomScalarFuncName%>();
		Y = <%randomBladeFuncName%>(s, g, bladeBasisVectorBitmap);

		// apply versor to blades
		VX = new <%gmvName%>(<%targetFuncName%>(V, X<%if (explicitInverse) {%>, IV<%}%>));
		VY = new <%gmvName%>(<%targetFuncName%>(V, Y<%if (explicitInverse) {%>, IV<%}%>));
		
		// compute inner product
		XdY = <%innerProductFuncName%>(X, Y);
		VXdVY = <%innerProductFuncName%>(VX, VY);
		
		// see if inner products are equal (versor application should not change metric)
		dif = <%subtractGmvFuncName%>(XdY, VXdVY);
		if (dif.LargestCoordinate() > (<%FT.DoubleToString(S, FT.PrecisionEpsilon() * 100.0)%> )) {
			Console.WriteLine("<%targetFuncName%>() test failed (metric test) (largestCoordinate = " + (double)dif.LargestCoordinate() + ")");
			return 0; // failure
		}
		
		// apply inverse transformation to VX
		IVVX = <%targetFuncName%>(IV, VX<%if (explicitInverse) {%>, V<%}%>);
		
		// see if X equals IVVX
		dif = <%subtractGmvFuncName%>(X, IVVX);
		if (dif.LargestCoordinate() > (<%FT.DoubleToString(S, FT.PrecisionEpsilon() * 100.0)%> )) {
			Console.WriteLine("<%targetFuncName%>() test failed (inverse test) (largestCoordinate = " + (double)dif.LargestCoordinate() + ")");
			return 0; // failure
		}
	}
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// testFuncName = name of testing function
// targetFuncName = name of function to test
// gmv = GMV type
// gmvName = name of GMV type
// unit = whether versor should be unit
// explicitInverse = whether explicit inverse should be used

// versorType = type of versor
// versorName = name of versor type
// smvName = name of type that versor is applied to
// transformedSmvName = name of transformed type 
// inverseVersorName = name of inverse type

// randomScalarFuncName = name of random generator function
// randomVersorFunc = name of random versor of type versorName
// randomSmvFunc = name of random versor of type smvName
// unitVersorFuncName = name of unit function for type versorName
// versorInverseFuncName = name of versor inverse for versorName
// applyVersorGmvFuncName = apply versor GMV to subject GMV
// subtractGmvFuncName = subtract two GMVs
// norm2VersorFuncName = name of norm squared function for type versorName
${CODEBLOCK testApplyVersor_SMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) {
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%versorType.NbCoordinates%>;
	<%versorName%> V;
<%if (unit) {%>
	<%versorName%> tmp;
<%}%>
	<%inverseVersorName%> IV;
	<%smvName%> X;
	<%transformedSmvName%> VX, tmpVX2;
	<%gmvName%> gmvV, gmvIV, gmvX, gmvVX, gmvVX2, dif;
	int i;

	for (i = 0; i < NB_LOOPS; i++) {
		// generate random versor of target type, make unit if required, invert
		V = <%randomVersorFunc%>(<%randomScalarFuncName%>());
		
<%if (unit) {%>
		// Test if norm2(V) is positive, otherwise do not perform the test.
		// (because with a negative norm2(v), the reverse is not the inverse)
		if (<%norm2VersorFuncName%>(V) <= <%FT.DoubleToString(S, 0.0)%>) continue;

		tmp = <%unitVersorFuncName%>(V);
		V = tmp;
<%}	%>
		IV = <%versorInverseFuncName%>(V);

		// avoid near-singular versors
		if ((V.LargestCoordinate() > <%FT.DoubleToString(S, 2.0)%>) ||
			(IV.LargestCoordinate() > <%FT.DoubleToString(S, 2.0)%>))
			continue;
		 

		// generate random SMV 
		X = <%randomSmvFunc%>(<%randomScalarFuncName%>());

		//  apply random versor to random SMV, convert to GMV
		VX = <%targetFuncName%>(V, X<%if (explicitInverse) {%>, IV<%}%>);
		gmvVX2 = new <%gmvName%>(VX);

		// convert all to GMV type, apply versor too as GMV
		gmvV = new <%gmvName%>(V);
		gmvIV = new <%gmvName%>(IV);
		gmvX = new <%gmvName%>(X);
		gmvVX = <%applyVersorGmvFuncName%>(gmvV, gmvX);
		
		// convert GMV back and forth to return type to fix possible constant coordinates
		tmpVX2 = new <%transformedSmvName%>(gmvVX);
		gmvVX = new <%gmvName%>(tmpVX2);
		
		// see if VX equals gmvVX
		dif = <%subtractGmvFuncName%>(gmvVX, gmvVX2);
		if (dif.LargestCoordinate() > (<%FT.DoubleToString(S, FT.PrecisionEpsilon() * 100.0)%> )) {
			Console.WriteLine("<%targetFuncName%>() test failed (largest coordinate = " + dif.LargestCoordinate() + ")");
			return 0; // failure
		}
	}

	return 1; // success
}

${ENDCODEBLOCK}

// S = Specification
// FT = float type
// testFuncName = name of testing function
// gmv = gmv type
// gmvName = name of gmv
// targetFuncName = name of function to test
// randomScalarFuncName = name of random generator function
// randomGmvFuncName = name of function for random 'gmv'
// addGmvFuncName = name of addition of two GMVs
${CODEBLOCK testEqualsGMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%S.m_GMV.NbCoordinates%>;
	<%gmvName%> A, B, C;
	<%FT.type%> s, eps = <%FT.DoubleToString(S, 0.2)%>;
	int g, i;
	bool e, l;
	int basisVectorBitmap = -1;
	
	for (i = 0; i < NB_LOOPS; i++) {
		s = <%randomScalarFuncName%>();
		g = (int)(<%randomScalarFuncName%>() * <%FT.DoubleToString(S, S.m_dimension + 0.5)%>);
		A = <%randomGmvFuncName%>(s, g, basisVectorBitmap);
		B = <%randomGmvFuncName%>(<%FT.DoubleToString(S, 1.1)%> * eps, g, basisVectorBitmap);
		C = <%addGmvFuncName%>(B, A);
		
		// check if <%targetFuncName%> thinks A if is equal to itself
		e = <%targetFuncName%>(A, A, eps);
		if (!e) {
			Console.WriteLine("<%targetFuncName%>() failed (variable not equal to itself)\n");
			return 0; // failure
		}
		
		// check if <%targetFuncName%> thinks A if is equal C
		e = <%targetFuncName%>(A, C, eps);
		
		// use <%gmvName%>_largestCoordinate() to verify
		l = !(B.LargestCoordinate() > eps);
		
		if (e != l) {
			Console.WriteLine("<%targetFuncName%>() test failed");
			return 0; // failure
		}
	}
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// testFuncName = name of testing function
// smv1 = smv1 type
// smv2 = smv2 type
// smv1Name = name of smv1
// smv2Name = name of smv2
// gmvName = name of gmv
// targetFuncName = name of function to test
// randomScalarFuncName = name of random generator function
// randomSmv1FuncName = name of function for random 'smv1'
// randomSmv2FuncName = name of function for random 'smv2'
// subtractGmvFuncName = name of subtraction of two GMVs
${CODEBLOCK testEqualsSMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%(smv1.NbCoordinates + smv2.NbCoordinates)%>;
	<%smv1Name%> A;
	<%smv2Name%> B;
	<%gmvName%> gA, gB, gC;
	<%FT.type%> s, eps = <%FT.DoubleToString(S, 0.5)%>; // note the really large epsilon
	int i;
	bool e, l;
<%if (smv1Name == smv2Name) { %>
	bool e1, e2;
<%}%>
	
	for (i = 0; i < NB_LOOPS; i++) {
		s = <%randomScalarFuncName%>();
		A = <%randomSmv1FuncName%>(s);
		B = <%randomSmv2FuncName%>(s);
		
<%if (smv1Name == smv2Name) { %>
		// check if <%targetFuncName%> thinks A if is equal to itself
		e1 = <%targetFuncName%>(A, A, eps);
		e2 = <%targetFuncName%>(B, B, eps);
		if ((!e1) || (!e2)) {
			Console.WriteLine("<%targetFuncName%>() failed (variable not equal to itself)\n");
			return 0; // failure
		}<%}%>
		// convert A and B to gmv
		gA = new <%gmvName%>(A);
		gB = new <%gmvName%>(B);
		
		// gC = gB - gA, get largest coord
		gC = <%subtractGmvFuncName%>(gB, gA);
		// use largestCoordinate() to verify
		l = !(gC.LargestCoordinate() > eps);
		
		// check if <%targetFuncName%> thinks A if is equal B
		e = <%targetFuncName%>(A, B, eps);
		
		if (e != l) {
			Console.WriteLine("<%targetFuncName%>() test failed\n");
			return 0; // failure
		}
	}
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// testFuncName = name of testing function
// targetFuncName = name of function to test
// vectorBased = construct point from Euclidean vector
// coordBased = construct point from coordinates
// random = construct random point
// cgaPointName = name of point type
// cgaPointType = point type
// vectorName = name of vector type (invalid when not vectorBased);
// randomScalarFuncName
// randomVectorFuncName
// spFuncName
${CODEBLOCK testCgaPoint}
static int <%testFuncName%>(int NB_TESTS_SCALER) {
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%cgaPointType.NbCoordinates%>;
<%if (vectorBased && !random) {%>
	<%vectorName%> V;
<%}%>
	<%cgaPointName%> pt;
	<%FT.type%> f;
	int i;

	for (i = 0; i < NB_LOOPS; i++) {
<%if (coordBased) {%>
		pt = <%targetFuncName%>(<%for (int i = 0; i < S.m_dimension-2; i++) {%><%if (i > 0) {%>, <%}%><%randomScalarFuncName%>()<%}%>);
<%} else if (random) {%>
		pt = <%targetFuncName%>(<%randomScalarFuncName%>());
<%} else if (vectorBased) {%>
		V = <%randomVectorFuncName%>(<%randomScalarFuncName%>());
		pt = <%targetFuncName%>(V);
<%}%>
		
		// check if null vector (todo: what if user overrides the scalar product to return an SMV type?)
		f = <%spFuncName%>(pt, pt);
		if ((<%FT.type%>)Math.Abs(f) > <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed\n");
			return 0; // failure
		}
	}

	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// testFuncName = name of testing function
// targetFuncName = name of function to test
// squared = whether distance or distance squared is being computed
// gmvName = name of GMV type
// fabs
// sqrt
// arg1TypeName = type name of function argument 1
// arg2TypeName = type name of function argument 2
// cgaPointName = name of point type return by cgaPoint function
// cgaPointType = point type
// randomScalarFuncName = name of random generator function
// c3gaPointFuncName = name function from coordinates to CGA point
${CODEBLOCK testCgaPointDistance}
static int <%testFuncName%>(int NB_TESTS_SCALER) {
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%cgaPointType.NbCoordinates%>;
	<%FT.type%>[] C1 = new <%FT.type%>[<%S.m_dimension-2%>], C2 = new <%FT.type%>[<%S.m_dimension-2%>];
	<%cgaPointName%> pt1, pt2;
	<%arg1TypeName%> argPt1;
	<%arg2TypeName%> argPt2;
	<%FT.type%> d1, d2, dif;
	int i, j;
	<%gmvName%> tmp;
	
	for (i = 0; i < NB_LOOPS; i++) {
		// get random coordinate for point, and compute distance 'd1' of points
		d1 = <%FT.DoubleToString(S, 0.0)%>;
		for (j = 0; j < <%S.m_dimension-2%>; j++) {
			C1[j] = <%randomScalarFuncName%>();
			C2[j] = <%randomScalarFuncName%>();
			d1 += (C1[j] - C2[j]) * (C1[j] - C2[j]);
		}
<%if (!squared) {%>
		d1 = <%sqrt%>(d1);
<%}%>
		
		// initialize points
		pt1 = <%c3gaPointFuncName%>(<%for (int i = 0; i < S.m_dimension-2; i++) {%><%if (i > 0) {%>, <%}%>C1[<%i%>]<%}%>);
		pt2 = <%c3gaPointFuncName%>(<%for (int i = 0; i < S.m_dimension-2; i++) {%><%if (i > 0) {%>, <%}%>C2[<%i%>]<%}%>);

		// convert points to the argument types of the distance function (this is usually not required, but doesn't hurt to do so anyway)
		tmp = new <%gmvName%>(pt1);
		argPt1 = new <%arg1TypeName%>(tmp);

		tmp = new <%gmvName%>(pt2);
		argPt2 = new <%arg2TypeName%>(tmp);

		// compute distance of points using <%targetFuncName%>()
		d2 = <%targetFuncName%>(argPt1, argPt2)<%if (S.GetScalarSMV() != null) {%>.get_scalar()<%}%>;
	
		// compare results
		dif = <%fabs%>(d1 - d2);
		if (dif > <%FT.DoubleToString(S, FT.PrecisionEpsilon() * 10.0)%>) {
			Console.WriteLine("<%targetFuncName%>() test failed (dif = " + (double)dif + ")");
			return 0; // failure
		}
	}

	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// gmvName = name of gmv
// targetFuncName = name of function to test
// testFuncName = name of testing function
// randomScalarFuncName = name of random generator function
// randomVersorFuncName = name of function for random 'gmv' blade
// gpFuncName = name of function for scalar product of two 'gmv'
// extractGradeFuncName = name of function to extract grade parts from GMV
${CODEBLOCK testVersorInverseGMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%S.m_GMV.NbCoordinates%>;
	<%gmvName%> V, VI, VVI, VIV, X, Y;
	int i;
	int basisVectorBitmap = -1;
	<%FT.type%> n1, n2;
	
	for (i = 0; i < NB_LOOPS; i++) {
		// get random versor
		V = <%randomVersorFuncName%>(<%randomScalarFuncName%>() + <%FT.DoubleToString(S, 0.5)%>, (int)(<%randomScalarFuncName%>() * <%FT.DoubleToString(S, S.m_dimension + 0.5)%>), basisVectorBitmap);
		
		// avoid 'near'-singular versors
		if (V.LargestCoordinate() > <%FT.DoubleToString(S, 2.0)%>)
			continue;
		
		// compute inverse
		VI = <%targetFuncName%>(V);
		
		// compute (inverse(V) V) and (V inverse(V))
		VIV = <%gpFuncName%>(VI, V);
		VVI = <%gpFuncName%>(V, VI);
		
		// check that scalar parts are 1
		n1 = VIV.get_scalar();
		n2 = VVI.get_scalar();
		
		if (Math.Abs(n1 - <%FT.DoubleToString(S, 1.0)%>) > <%FT.DoubleToString(S, 1000.0 * FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed |VI . V - 1|= " + (double)Math.Abs(n1 - <%FT.DoubleToString(S, 1.0)%>) + ")");
			return 0; // failure
		}
		
		if (Math.Abs(n2 - <%FT.DoubleToString(S, 1.0)%>) > <%FT.DoubleToString(S, 1000.0 * FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed ( |V . VI - 1| = " + (double)Math.Abs(n2 - <%FT.DoubleToString(S, 1.0)%>) + ")");
			return 0; // failure
		}
		
		// check that other grade parts are zero:
		X = <%extractGradeFuncName%>(VIV, GroupBitmap.ALL_GROUPS ^ GroupBitmap.GROUP_0);
		Y = <%extractGradeFuncName%>(VVI, GroupBitmap.ALL_GROUPS ^ GroupBitmap.GROUP_0);
		
		if (X.LargestCoordinate() > <%FT.DoubleToString(S, 1000.0 * FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed (largestCoordinate of VIV = " + (double)X.LargestCoordinate() + ")");
			return 0; // failure
		}
		
		if (Y.LargestCoordinate() > <%FT.DoubleToString(S, 1000.0 * FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed (largestCoordinate of VVI = " + (double)Y.LargestCoordinate() + ")");
			return 0; // failure
		}
		
	}
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// gmvName = name of gmv
// smv = smv type
// smvName = name of smv
// resultSmvName = name of result smv (inverse versor)
// targetFuncName = name of function to test
// testFuncName = name of testing function
// randomScalarFuncName = name of random generator function
// randomSmvFuncName = name of function for random 'gmv' blade
// gpFuncName = name of function for scalar product of two 'gmv'
// extractGradeFuncName = name of function to extract grade parts from GMV
${CODEBLOCK testVersorInverseSMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%smv.NbCoordinates%>;
	<%smvName%> V;
	<%resultSmvName%> VI;
	<%gmvName%> gmvV, gmvVI, VVI, VIV, X, Y;
	int i;
	<%FT.type%> n1, n2;
	
	for (i = 0; i < NB_LOOPS; i++) {
		// get random blade
		V = <%randomSmvFuncName%>(<%randomScalarFuncName%>() + <%FT.DoubleToString(S, 0.5)%>);
		
		// avoid 'near'-singular versors
		if (V.LargestCoordinate() > <%FT.DoubleToString(S, 2.0)%>)
			continue;
		
		// compute inverse
		VI = <%targetFuncName%>(V);
		
		// convert to GMV
		gmvV = new <%gmvName%>(V);
		gmvVI = new <%gmvName%>(VI);
		
		// compute (inverse(V) V) and (V inverse(V))
		VIV = <%gpFuncName%>(gmvVI, gmvV);
		VVI = <%gpFuncName%>(gmvV, gmvVI);
		
		// check that scalar parts are 1
		n1 = VIV.get_scalar();
		n2 = VVI.get_scalar();
		
		if (Math.Abs(n1 - <%FT.DoubleToString(S, 1.0)%>) > <%FT.DoubleToString(S, 1000.0 * FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed |VI . V - 1|= " + (double)Math.Abs(n1 - <%FT.DoubleToString(S, 1.0)%>) + ")");
			return 0; // failure
		}
		
		if (Math.Abs(n2 - <%FT.DoubleToString(S, 1.0)%>) > <%FT.DoubleToString(S, 1000.0 * FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed ( |V . VI - 1| = " + (double)Math.Abs(n2 - <%FT.DoubleToString(S, 1.0)%>) + ")");
			return 0; // failure
		}
		
		// check that other grade parts are zero:
		X = <%extractGradeFuncName%>(VIV, GroupBitmap.ALL_GROUPS ^ GroupBitmap.GROUP_0);
		Y = <%extractGradeFuncName%>(VVI, GroupBitmap.ALL_GROUPS ^ GroupBitmap.GROUP_0);
		
		if (X.LargestCoordinate() > <%FT.DoubleToString(S, 1000.0 * FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed (largestCoordinate of VIV = " + (double)X.LargestCoordinate() + ")");
			return 0; // failure
		}
		
		if (Y.LargestCoordinate() > <%FT.DoubleToString(S, 1000.0 * FT.PrecisionEpsilon())%>) {
			Console.WriteLine("<%targetFuncName%>() test failed (largestCoordinate of VVI = " + (double)Y.LargestCoordinate() + ")");
			return 0; // failure
		}
		
	}
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// testFuncName = name of testing function
// gmv = gmv
// gmvName = name of gmv
// targetFuncName = name of function to test
// randomScalarFuncName = name of random generator function
// randomVersorFuncName = name of function for random versor
${CODEBLOCK testZeroGMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%S.m_GMV.NbCoordinates%>;
	<%gmvName%> A;
	<%FT.type%> s, eps = <%FT.DoubleToString(S, 0.2)%>;
	int g, i;
	bool z, l, c;
	int basisVectorBitmap = -1;
	
	for (i = 0; i < NB_LOOPS; i++) {
		s = <%randomScalarFuncName%>();
		g = (int)(<%randomScalarFuncName%>() * <%FT.DoubleToString(S, S.m_dimension + 0.5)%>);
		A = <%randomVersorFuncName%>(s, g, basisVectorBitmap);
		
		// ask if <%targetFuncName%> thinks A is zero
		z = <%targetFuncName%>(A, eps);
		
		// check it yourself
		c = true; // assume it is zero
		for (g = 0; g < <%S.m_GMV.NbGroups%>; g++) {
			if (A.m_c[g] != null) {
				for (int e = 0; e < A.m_c[g].Length; e++) {
					if (Math.Abs(A.m_c[g][e]) > eps) c = false;
				}
			}
		}
		
		// also use <%gmvName%>_largestCoordinate() to verify
		l = !(A.LargestCoordinate() > eps);
		
		if ((c != z) || (l != z)) {
			Console.WriteLine("<%targetFuncName%>() test failed\n");
			return 0; // failure
		}
	}
	return 1; // success
}
${ENDCODEBLOCK}

// S = Specification
// FT = float type
// testFuncName = name of testing function
// gmvName = name of gmv
// smv = G25.SMV
// smvName = mangled name of G25.SMV
// targetFuncName = name of function to test
// randomScalarFuncName = name of random generator function
// randomSmvFuncName = name of function for random smv
${CODEBLOCK testZeroSMV}
static int <%testFuncName%>(int NB_TESTS_SCALER) 
{
	int NB_LOOPS = 100 + NB_TESTS_SCALER / <%(smv.NbCoordinates+1)%>;
	<%smvName%> A;
	<%FT.type%> s, eps = <%FT.DoubleToString(S, 0.2)%>;
	int i;
	bool l, z;
	
	for (i = 0; i < NB_LOOPS; i++) {
		s = <%randomScalarFuncName%>();
		A = <%randomSmvFuncName%>(s);
		
		// ask if <%targetFuncName%> thinks A is zero
		z = <%targetFuncName%>(A, eps);
		
		// use <%smvName%>_largestCoordinate() to verify
		l = !(A.LargestCoordinate() > eps);
		
		if (l != z) {
			Console.WriteLine("<%targetFuncName%>() test failed\n");
			return 0; // failure
		}
	}
	return 1; // success
}
${ENDCODEBLOCK}

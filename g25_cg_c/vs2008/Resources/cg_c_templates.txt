// arguments: 
// Namespace = name of algebra.
// Gaigen = name and version of Gaigen
// License = full text of license.
${CODEBLOCK doxyMainPage}
/*! \mainpage <%Namespace%> documentation
 *
 * <%Namespace%> implementation generated by <%Gaigen%>. 
 * 
 * 
 * License: 
<%License%>  
 * 
 * \section intro_sec Introduction
 *
 * Todo
 * 
 */
${ENDCODEBLOCK}


// S = Specification of algebra.
${CODEBLOCK basicInfo}

/// The dimension of the space:
extern const int <%S.m_namespace%>_spaceDim;

/// Number of groups/grades of coordinates in multivector:
extern const int <%S.m_namespace%>_nbGroups;

/// The constants for the grades in an array:
extern const int <%S.m_namespace%>_grades[];

/// The constants for the groups in an array:
extern const int <%S.m_namespace%>_groups[];

/// Is the metric of the space Euclidean? (0 or 1)
extern const int <%S.m_namespace%>_metricEuclidean;

/// This array can be used to lookup the number of coordinates for a group part of a general multivector
extern const int <%S.m_namespace%>_groupSize[<%S.m_GMV.NbGroups%>];

/// This array can be used to lookup the number of coordinates based on a group usage bitmap
extern const int <%S.m_namespace%>_mvSize[<%1<<S.m_GMV.NbGroups%>];

/// This array of ASCIIZ strings contains the names of the basis vectors
extern const char *<%S.m_namespace%>_basisVectorNames[<%S.m_dimension%>];

/// This array of integers contains the order of basis elements in the general multivector
/// Use it to answer: 'what basis vectors are in the basis element at position [x]?
extern const int <%S.m_namespace%>_basisElements[<%1<<S.m_dimension%>][<%S.m_dimension+1%>];

/// This array of integers contains the 'sign' (even/odd permutation of canonical order) of basis elements in the general multivector
/// Use it to answer 'what is the permutation of the coordinate at index [x]'?
extern const double <%S.m_namespace%>_basisElementSignByIndex[<%1<<S.m_dimension%>];

/// This array of integers contains the 'sign' (even/odd permutation of canonical order) of basis elements in the general multivector
/// Use it to answer 'what is the permutation of the coordinate of bitmap [x]'?
extern const double <%S.m_namespace%>_basisElementSignByBitmap[<%1<<S.m_dimension%>];

/// This array of integers contains the order of basis elements in the general multivector
/// Use it to answer: 'at what index do I find basis element [x] (x = basis vector bitmap)?'
extern const int <%S.m_namespace%>_basisElementIndexByBitmap[<%1<<S.m_dimension%>];

/// This array of integers contains the indices of basis elements in the general multivector
/// Use it to answer: 'what basis element do I find at index [x]'?
extern const int <%S.m_namespace%>_basisElementBitmapByIndex[<%1<<S.m_dimension%>];

/// This array of grade of each basis elements in the general multivector
/// Use it to answer: 'what is the grade of basis element bitmap [x]'?
extern const int <%S.m_namespace%>_basisElementGradeByBitmap[<%1<<S.m_dimension%>];

/// This array of group of each basis elements in the general multivector
/// Use it to answer: 'what is the group of basis element bitmap [x]'?
extern const int <%S.m_namespace%>_basisElementGroupByBitmap[<%1<<S.m_dimension%>];
${ENDCODEBLOCK}


// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// gmv = general multivector (G25.GMV)
${CODEBLOCK compress_decl}
extern void <%FT.GetMangledName(S, "compress")%>(const <%FT.type%> *c, <%FT.type%> *cc, int *cgu, <%FT.type%> epsilon, int gu);
extern void <%FT.GetMangledName(S, "expand")%>(const <%FT.type%> *ptrs[<%S.m_dimension+1%>], const <%FT.GetMangledName(S, gmv.Name)%> *src);
${ENDCODEBLOCK}

// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// gmv = general multivector (G25.GMV)
${CODEBLOCK compress}
/** This function is not for external use. It compresses arrays of floats for storage in multivectors. */
void <%FT.GetMangledName(S, "compress")%>(const <%FT.type%> *c, <%FT.type%> *cc, int *cgu, <%FT.type%> epsilon, int gu) {
	int i, j, ia = 0, ib = 0, f, s;
	*cgu = 0;

	// for all grade parts...
	for (i = 0; i <= <%gmv.NbGroups%>; i++) {
		// check if grade part has memory use:
		if (!(gu & (1 << i))) continue;

		// check if abs coordinates of grade part are all < epsilon
		s = <%S.m_namespace%>_groupSize[i];
		j = ia + s;
		f = 0;
		for (; ia < j; ia++)
			if (fabs<%((FT.type == "float") ? "f" : "")%>(c[ia]) > epsilon) {f = 1; break;}
		ia = j;
		if (f) {
			<%if (S.m_GMV.MemoryAllocationMethod == G25.GMV.MEM_ALLOC_METHOD.PARITY_PURE) {%>if ((ib+s) > <%1<<(S.m_dimension-1)%>) break; // when this 'break' happens, the input is not parity pure
<%}%>
			<%G25.CG.Shared.Util.GetCopyCode(S, FT, "c + ia - s", "cc + ib", "s")%>
			ib += s;
			*cgu |= (1 << i);
		}
	}
}

/** This function is not for external use. It decompresses the coordinates stored in this */
void <%FT.GetMangledName(S, "expand")%>(const <%FT.type%> *ptrs[<%S.m_GMV.NbGroups%>], const <%FT.GetMangledName(S, gmv.Name)%> *src) {
	const <%FT.type%> *c = src->c;
	
<%for (int i = 0; i < gmv.NbGroups; i++) {%>
	if (src->gu & <%1 << i%>) {
		ptrs[<%i%>] =  c;
<%if (i != (gmv.NbGroups-1)) {%>
		c += <%gmv.Group(i).Length%>;
<%}%>
	}
	else ptrs[<%i%>] = NULL;	
<%}%>
}

${ENDCODEBLOCK}

// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
${CODEBLOCK largestCoordinateDecl}
/// Returns absolute largest coordinate in <%gmvName%>.
<%FT.type%> <%gmvName%>_largestCoordinate(const <%gmvName%> *x);
/// Returns absolute largest coordinate in <%gmvName%>, and the bitmap of the corresponding basis blade (in 'bm').
<%FT.type%> <%gmvName%>_largestBasisBlade(const <%gmvName%> *x, unsigned int *bm);
${ENDCODEBLOCK}

// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// gmvName = name of GMV struct
// fabsFunc = name of floating point absolute function
${CODEBLOCK largestCoordinateDef}
<%FT.type%> <%gmvName%>_largestCoordinate(const <%gmvName%> *x) {
	<%FT.type%> maxValue = <%FT.DoubleToString(S, 0.0)%>;
	int nbC = <%S.m_namespace%>_mvSize[x->gu], i;
	for (i = 0; i < nbC; i++)
		if (<%fabsFunc%>(x->c[i]) > maxValue) maxValue = <%fabsFunc%>(x->c[i]);
	return maxValue;
}

<%FT.type%> <%gmvName%>_largestBasisBlade(const <%gmvName%> *x, unsigned int *bm) {
	int nc = <%S.m_namespace%>_mvSize[x->gu];
	<%FT.type%> maxC = <%FT.DoubleToString(S, -1.0)%>, C;

	int idx = 0;
	int group = 0;
	int i = 0, j;
	*bm = 0;

	while (i < nc) {
		if (x->gu & (1 << group)) {
			for (j = 0; j < <%S.m_namespace%>_groupSize[group]; j++) {
				C = <%fabsFunc%>(x->c[i]);
				if (C > maxC) {
					maxC = C;
					*bm = <%S.m_namespace%>_basisElementBitmapByIndex[idx];
				}
				idx++;
				i++;
			}
		}
		else idx += <%S.m_namespace%>_groupSize[group];
		group++;
	}

	return maxC;
} // end of <%gmvName%>::largestBasisBlade()


${ENDCODEBLOCK}


${CODEBLOCK swapPointer}
void swapPointer(void **P1, void **P2)
{
	void *tmp = *P1;
	*P1 = *P2;
	*P2 = tmp;
}
${ENDCODEBLOCK}

${CODEBLOCK swapPointerDecl}
extern void swapPointer(void **P1, void **P2);
${ENDCODEBLOCK}

${CODEBLOCK seriesDecl}
/** Computes <%mathFuncName%> of <%inputType%>.
<%userComment%> */
void <%funcName%>(<%returnType%> *R, const <%inputType%> *x, int order);
${ENDCODEBLOCK}

// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesSin}

void <%funcName%>(<%returnType%> *R, const <%inputType%> *x, int order) {
	<%returnType%> tmp1, tmp2, tmp3; // temp <%returnType%> used for various purposes
	<%returnType%> *xPow1 = &tmp1, *xPow2 = &tmp2; // xScaled^... goes here
	<%returnType%> *result1 = R, *result2 = &tmp3; // accumulated result goes here (note: 'result1' = 'R')
	<%FT.type%> s_x2, a;
	int i;
   
	// First try special cases: check if (x * x) is scalar
	<%gpFuncII%>(&tmp1, x, x);
	s_x2 = <%scalarTmp1%>;
	if ((<%normE2funcR%>(&tmp1) - s_x2 * s_x2) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
		// OK (x * x == ~scalar), so use special cases:
		if (s_x2 < <%FT.DoubleToString(S, 0.0)%>) {
			a = <%sqrtFunc%>(-s_x2);
			<%SASfuncI%>(R, x, <%sinhFunc%>(a) / a, <%FT.DoubleToString(S, 0.0)%>);
			return;
		}
		else if (s_x2 > <%FT.DoubleToString(S, 0.0)%>) {
			a = <%sqrtFunc%>(s_x2);
			<%SASfuncI%>(R, x, <%sinFunc%>(a) / a, <%FT.DoubleToString(S, 0.0)%>);
			return;
		}
		else {
			<%copyInputToReturnFunc%>(R, x);
			return;
		}
	}

	// else do general series eval . . .

	// result = A -  ....	+ ... - ...
	<%returnType%>_setZero(result1);
    	if (order == 0) return;
    	
	// taylor series approximation
	<%returnType%>_setScalar(xPow1, <%FT.DoubleToString(S, 1.0)%>); // xPow1 = 1.0
	for (i = 1; i <= order; i++) {
		<%gpFuncRI%>(xPow2, xPow1, x); // xPow2 = xPow1 * x
		
		<%gpFuncRdouble%>(xPow1, xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i); // xPow1 = xScaled^i / i! 
		if ((i % 4) == 3)
		{
			<%subFuncRR%>(result2, result1, xPow1); // result2 = result1 - xPow1
			swapPointer((void**)&result1, (void**)&result2); // result is always in 'result1' at end of loop
		}
		else if ((i % 4) == 1) 
		{
			<%addFuncRR%>(result2, result1, xPow1); // result2 = result1 + xPow1
			swapPointer((void**)&result1, (void**)&result2); // result is always in 'result1' at end of loop
		}
	}

    
	if (R != result1) { // if result does not reside in 'R' in the end, do an explicit copy
		<%returnType%>_copy(R, result1);
	}
} // end of <%funcName%>()

${ENDCODEBLOCK}

// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesSinh}

void <%funcName%>(<%returnType%> *R, const <%inputType%> *x, int order) {
	<%returnType%> tmp1, tmp2, tmp3; // temp <%returnType%> used for various purposes
	<%returnType%> *xPow1 = &tmp1, *xPow2 = &tmp2; // xScaled^... goes here
	<%returnType%> *result1 = R, *result2 = &tmp3; // accumulated result goes here (note: 'result1' = 'R')
	<%FT.type%> s_x2, a;
	int i;
   
	// First try special cases: check if (x * x) is scalar
	<%gpFuncII%>(&tmp1, x, x);
	s_x2 = <%scalarTmp1%>;
	if ((<%normE2funcR%>(&tmp1) - s_x2 * s_x2) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
		// OK (x * x == ~scalar), so use special cases:
		if (s_x2 < <%FT.DoubleToString(S, 0.0)%>) {
			a = <%sqrtFunc%>(-s_x2);
			<%SASfuncI%>(R, x, <%sinFunc%>(a) / a, <%FT.DoubleToString(S, 0.0)%>);
			return;
		}
		else if (s_x2 > <%FT.DoubleToString(S, 0.0)%>) {
			a = <%sqrtFunc%>(s_x2);
			<%SASfuncI%>(R, x, <%sinhFunc%>(a) / a, <%FT.DoubleToString(S, 0.0)%>);
			return;
		}
		else {
			<%copyInputToReturnFunc%>(R, x);
			return;
		}
	}

	// else do general series eval . . .

	// result = A +  A^3/3! + A^5/5!
	<%returnType%>_setZero(result1);
    if (order == 0) return;
    	
	// taylor series approximation
	<%returnType%>_setScalar(xPow1, <%FT.DoubleToString(S, 1.0)%>); // xPow1 = 1.0
	for (i = 1; i <= order; i++) {
		<%gpFuncRI%>(xPow2, xPow1, x); // xPow2 = xPow1 * x
		<%gpFuncRdouble%>(xPow1, xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i); // xPow1 = xScaled^i / i! 
		
		if ((i % 2) == 1) {
			<%addFuncRR%>(result2, result1, xPow1); // result2 = result1 + xPow1
			swapPointer((void**)&result1, (void**)&result2); // result is always in 'result1' at end of loop
		}
	}

    
	if (R != result1) { // if result does not reside in 'R' in the end, do an explicit copy
		<%returnType%>_copy(R, result1);
	}
} // end of <%funcName%>()

${ENDCODEBLOCK}

// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesCos}

void <%funcName%>(<%returnType%> *R, const <%inputType%> *x, int order) {
	<%returnType%> tmp1, tmp2, tmp3; // temp <%returnType%> used for various purposes
	<%returnType%> *xPow1 = &tmp1, *xPow2 = &tmp2; // xScaled^... goes here
	<%returnType%> *result1 = R, *result2 = &tmp3; // accumulated result goes here (note: 'result1' = 'R')
	<%FT.type%> s_x2, a;
	int i;
   
	// First try special cases: check if (x * x) is scalar
	<%gpFuncII%>(&tmp1, x, x);
	s_x2 = <%scalarTmp1%>;
	if ((<%normE2funcR%>(&tmp1) - s_x2 * s_x2) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
		// OK (x * x == ~scalar), so use special cases:
		if (s_x2 > <%FT.DoubleToString(S, 0.0)%>) {
			a = <%sqrtFunc%>(s_x2);
			<%returnType%>_setScalar(R, <%cosFunc%>(a));
			return;
		}
		else if (s_x2 < <%FT.DoubleToString(S, 0.0)%>) {
			a = <%sqrtFunc%>(-s_x2);
			<%returnType%>_setScalar(R, <%coshFunc%>(a));
			return;
		}
		else {
			<%returnType%>_setScalar(R, <%FT.DoubleToString(S, 1.0)%>);
			return;
		}
	}

	// else do general series eval . . .


	<%returnType%>_setScalar(result1, <%FT.DoubleToString(S, 1.0)%>);
	if (order == 0) return;

	// taylor series approximation
	<%returnType%>_setScalar(xPow1, <%FT.DoubleToString(S, 1.0)%>); // xPow1 = 1.0
	for (i = 1; i <= order; i++) {
		<%gpFuncRI%>(xPow2, xPow1, x); // xPow2 = xPow1 * x
		<%gpFuncRdouble%>(xPow1, xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i); // xPow1 = xScaled^i / i! 
		
		if ((i % 4) == 2)
		{
			<%subFuncRR%>(result2, result1, xPow1); // result2 = result1 - xPow1
			swapPointer((void**)&result1, (void**)&result2); // result is always in 'result1' at end of loop
		}
		else if ((i % 4) == 0) 
		{
			<%addFuncRR%>(result2, result1, xPow1); // result2 = result1 + xPow1
			swapPointer((void**)&result1, (void**)&result2); // result is always in 'result1' at end of loop
		}		
    }

    
	if (R != result1) { // if result does not reside in 'R' in the end, do an explicit copy
		<%returnType%>_copy(R, result1);
	}
} // end of <%funcName%>()

${ENDCODEBLOCK}

// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesCosh}

void <%funcName%>(<%returnType%> *R, const <%inputType%> *x, int order) {
	<%returnType%> tmp1, tmp2, tmp3; // temp <%returnType%> used for various purposes
	<%returnType%> *xPow1 = &tmp1, *xPow2 = &tmp2; // xScaled^... goes here
	<%returnType%> *result1 = R, *result2 = &tmp3; // accumulated result goes here (note: 'result1' = 'R')
	<%FT.type%> s_x2, a;
	int i;
   
	// First try special cases: check if (x * x) is scalar
	<%gpFuncII%>(&tmp1, x, x);
	s_x2 = <%scalarTmp1%>;
	if ((<%normE2funcR%>(&tmp1) - s_x2 * s_x2) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
		// OK (x * x == ~scalar), so use special cases:
		if (s_x2 > <%FT.DoubleToString(S, 0.0)%>) {
			a = <%sqrtFunc%>(s_x2);
			<%returnType%>_setScalar(R, <%coshFunc%>(a));
			return;
		}
		else if (s_x2 < <%FT.DoubleToString(S, 0.0)%>) {
			a = <%sqrtFunc%>(-s_x2);
			<%returnType%>_setScalar(R, <%cosFunc%>(a));
			return;
		}
		else {
			<%returnType%>_setScalar(R, <%FT.DoubleToString(S, 1.0)%>);
			return;
		}
	}

	// else do general series eval . . .


	<%returnType%>_setScalar(result1, <%FT.DoubleToString(S, 1.0)%>);
	if (order == 0) return;

	// taylor series approximation
	<%returnType%>_setScalar(xPow1, <%FT.DoubleToString(S, 1.0)%>); // xPow1 = 1.0
	for (i = 1; i <= order; i++) {
		<%gpFuncRI%>(xPow2, xPow1, x); // xPow2 = xPow1 * x
		<%gpFuncRdouble%>(xPow1, xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i); // xPow1 = xScaled^i / i! 
		
		if ((i % 2) == 0) {
			<%addFuncRR%>(result2, result1, xPow1); // result2 = result1 + xPow1
			swapPointer((void**)&result1, (void**)&result2); // result is always in 'result1' at end of loop		
		}
    }

    
	if (R != result1) { // if result does not reside in 'R' in the end, do an explicit copy
		<%returnType%>_copy(R, result1);
	}
} // end of <%funcName%>()

${ENDCODEBLOCK}

// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesExp}

void <%funcName%>(<%returnType%> *R, const <%inputType%> *x, int order) {
	unsigned long maxC;
	int scale = 1;
	<%inputType%> xScaled;
	<%returnType%> tmp1, tmp2, tmp3; // temp <%returnType%> used for various purposes
	<%returnType%> *xPow1 = &tmp1, *xPow2 = &tmp2; // xScaled^... goes here
	<%returnType%> *result1 = R, *result2 = &tmp3; // accumulated result goes here (note: 'result1' = 'R')
	<%FT.type%> s_x2, a;
	int i;
   
	// First try special cases: check if (x * x) is scalar
	<%gpFuncII%>(&tmp1, x, x);
	s_x2 = <%scalarTmp1%>;
	if ((<%normE2funcR%>(&tmp1) - s_x2 * s_x2) < <%FT.DoubleToString(S, FT.PrecisionEpsilon())%>) {
		// OK (x * x == ~scalar), so use special cases:
		if (s_x2 < <%FT.DoubleToString(S, 0.0)%>) {
			a = <%sqrtFunc%>(-s_x2);
			<%SASfuncI%>(R, x, <%sinFunc%>(a) / a, <%cosFunc%>(a));
			return;
		}
		else if (s_x2 > <%FT.DoubleToString(S, 0.0)%>) {
			a = <%sqrtFunc%>(s_x2);
			<%SASfuncI%>(R, x, <%sinhFunc%>(a) / a, <%coshFunc%>(a));
			return;
		}
		else {
			<%SASfuncI%>(R, x, <%FT.DoubleToString(S, 1.0)%>, <%FT.DoubleToString(S, 1.0)%>);
			return;
		}
	}

	// else do general series eval . . .

	// result = 1 + ....	
	<%returnType%>_setScalar(result1, <%FT.DoubleToString(S, 1.0)%>);
	if (order == 0) return;

	// find scale (power of 2) such that its norm is < 1
	maxC = (unsigned long)<%inputType%>_largestCoordinate(x);
	scale = 1;
	if (maxC > 1) scale <<= 1;
	while (maxC)
	{
		maxC >>= 1;
		scale <<= 1;
	}

	// scale
	<%gpFuncIdouble%>(&xScaled, x, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)scale); // xScaled = x / scale

	// taylor series approximation
	<%returnType%>_setScalar(xPow1, <%FT.DoubleToString(S, 1.0)%>); // xPow1 = 1.0
	for (i = 1; i <= order; i++) {
		<%gpFuncRI%>(xPow2, xPow1, &xScaled); // xPow2 = xPow1 * xScaled
		<%gpFuncRdouble%>(xPow1, xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i); // xPow1 = xScaled^i / i! 
		
		<%addFuncRR%>(result2, result1, xPow1); // result2 = result1 + xPow1
		swapPointer((void**)&result1, (void**)&result2); // result is always in 'result1' at end of loop
    }

	// undo scaling
	while (scale > 1)
	{
		<%gpFuncRR%>(result2, result1, result1); // result2 = result1 * result1
		swapPointer((void**)&result1, (void**)&result2); // result is always in 'result1' at end of loop
		scale >>= 1;
	}
    
	if (R != result1) { // if result does not reside in 'R' in the end, do an explicit copy
		<%returnType%>_copy(R, result1);
	}
} // end of <%funcName%>()

${ENDCODEBLOCK}


// S = Specification of algebra.
${CODEBLOCK mersenneTwisterHeader}
#ifndef _MT_<%S.m_namespace.ToUpper()%>_H_
#define _MT_<%S.m_namespace.ToUpper()%>_H_

/** initializes mt[N] with a seed */
void init_genrand(unsigned long s);
/** generates a random number on [0,0xffffffff]-interval */
unsigned long genrand_int32(void);
/** generates a random number on [0,0x7fffffff]-interval */
long genrand_int31(void);
/** generates a random number on [0,1]-real-interval */
double genrand_real1(void);
/** generates a random number on [0,1)-real-interval */
double genrand_real2(void);
/** generates a random number on (0,1)-real-interval */
double genrand_real3(void);
/** generates a random number on [0,1) with 53-bit resolution*/
double genrand_res53(void);

#endif /* _MT_<%S.m_namespace.ToUpper()%>_H_ */
${ENDCODEBLOCK}


// S = Specification of algebra.
${CODEBLOCK mersenneTwisterSource}
/* 
   A C-program for MT19937, with initialization improved 2002/1/26.
   Coded by Takuji Nishimura and Makoto Matsumoto.

   Before using, initialize the state by using init_genrand(seed)  
   or init_by_array(init_key, key_length).

   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
   All rights reserved.                          

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

     3. The names of its contributors may not be used to endorse or promote 
        products derived from this software without specific prior written 
        permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


   Any feedback is very welcome.
   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)
*/

#include <stdio.h>



/* Period parameters */  
#define N 624
#define M 397
#define MATRIX_A 0x9908b0dfUL   /* constant vector a */
#define UPPER_MASK 0x80000000UL /* most significant w-r bits */
#define LOWER_MASK 0x7fffffffUL /* least significant r bits */

static unsigned long mt[N]; /* the array for the state vector  */
static int mti=N+1; /* mti==N+1 means mt[N] is not initialized */

/* initializes mt[N] with a seed */
void init_genrand(unsigned long s)
{
    mt[0]= s & 0xffffffffUL;
    for (mti=1; mti<N; mti++) {
        mt[mti] = 
	    (1812433253UL * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti); 
        /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
        /* In the previous versions, MSBs of the seed affect   */
        /* only MSBs of the array mt[].                        */
        /* 2002/01/09 modified by Makoto Matsumoto             */
        mt[mti] &= 0xffffffffUL;
        /* for >32 bit machines */
    }
}

/* initialize by an array with array-length */
/* init_key is the array for initializing keys */
/* key_length is its length */
/* slight change for C++, 2004/2/26 */
void init_by_array(unsigned long init_key[], int key_length)
{
    int i, j, k;
    init_genrand(19650218UL);
    i=1; j=0;
    k = (N>key_length ? N : key_length);
    for (; k; k--) {
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525UL))
          + init_key[j] + j; /* non linear */
        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
        i++; j++;
        if (i>=N) { mt[0] = mt[N-1]; i=1; }
        if (j>=key_length) j=0;
    }
    for (k=N-1; k; k--) {
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941UL))
          - i; /* non linear */
        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
        i++;
        if (i>=N) { mt[0] = mt[N-1]; i=1; }
    }

    mt[0] = 0x80000000UL; /* MSB is 1; assuring non-zero initial array */ 
}

/* generates a random number on [0,0xffffffff]-interval */
unsigned long genrand_int32(void)
{
    unsigned long y;
    static unsigned long mag01[2]={0x0UL, MATRIX_A};
    /* mag01[x] = x * MATRIX_A  for x=0,1 */

    if (mti >= N) { /* generate N words at one time */
        int kk;

        if (mti == N+1)   /* if init_genrand() has not been called, */
            init_genrand(5489UL); /* a default initial seed is used */

        for (kk=0;kk<N-M;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        for (;kk<N-1;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);
        mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1UL];

        mti = 0;
    }
  
    y = mt[mti++];

    /* Tempering */
    y ^= (y >> 11);
    y ^= (y << 7) & 0x9d2c5680UL;
    y ^= (y << 15) & 0xefc60000UL;
    y ^= (y >> 18);

    return y;
}

/* generates a random number on [0,0x7fffffff]-interval */
long genrand_int31(void)
{
    return (long)(genrand_int32()>>1);
}

/* generates a random number on [0,1]-real-interval */
double genrand_real1(void)
{
    return genrand_int32()*(1.0/4294967295.0); 
    /* divided by 2^32-1 */ 
}

/* generates a random number on [0,1)-real-interval */
double genrand_real2(void)
{
    return genrand_int32()*(1.0/4294967296.0); 
    /* divided by 2^32 */
}

/* generates a random number on (0,1)-real-interval */
double genrand_real3(void)
{
    return (((double)genrand_int32()) + 0.5)*(1.0/4294967296.0); 
    /* divided by 2^32 */
}

/* generates a random number on [0,1) with 53-bit resolution*/
double genrand_res53(void) 
{ 
    unsigned long a=genrand_int32()>>5, b=genrand_int32()>>6; 
    return(a*67108864.0+b)*(1.0/9007199254740992.0); 
} 
/* These real versions are due to Isaku Wada, 2002/01/09 added */

${ENDCODEBLOCK}


// same arguments as randomBladeVersor
${CODEBLOCK randomBladeVersorHeader}
/**
Generates a random <%if (generatorVersor) {%>versor<%}else{%>blade<%}%>.
The scale is uniformly distributed over the interval [0 1).
The maximum non-zero grade-part is 'grade'.
Only the basis vectors marked in 'basisVectorBitmap' will be used to generate the
versor/blade. Use 'basisVectorBitmap = -1' to use all basisvectors.

Calls <%functionName%>_ex(arg1, scale, grade, basisVectorBitmap, 0.01, scale * 4.0);
*/
void <%functionName%>(<%mvType%> *arg1, <%FT.type%> scale, int grade, int basisVectorBitmap);

/**
This version of <%functionName%>() has extra arguments which help to avoid 
near-singular blades / versors.

Near-singular blades / versors are avoid by testing the norm and largest coordinate
of the random blade / versor. If the test does not pass, the function recursively
tries to generate another random blade / versor.

'minimumNorm' is the minimum allowed norm of the blade/versor before scaling. 
'minimumNorm' must be > 0.0 for versors.

'largestCoordinate' is the largest coordinate allowed after scaling.

*/
void <%functionName%>_ex(<%mvType%> *arg1, <%FT.type%> scale, int grade, int basisVectorBitmap, <%FT.type%> minimumNorm, <%FT.type%> largestCoordinate);
${ENDCODEBLOCK}

// S = Specification of algebra.
// functionName = name of generated function
// FT = floating point type
// mvType = multivector type name (with prefix/suffix)
// randomScalarFuncName = name of function which generates random scalar values
// gpopFuncName = name of geometric product or outer product function for two multivectors
// normFuncName = norm of multivector function (must return scalar)
// gpScalarFuncName = geometric product of multivector and scalar
// generatorVersor = bool (use geometric product or outer product)
${CODEBLOCK randomBladeVersor}
<%G25.CG.Shared.Util.GetInlineString(S, S.m_inlineFunctions, " ")%>void <%functionName%>(<%mvType%> *arg1, <%FT.type%> scale, int grade, int basisVectorBitmap) {
	<%FT.type%> minimumNorm = <%FT.DoubleToString(S, 0.01)%>;
	<%FT.type%> largestCoordinate = <%FT.DoubleToString(S, 4.0)%>;
	<%functionName%>_ex(arg1, scale, grade, basisVectorBitmap, minimumNorm, scale * largestCoordinate);
}

<%G25.CG.Shared.Util.GetInlineString(S, S.m_inlineFunctions, " ")%>void <%functionName%>_ex(<%mvType%> *arg1, <%FT.type%> scale, int _grade, int basisVectorBitmap, 
		<%FT.type%> minimumNorm, <%FT.type%> largestCoordinate) 
{
	<%mvType%> randomVector, tmp1, tmp2;
	<%mvType%> *IR1 = &tmp1, *IR2 = &tmp2, *swapIR; // IR = intermediate result
	<%FT.type%> randomValues[<%S.m_dimension%>];
	<%FT.type%> n2, mul;
	int i;
	int tryAgain = 1;
	int grade = _grade;
	
	// set IR1 (intermediate result) to 1
	<%mvType%>_setScalar(IR1, <%FT.DoubleToString(S, 1.0)%>);

	while (grade > 0) {	// loop until grade == 0
		// fill array with random values
		for (i = 0; i < <%S.m_dimension%>; i++) 
			randomValues[i] = (basisVectorBitmap & (1 << i))
				? (<%FT.DoubleToString(S, -1.0)%> + <%FT.DoubleToString(S, 2.0)%> * <%randomScalarFuncName%>())
				: <%FT.DoubleToString(S, 0.0)%>;
		
		// make it a multivector:
		<%mvType%>_setArray(&randomVector, GRADE_1, randomValues);
		
		// multiply 
		<%gpopFuncName%>(IR2, IR1, &randomVector);
		
		// swap IR pointers: 
		swapIR = IR1; IR1 = IR2; IR2 = swapIR;
		
		// lower grade
		grade--;
	}
	
	// compute norm/multiplier, test for near-null blade or versor.
	n2 = <%normFuncName%>(IR1);
	if ((<%FT.type%>)fabs(n2) > minimumNorm * minimumNorm) { 
		if (n2 != <%FT.DoubleToString(S, 0.0)%>) {
			mul = scale * <%randomScalarFuncName%>() / n2;
			<%gpScalarFuncName%>(arg1, IR1, mul);
		}
		else {
			<%mvType%>_copy(arg1, IR1);
		}
		
		if (<%mvType%>_largestCoordinate(arg1) < largestCoordinate)
			tryAgain = 0;
	}
	
	if (tryAgain) { // this can lead to infinite recursion due to bad arguments
		<%functionName%>_ex(arg1, scale, _grade, basisVectorBitmap, minimumNorm, largestCoordinate); 
	}
}
${ENDCODEBLOCK}

// S = Specification of algebra.
// functionName = name of generated function
// pointType = multivector type name (with prefix/suffix)
// FT = floating point type
// randomScalarFuncName = name of function which generates random scalar values
// cgaPointFunc = function for computing a point from coordinates
${CODEBLOCK randomCgaPoint}
<%if (S.m_inlineFunctions) {%>inline <%}%>void <%functionName%>(<%pointType%> *pt, <%FT.type%> scale) {
<%for (int i = 0; i < S.m_dimension-2; i++) {%>	<%FT.type%> ce<%(i+1).ToString()%> = scale * (<%FT.DoubleToString(S, -1.0)%> + <%FT.DoubleToString(S, 2.0)%> * <%randomScalarFuncName%>());
<%}%>
	<%cgaPointFunc%>(pt<%for (int i = 0; i < S.m_dimension-2; i++) {%>, ce<%(i+1).ToString()%><%}%>);
}
${ENDCODEBLOCK}
${CODEBLOCK randomCgaPointHeader}
/** Returns a random conformal point where the coordinates lie in the interval [-scale, scale). */
void <%functionName%>(<%pointType%> *pt, <%FT.type%> scale);
${ENDCODEBLOCK}



// S = Specification of algebra.
// STRING_PARAMETERS = list of parameters that determine output of toString and their default values.
${CODEBLOCK toStringHeader}
/**
This function alters the formatting of 'string()'.
'format' = NULL will give you back the default.
*/
void <%S.m_namespace%>_setStringFormat(const char *what, const char *format);

<%for (int i = 0; i < STRING_PARAMETERS.Length; i++) {
%>extern const char *<%S.m_namespace%>_string_<%STRING_PARAMETERS[i][0]%>; /* = \"<%STRING_PARAMETERS[i][1]%>\" */
<%}%>


<%foreach (G25.FloatType FT in S.m_floatTypes) {%>
/// Writes value of 'V' to 'str' using float point precision 'fp' (e.g. %f). 'maxLength' is the length of 'str'. 'str' is returned.
const char *toString_<%FT.GetMangledName(S, S.m_GMV.Name)%>(const <%FT.GetMangledName(S, S.m_GMV.Name)%> *V, char *str, int maxLength, const char *fp);

<%foreach (G25.SMV smv in S.m_SMV) {
if (!smv.CanConvertToGmv(S)) continue;
%>
/// Writes value of 'V' to 'str' using float point precision 'fp' (e.g. %f). 'maxLength' is the length of 'str'. 'str' is returned.
const char *toString_<%FT.GetMangledName(S, smv.Name)%>(const <%FT.GetMangledName(S, smv.Name)%> *V, char *str, int maxLength, const char *fp);
<%}%>

<%}%>


${ENDCODEBLOCK}


// S = Specification of algebra.
// STRING_PARAMETERS = list of parameters that determine output of toString and their default values.
${CODEBLOCK toStringSource}
/* 
These strings determine how the output of string() is formatted.
You can alter them at runtime using <%S.m_namespace%>_setStringFormat().
*/
<%for (int i = 0; i < STRING_PARAMETERS.Length; i++) {%> 
const char *<%S.m_namespace%>_string_<%STRING_PARAMETERS[i][0]%> = "<%STRING_PARAMETERS[i][1]%>";<%}%> 

void <%S.m_namespace%>_setStringFormat(const char *what, const char *format) {
<%for (int i = 0; i < STRING_PARAMETERS.Length; i++) {%> 
	<%if (i > 0) {%>else <%}%>if (!strcmp(what, "<%STRING_PARAMETERS[i][0]%>")) 
		<%S.m_namespace%>_string_<%STRING_PARAMETERS[i][0]%> = (format) ? format : "<%STRING_PARAMETERS[i][1]%>";<%}%>

}

<%foreach (G25.FloatType FT in S.m_floatTypes) {%>
<%if (FT != S.m_floatTypes[0]) {%>
const char *toString_<%FT.GetMangledName(S, S.m_GMV.Name)%>(const <%FT.GetMangledName(S, S.m_GMV.Name)%> *V, char *str, int maxLength, const char *fp)
{
	<%S.m_floatTypes[0].GetMangledName(S, S.m_GMV.Name)%> tmp;
	<%FT.GetMangledName(S, S.m_GMV.Name)%>_to_<%S.m_floatTypes[0].GetMangledName(S, S.m_GMV.Name)%>(&tmp,V);
	return toString_<%S.m_floatTypes[0].GetMangledName(S, S.m_GMV.Name)%>(&tmp, str, maxLength, fp);
}
<%}%>
<%foreach (G25.SMV smv in S.m_SMV) {
if (!smv.CanConvertToGmv(S)) continue;
%>
const char *toString_<%FT.GetMangledName(S, smv.Name)%>(const <%FT.GetMangledName(S, smv.Name)%> *V, char *str, int maxLength, const char *fp)
{
	<%S.m_floatTypes[0].GetMangledName(S, S.m_GMV.Name)%> tmp;
<%if (FT != S.m_floatTypes[0]) {%>
	<%FT.GetMangledName(S, S.m_GMV.Name)%> tmp2;
	<%FT.GetMangledName(S, smv.Name)%>_to_<%FT.GetMangledName(S, S.m_GMV.Name)%>(&tmp2,V);
	<%FT.GetMangledName(S, S.m_GMV.Name)%>_to_<%S.m_floatTypes[0].GetMangledName(S, S.m_GMV.Name)%>(&tmp, &tmp2);
<%} else {%>
	<%FT.GetMangledName(S, smv.Name)%>_to_<%S.m_floatTypes[0].GetMangledName(S, S.m_GMV.Name)%>(&tmp,V);
<%}%>
	return toString_<%S.m_floatTypes[0].GetMangledName(S, S.m_GMV.Name)%>(&tmp, str, maxLength, fp);
}
<%}%>

<%}%>
#ifdef WIN32
#define snprintf _snprintf
#pragma warning(disable:4996) /* quit your whining already */
#endif /* WIN32 */
<%{const int TMP_BUF_LENGTH = 256; %>
const char *toString_<%S.m_floatTypes[0].GetMangledName(S, S.m_GMV.Name)%>(const <%S.m_floatTypes[0].GetMangledName(S, S.m_GMV.Name)%> *V, char *str, int maxLength, const char *fp) 
{
	int dummyArg = 0; // prevents compiler warning on some platforms
	int stdIdx = 0, l;
	char tmpBuf[<%TMP_BUF_LENGTH%>], tmpFloatBuf[<%TMP_BUF_LENGTH%>]; 
	int i, j, k = 0, bei, ia = 0, s = <%S.m_namespace%>_mvSize[V->gu], p = 0, cnt = 0;

	// set up the floating point precision
	if (fp == NULL) fp = <%S.m_namespace%>_string_fp;

	// start the string
	l = snprintf(tmpBuf, <%TMP_BUF_LENGTH%>, "%s", <%S.m_namespace%>_string_start);
	if (stdIdx + l <= maxLength) {
		strcpy(str + stdIdx, tmpBuf);
		stdIdx += l;
	}
	else {
		snprintf(str, maxLength, "toString_<%S.m_floatTypes[0].GetMangledName(S, S.m_GMV.Name)%>: buffer too small");
		return str;
	}

	// print all coordinates
	for (i = 0; i <= <%S.m_GMV.NbGroups%>; i++) {
		if (V->gu & (1 << i)) {
			for (j = 0; j < <%S.m_namespace%>_groupSize[i]; j++) {
				<%S.m_floatTypes[0].type%> coord = (<%S.m_floatTypes[0].type%>)<%S.m_namespace%>_basisElementSignByIndex[ia] * V->c[k];
				/* goal: print [+|-]V->c[k][* basisVector1 ^ ... ^ basisVectorN] */			
				snprintf(tmpFloatBuf, <%TMP_BUF_LENGTH%>, fp, fabs(coord));
				if (atof(tmpFloatBuf) != 0.0) {
					l = 0;

					// print [+|-]
					l += snprintf(tmpBuf + l, <%TMP_BUF_LENGTH%>-l, "%s", (coord >= 0.0) 
						? (cnt ? <%S.m_namespace%>_string_plus : "")
						: <%S.m_namespace%>_string_minus);
						
					// print obj.m_c[k]
					l += snprintf(tmpBuf + l, <%TMP_BUF_LENGTH%>-l, tmpFloatBuf, dummyArg);

					if (i) { // if not grade 0, print [* basisVector1 ^ ... ^ basisVectorN]
						l += snprintf(tmpBuf + l, <%TMP_BUF_LENGTH%>-l, "%s", <%S.m_namespace%>_string_mul);

						// print all basis vectors
						bei = 0;
						while (<%S.m_namespace%>_basisElements[ia][bei] >= 0) {
							l += snprintf(tmpBuf + l, <%TMP_BUF_LENGTH%>-l, "%s%s", (bei) ? <%S.m_namespace%>_string_wedge : "", 
							 <%S.m_namespace%>_basisVectorNames[<%S.m_namespace%>_basisElements[ia][bei]]);
							 bei++;
						}
					}

					// copy all to 'str'
					if (stdIdx + l <= maxLength) {
						strcpy(str + stdIdx, tmpBuf);
						stdIdx += l;
					}
					else {
						snprintf(str, maxLength, "toString_<%S.m_floatTypes[0].GetMangledName(S, S.m_GMV.Name)%>: buffer too small");
						return str;
					}
					cnt++;
				}
				k++; ia++;
			}
		}
		else ia += <%S.m_namespace%>_groupSize[i];
	}

    // if no coordinates printed: 0
	l = 0;
	if (cnt == 0) {
		l += snprintf(tmpBuf + l, <%TMP_BUF_LENGTH%>-l, "0");
	}

    // end the string
	l += snprintf(tmpBuf + l, <%TMP_BUF_LENGTH%>-l, "%s", <%S.m_namespace%>_string_end);
	if (stdIdx + l <= maxLength) {
		strcpy(str + stdIdx, tmpBuf);
		stdIdx += l;
		return str;
	}
	else {
		snprintf(str, maxLength, "toString_<%S.m_floatTypes[0].GetMangledName(S, S.m_GMV.Name)%>: buffer too small\n");
		return str;
	}
}
<%}%>

${ENDCODEBLOCK}


// S = Specification of algebra.
// FT = floatType
${CODEBLOCK CustomParserHeader}

/** structure used by custom parser */
struct <%S.m_namespace%><%FT.GetMangledName(S, "ParseMultivectorData")%> {
	/** the parsed value (initialize this pointer to a valid multivector before calling) */
	<%FT.GetMangledName(S, S.m_GMV.Name)%> *value;
	/** this string will contain an error message when error is true */
	char message[256];
};

/** 
Parses 'str' (output of toString_<%FT.GetMangledName(S, S.m_GMV.Name)%>()) and stores result in 'val' 
Returns true when 'str' parsed correctly.
*/
int parse_<%FT.GetMangledName(S, S.m_GMV.Name)%>(<%FT.GetMangledName(S, S.m_GMV.Name)%> *val, const char *str);

/** 
Parses 'str' (output of toString_<%FT.GetMangledName(S, S.m_GMV.Name)%>()) and stores result in 'data'. 
'strSourceName' is the name of the source of 'str' (for example, a filename).
It is used for error messages.

Returns true when 'str' parsed correctly.
Otherwise a lexer or parser error occured and you can check 
the errors in 'data->message'.
*/
int parse_<%FT.GetMangledName(S, S.m_GMV.Name)%>Ex(struct <%S.m_namespace%><%FT.GetMangledName(S, "ParseMultivectorData")%> *data, const char *str, const char *strSourceName);
${ENDCODEBLOCK}


// S = Specification of algebra.
// FT = floatType
${CODEBLOCK ANTLRparserHeader}
/** structure used by ANTLR parser */
struct <%S.m_namespace%><%FT.GetMangledName(S, "ParseBasisBladeData")%> {
	/** internal: intermediate scale info (used while parsing basis element) */
	<%FT.type%> scale;
	/** internal: intermediate bitmap info (used while parsing basis element) */
	unsigned int bitmap;
};

/** structure used by ANTLR parser */
struct <%S.m_namespace%><%FT.GetMangledName(S, "ParseMultivectorData")%> {
	/** the parsed value */
	<%FT.GetMangledName(S, S.m_GMV.Name)%> *value;
	/** this string will contain an error message when error is true */
	char message[256];
};

/** wedges 'bv' to the basis blade in 'BB' */
void <%S.m_namespace%><%FT.GetMangledName(S, "ParseWedgeBasisVector")%>(const char *bv, struct <%S.m_namespace%><%FT.GetMangledName(S, "ParseBasisBladeData")%> *BB); 

/** adds 'scale*BB' to PD */
void <%S.m_namespace%><%FT.GetMangledName(S, "ParseSum")%>(<%FT.type%> coord[<%1<<S.m_dimension%>], <%FT.type%> scale, const struct <%S.m_namespace%><%FT.GetMangledName(S, "ParseBasisBladeData")%> *BB); 

/** initializes a struct <%S.m_namespace%><%FT.GetMangledName(S, "ParseMultivectorData")%>, making it ready for use */
void <%S.m_namespace%><%FT.GetMangledName(S, "ParseDataInit")%>(struct <%S.m_namespace%><%FT.GetMangledName(S, "ParseMultivectorData")%> *PD); 

/** 
Parses 'str' (output of toString_<%FT.GetMangledName(S, S.m_GMV.Name)%>()) and stores result in 'val' 
Returns true when 'str' parsed correctly.
*/
int parse_<%FT.GetMangledName(S, S.m_GMV.Name)%>(<%FT.GetMangledName(S, S.m_GMV.Name)%> *val, const char *str);

/** 
Parses 'str' (output of toString_<%FT.GetMangledName(S, S.m_GMV.Name)%>()) and stores result in 'data'. 
'strSourceName' is the name of the source of 'str' (for example, a filename).
It is used for error messages.

Returns true when 'str' parsed correctly.
Otherwise a lexer or parser error occured and you can check 
the errors in 'data->message'.
*/
int parse_<%FT.GetMangledName(S, S.m_GMV.Name)%>Ex(struct <%S.m_namespace%><%FT.GetMangledName(S, "ParseMultivectorData")%> *data, const char *str, const char *strSourceName);
${ENDCODEBLOCK}


// S = Specification of algebra.
// FT = float type
// arg1name = argument 1 name
// arg2name = argument 2 name
// dstName = argument 2 name
// gmvName = mangled name of GMV
// gpFuncName = gpFuncName
// reverseFuncName = reverseFuncName
// norm2FuncName = norm2FuncName
// divFuncName = divFuncName
${CODEBLOCK igp_GMV_GMV_body}
<%gmvName%> rev<%arg2name%>;
<%gmvName%> <%arg1name%>rev<%arg2name%>;
<%FT.type%> _N2_ = <%norm2FuncName%>(<%arg2name%>);

<%reverseFuncName%>(&rev<%arg2name%>, <%arg2name%>);
<%gpFuncName%>(&<%arg1name%>rev<%arg2name%>, <%arg1name%>, &rev<%arg2name%>);

<%divFuncName%>(<%dstName%>, &<%arg1name%>rev<%arg2name%>, _N2_);
${ENDCODEBLOCK}

// S = Specification of algebra.
// FT = float type
// arg1name = argument 1 name
// arg2name = argument 2 name
// dstName = argument 2 name
// gmvName = mangled name of GMV
// divFuncName = divFuncName
${CODEBLOCK igp_GMV_float_body}
<%divFuncName%>(<%dstName%>, <%arg1name%>, <%arg2name%>);
${ENDCODEBLOCK}

// S = Specification of algebra.
// FT = float type
// arg1name = argument 1 name
// arg2name = argument 2 name
// dstName = argument 2 name
// gmvName = mangled name of GMV
// mulFuncName = gpFuncName
// reverseFuncName = reverseFuncName
// norm2FuncName = norm2FuncName
// mulFuncName = divFuncName
${CODEBLOCK igp_float_GMV_body}
<%gmvName%> rev<%arg2name%>;
<%FT.type%> _N2_ = <%norm2FuncName%>(<%arg2name%>);

<%reverseFuncName%>(&rev<%arg2name%>, <%arg2name%>);
<%mulFuncName%>(<%dstName%>, &rev<%arg2name%>, <%arg1name%> / _N2_);
${ENDCODEBLOCK}

// S = Specification of algebra.
// MAX_N = maximum number of coordinates to set to zero explicitly
${CODEBLOCK float_zero_copy_decl}
<%foreach(G25.FloatType FT in S.m_floatTypes) {%>
<%for (int n = 1; n <= MAX_N; n++) {%>
/** Sets <%n%> <%FT.type%><%((n>1) ? "s" : "")%> to zero */
void <%S.m_namespace%>_<%FT.type%>_zero_<%n%>(<%FT.type%> *dst);
/** Copies <%n%> <%FT.type%><%((n>1) ? "s" : "")%> from 'src' to 'dst' */
void <%S.m_namespace%>_<%FT.type%>_copy_<%n%>(<%FT.type%> *dst, const <%FT.type%> *src);
<%}%>
/** Sets N <%FT.type%>s to zero */
void <%S.m_namespace%>_<%FT.type%>_zero_N(<%FT.type%> *dst, int N);
/** Copies N <%FT.type%>s from 'src' to 'dst' */
void <%S.m_namespace%>_<%FT.type%>_copy_N(<%FT.type%> *dst, const <%FT.type%> *src, int N);
<%}%>
${ENDCODEBLOCK}

// S = Specification of algebra.
// MAX_N = maximum number of coordinates to set to zero explicitly
${CODEBLOCK float_zero_copy_def}
<%foreach(G25.FloatType FT in S.m_floatTypes) {%>
<%for (int n = 1; n <= MAX_N; n++) {%>
void <%S.m_namespace%>_<%FT.type%>_zero_<%n%>(<%FT.type%> *dst) {
	<%for (int i = 0; i < n; i++) {%>dst[<%i%>]=<%}%><%FT.DoubleToString(S, 0.0)%>;
}
void <%S.m_namespace%>_<%FT.type%>_copy_<%n%>(<%FT.type%> *dst, const <%FT.type%> *src) {
<%for (int i = 0; i < n; i++) {%>
	dst[<%i%>] = src[<%i%>];
<%}%>
}
<%}%>
/** Sets N <%FT.type%>s to zero */
void <%S.m_namespace%>_<%FT.type%>_zero_N(<%FT.type%> *dst, int N) {
	int i = 0;
	while ((N-i) > <%MAX_N%>) {
		<%S.m_namespace%>_<%FT.type%>_zero_<%MAX_N%>(dst + i);
		i += <%MAX_N%>;
	}
	for (; i < N; i++)
		dst[i] = <%FT.DoubleToString(S, 0.0)%>;
}
/** Copies N <%FT.type%>s from 'src' to 'dst' */
void <%S.m_namespace%>_<%FT.type%>_copy_N(<%FT.type%> *dst, const <%FT.type%> *src, int N) {
	int i = 0;
	while ((N-i) > <%MAX_N%>) {
		<%S.m_namespace%>_<%FT.type%>_copy_<%MAX_N%>(dst + i, src + i);
		i += <%MAX_N%>;
	}
	for (; i < N; i++)
		dst[i] = src[i];
}
<%}%>
${ENDCODEBLOCK}

// same arguments as logEuclidean
${CODEBLOCK logEuclideanHeader}
/**
Returns logarithm of 3-D Euclidean rotor.
*/
void <%functionName%>(<%mvType%> *dst, const <%mvType%> *src);
${ENDCODEBLOCK}

// S = Specification of algebra.
// functionName = name of generated function
// FT = floating point type
// mvType = multivector type name (with prefix/suffix)
// setPlaneFuncName = Name of function to set coordinate of some Euclidean bivector coordinate.
// randomScalarFuncName = name of function which generates random scalar values
// scalarGpFuncName = geometric product of multivector and scalar
// norm2FuncName = Euclidean norm, squared of multivector
// grade2FuncName = extract grade 2 part of multivector
${CODEBLOCK logEuclidean}

void <%functionName%>(<%mvType%> *dst, const <%mvType%> *src) {
	<%FT.type%> _g2norm2_ = <%norm2FuncName%>(src);
	<%FT.type%> _scalarPart_ = <%mvType%>_scalar(src);
	<%FT.type%> _g2norm_;
	<%mvType%> grade2part;

	if (_g2norm2_ <= <%FT.DoubleToString(S, 0.0)%>) {
		if (_scalarPart_ < <%FT.DoubleToString(S, 0.0)%>) {
			<%mvType%>_setZero(dst);
			<%mvType%>_<%setPlaneFuncName%>(dst, <%FT.DoubleToString(S, Math.PI)%>);
		}
		else {
			<%mvType%>_setZero(dst);
		}
	}
	else {
		_g2norm_ = (<%FT.type%>)sqrt(_g2norm2_);

		<%grade2FuncName%>(&grade2part, src);

		<%scalarGpFuncName%>(dst, &grade2part, (<%FT.type%>)atan2(_g2norm_, _scalarPart_)/_g2norm_);
	}
}

${ENDCODEBLOCK}

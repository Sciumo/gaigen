// arguments: 
// Namespace = name of algebra.
// Gaigen = name and version of Gaigen
// License = full text of license.
${CODEBLOCK doxyMainPage}
/*! \mainpage <%Namespace%> documentation
 *
 * <%Namespace%> implementation generated by <%Gaigen%>. 
 * 
 * 
 * License: 
<%License%>  
 * 
 * \section intro_sec Introduction
 *
 * Todo
 * 
 */
${ENDCODEBLOCK}


// S = Specification of algebra.
${CODEBLOCK basicInfo}

/// The dimension of the space:
extern const int <%S.m_namespace%>_spaceDim;

/// Number of groups/grades of coordinates in multivector:
extern const int <%S.m_namespace%>_nbGroups;

/// The constants for the grades/groups in an array:
extern const int <%S.m_namespace%>_groups[];

/// Is the metric of the space Euclidean? (0 or 1)
extern const int <%S.m_namespace%>_metricEuclidean;

/// This array can be used to lookup the number of coordinates for a group part of a general multivector
extern const int <%S.m_namespace%>_groupSize[<%S.m_GMV.NbGroups%>];

/// This array can be used to lookup the number of coordinates based on a group usage bitmap
extern const int <%S.m_namespace%>_mvSize[<%1<<S.m_GMV.NbGroups%>];

/// This array of ASCIIZ strings contains the names of the basis vectors
extern const char *<%S.m_namespace%>_basisVectorNames[<%S.m_dimension%>];

/// This array of integers contains the order of basis elements in the general multivector
/// Use it to answer: 'what basis vectors are in the basis element at position [x]?
extern const int <%S.m_namespace%>_basisElements[<%1<<S.m_dimension%>][<%S.m_dimension+1%>];

/// This array of integers contains the 'sign' (even/odd permutation of canonical order) of basis elements in the general multivector
/// Use it to answer 'what is the permutation of the coordinate at index [x]'?
extern const double <%S.m_namespace%>_basisElementSignByIndex[<%1<<S.m_dimension%>];

/// This array of integers contains the 'sign' (even/odd permutation of canonical order) of basis elements in the general multivector
/// Use it to answer 'what is the permutation of the coordinate of bitmap [x]'?
extern const double <%S.m_namespace%>_basisElementSignByBitmap[<%1<<S.m_dimension%>];

/// This array of integers contains the order of basis elements in the general multivector
/// Use it to answer: 'at what index do I find basis element [x] (x = basis vector bitmap)?'
extern const int <%S.m_namespace%>_basisElementIndexByBitmap[<%1<<S.m_dimension%>];

/// This array of integers contains the indices of basis elements in the general multivector
/// Use it to answer: 'what basis element do I find at index [x]'?
extern const int <%S.m_namespace%>_basisElementBitmapByIndex[<%1<<S.m_dimension%>];

/// This array of grade of each basis elements in the general multivector
/// Use it to answer: 'what is the grade of basis element bitmap [x]'?
extern const int <%S.m_namespace%>_basisElementGradeByBitmap[<%1<<S.m_dimension%>];
${ENDCODEBLOCK}

// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// gmv = general multivector (G25.GMV)
${CODEBLOCK compress}
/** This function is not for external use. It compresses arrays of floats for storage in multivectors. */
void <%FT.GetMangledName("compress")%>(const <%FT.type%> *c, <%FT.type%> *cc, int *cgu, <%FT.type%> epsilon, int gu) {
	int i, j, ia = 0, ib = 0, f, s;
	cgu = 0;

	// for all grade parts...
	for (i = 0; i <= <%gmv.NbGroups%>; i++) {
		// check if grade part has memory use:
		if (!(gu & (1 << i))) continue;

		// check if abs coordinates of grade part are all < epsilon
		s = <%S.m_namespace%>_groupSize[i];
		j = ia + s;
		f = 0;
		for (; ia < j; ia++)
			if (fabs<%((FT.type == "float") ? "f" : "")%>(c[ia]) >= epsilon) {f = 1; break;}
		ia = j;
		if (f) {
			memcpy(cc + ib, c + ia - s, s * sizeof(<%FT.type%>));
			ib += s;
			*cgu |= (1 << i);
		}
	}	
}

/** This function is not for external use. It decompresses the coordinates stored in this */
void <%FT.GetMangledName("expand")%>(const <%FT.type%> *ptrs[<%(1+S.m_dimension)%>], const <%FT.GetMangledName(gmv.Name)%> *src) {
	const <%FT.type%> *c = src->c;
	
<%for (int i = 0; i < gmv.NbGroups; i++) {%>
	if (src->gu & <%1 << i%>) {
		ptrs[<%i%>] =  c;
<%if (i != (gmv.NbGroups-1)) {%>
		c += <%gmv.Group(i).Length%>;
<%}%>
	}
	else ptrs[<%i%>] = NULL;	
<%}%>
}

${ENDCODEBLOCK}

${CODEBLOCK seriesSinDecl}
/** Computes sine of <%inputType%>.
<%userComment%> */
void sin_<%inputType%>(<%returnType%> *R, const <%inputType%> *x, int order);
${ENDCODEBLOCK}

// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesSin}

void <%returnType%>_swapPointerSin(<%returnType%> *P1, <%returnType%> *P2)
{
	<%returnType%> *tmp = P1;
	P1 = P2;
	P2 = tmp;
}

void sin_<%inputType%>(<%returnType%> *R, const <%inputType%> *x, int order) {
	<%returnType%> tmp1, tmp2, tmp3; // temp <%returnType%> used for various purposes
	<%returnType%> *xPow1 = &tmp1, *xPow2 = &tmp2; // xScaled^... goes here
	<%returnType%> *result1 = R, *result2 = &tmp3; // accumulated result goes here (note: 'result1' = 'R')
	<%FT.type%> s_x2, a;
	int i;
   
	// First try special cases: check if (x * x) is scalar
	<%gpFuncII%>(&tmp1, x, x);
	s_x2 = <%scalarTmp1%>;
	if ((<%normE2funcR%>(&tmp1) - s_x2 * s_x2) < 1e-7f) {
		// OK (x * x == ~scalar), so use special cases:
		if (s_x2 < 0.0) {
			a = <%sqrtFunc%>(-s_x2);
			<%SASfuncI%>(R, x, <%sinhFunc%>(a) / a, <%FT.DoubleToString(S, 0.0)%>);
			return;
		}
		else if (s_x2 > 0.0) {
			a = <%sqrtFunc%>(s_x2);
			<%SASfuncI%>(R, x, <%sinFunc%>(a) / a, <%FT.DoubleToString(S, 0.0)%>);
			return;
		}
		else {
			<%copyInputToReturnFunc%>(R, x);
			return;
		}
	}

	// else do general series eval . . .

	// result = A -  ....	+ ... - ...
	<%returnType%>_setZero(result1);
    	if (order == 0) return;
    	
	// taylor series approximation
	<%returnType%>_setScalar(xPow1, <%FT.DoubleToString(S, 1.0)%>); // xPow1 = 1.0
	for (i = 1; i <= order; i++) {
		<%gpFuncRI%>(xPow2, xPow1, x); // xPow2 = xPow1 * x
		
		<%gpFuncRdouble%>(xPow1, xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i); // xPow1 = xScaled^i / i! 
		if ((i % 4) == 3)
		{
			<%subFuncRR%>(result2, result1, xPow1); // result2 = result1 - xPow1
			<%returnType%>_swapPointerSin(result1, result2); // result is always in 'result1' at end of loop
		}
		else if ((i % 4) == 1) 
		{
			<%addFuncRR%>(result2, result1, xPow1); // result2 = result1 + xPow1
			<%returnType%>_swapPointerSin(result1, result2); // result is always in 'result1' at end of loop
		}
	}

    
	if (R != result1) { // if result does not reside in 'R' in the end, do an explicit copy
		<%returnType%>_copy(R, result2);
	}
} // end of sin_<%inputType%>()

${ENDCODEBLOCK}


${CODEBLOCK seriesCosDecl}
/** Computes cosine of <%inputType%>. 
<%userComment%> */
void cos_<%inputType%>(<%returnType%> *R, const <%inputType%> *x, int order);
${ENDCODEBLOCK}

// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesCos}

void <%returnType%>_swapPointerCos(<%returnType%> *P1, <%returnType%> *P2)
{
	<%returnType%> *tmp = P1;
	P1 = P2;
	P2 = tmp;
}

void cos_<%inputType%>(<%returnType%> *R, const <%inputType%> *x, int order) {
	<%returnType%> tmp1, tmp2, tmp3; // temp <%returnType%> used for various purposes
	<%returnType%> *xPow1 = &tmp1, *xPow2 = &tmp2; // xScaled^... goes here
	<%returnType%> *result1 = R, *result2 = &tmp3; // accumulated result goes here (note: 'result1' = 'R')
	<%FT.type%> s_x2, a;
	int i;
   
	// First try special cases: check if (x * x) is scalar
	<%gpFuncII%>(&tmp1, x, x);
	s_x2 = <%scalarTmp1%>;
	if ((<%normE2funcR%>(&tmp1) - s_x2 * s_x2) < 1e-7f) {
		// OK (x * x == ~scalar), so use special cases:
		if (s_x2 > 0.0) {
			a = <%sqrtFunc%>(s_x2);
			<%returnType%>_setScalar(R, <%cosFunc%>(a));
			return;
		}
		else if (s_x2 < 0.0) {
			a = <%sqrtFunc%>(-s_x2);
			<%returnType%>_setScalar(R, <%coshFunc%>(a));
			return;
		}
		else {
			<%returnType%>_setScalar(R, <%FT.DoubleToString(S, 1.0)%>);
			return;
		}
	}

	// else do general series eval . . .


	<%returnType%>_setScalar(result1, <%FT.DoubleToString(S, 1.0)%>);
	if (order == 0) return;

	// taylor series approximation
	<%returnType%>_setScalar(xPow1, <%FT.DoubleToString(S, 1.0)%>); // xPow1 = 1.0
	for (i = 1; i <= order; i++) {
		<%gpFuncRI%>(xPow2, xPow1, x); // xPow2 = xPow1 * x
		<%gpFuncRdouble%>(xPow1, xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i); // xPow1 = xScaled^i / i! 
		
		if ((i % 4) == 2)
		{
			<%subFuncRR%>(result2, result1, xPow1); // result2 = result1 - xPow1
			<%returnType%>_swapPointerCos(result1, result2); // result is always in 'result1' at end of loop
		}
		else if ((i % 4) == 0) 
		{
			<%addFuncRR%>(result2, result1, xPow1); // result2 = result1 + xPow1
			<%returnType%>_swapPointerCos(result1, result2); // result is always in 'result1' at end of loop
		}
		
		<%addFuncRR%>(result2, result1, xPow1); // result2 = result1 + xPow1
		<%returnType%>_swapPointerSin(result1, result2); // result is always in 'result1' at end of loop
    }

    
	if (R != result1) { // if result does not reside in 'R' in the end, do an explicit copy
		<%returnType%>_copy(R, result2);
	}
} // end of cos_<%inputType%>()

${ENDCODEBLOCK}


${CODEBLOCK seriesExpDecl}
/** Computes exponetial of <%inputType%>. 
<%userComment%> */
void exp_<%inputType%>(<%returnType%> *R, const <%inputType%> *x, int order);
${ENDCODEBLOCK}

// S = Specification of algebra. (G25.spec)
// FT = floating point type (G25.FloatType)
// inputType = mangled name of input type
// returnType = mangled name of return type
// gpFuncII = mangled name of geometric product of (inputType, inputType)
// gpFuncRI = mangled name of geometric product of (returnType, inputType)
// gpFuncRR = mangled name of geometric product of (returnType, returnType)
// gpFuncIdouble = mangled name of geometric product of (inputType, double)
// gpFuncRdouble = mangled name of geometric product of (returnType, double)
// subFuncRR = mangled name of subtraction of (returnType, returnType)
// addFuncRR = mangled name of addition of (returnType, returnType)
// normE2funcR = mangled name of norm2 of (returnType)
// SASfuncI = Scale and add scalar (input type)
// sqrtFunc
// cosFunc
// sinFunc
// coshFunc
// sinhFunc
${CODEBLOCK seriesExp}

void <%returnType%>_swapPointerExp(<%returnType%> *P1, <%returnType%> *P2)
{
	<%returnType%> *tmp = P1;
	P1 = P2;
	P2 = tmp;
}

void exp_<%inputType%>(<%returnType%> *R, const <%inputType%> *x, int order) {
	unsigned long maxC, scale = 1;
	<%inputType%> xScaled;
	<%returnType%> tmp1, tmp2, tmp3; // temp <%returnType%> used for various purposes
	<%returnType%> *xPow1 = &tmp1, *xPow2 = &tmp2; // xScaled^... goes here
	<%returnType%> *result1 = R, *result2 = &tmp3; // accumulated result goes here (note: 'result1' = 'R')
	<%FT.type%> s_x2, a;
	int i;
   
	// First try special cases: check if (x * x) is scalar
	<%gpFuncII%>(&tmp1, x, x);
	s_x2 = <%scalarTmp1%>;
	if ((<%normE2funcR%>(&tmp1) - s_x2 * s_x2) < 1e-7f) {
		// OK (x * x == ~scalar), so use special cases:
		if (s_x2 < 0.0) {
			a = <%sqrtFunc%>(-s_x2);
			<%SASfuncI%>(R, x, <%sinFunc%>(a) / a, <%cosFunc%>(a));
			return;
		}
		else if (s_x2 > 0.0) {
			a = <%sqrtFunc%>(s_x2);
			<%SASfuncI%>(R, x, <%sinhFunc%>(a) / a, <%coshFunc%>(a));
			return;
		}
		else {
			<%SASfuncI%>(R, x, <%FT.DoubleToString(S, 1.0)%>, <%FT.DoubleToString(S, 1.0)%>);
			return;
		}
	}

	// else do general series eval . . .

	// result = 1 + ....	
	<%returnType%>_setScalar(result1, <%FT.DoubleToString(S, 1.0)%>);
	if (order == 0) return;

	// find scale (power of 2) such that its norm is < 1
	maxC = (unsigned long)<%inputType%>_largestCoordinate(x);
	scale = 1;
	if (maxC > 1) scale <<= 1;
	while (maxC)
	{
		maxC >>= 1;
		scale <<= 1;
	}

	// scale
	<%gpFuncIdouble%>(&xScaled, x, (<%FT.type%>)scale); // xScaled = x * scale

	// taylor series approximation
	<%returnType%>_setScalar(xPow1, <%FT.DoubleToString(S, 1.0)%>); // xPow1 = 1.0
	for (i = 1; i <= order; i++) {
		<%gpFuncRI%>(xPow2, xPow1, &xScaled); // xPow2 = xPow1 * xScaled
		<%gpFuncRdouble%>(xPow1, xPow2, <%FT.DoubleToString(S, 1.0)%> / (<%FT.type%>)i); // xPow1 = xScaled^i / i! 
		<%addFuncRR%>(result2, result1, xPow1); // result2 = result1 + xPow1
		<%returnType%>_swapPointerExp(result1, result2); // result is always in 'result1' at end of loop
    }

	// undo scaling
	while (scale > 1)
	{
		<%gpFuncRR%>(result2, result1, result1); // result2 = result1 * result1
		<%returnType%>_swapPointerExp(result1, result2); // result is always in 'result1' at end of loop
		scale >>= 1;
	}
    
	if (R != result1) { // if result does not reside in 'R' in the end, do an explicit copy
		<%returnType%>_copy(R, result2);
	}
} // end of exp_<%inputType%>()

${ENDCODEBLOCK}
